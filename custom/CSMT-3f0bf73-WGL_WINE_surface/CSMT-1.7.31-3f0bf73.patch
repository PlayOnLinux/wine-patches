diff --git a/configure b/configure
index de03151..d09438e 100755
--- a/configure
+++ b/configure
@@ -932,6 +932,7 @@ enable_crtdll
 enable_crypt32
 enable_cryptdlg
 enable_cryptdll
+enable_cryptext
 enable_cryptnet
 enable_cryptui
 enable_ctapi32
@@ -16861,6 +16862,7 @@ wine_fn_config_dll crypt32 enable_crypt32 implib,po
 wine_fn_config_test dlls/crypt32/tests crypt32_test
 wine_fn_config_dll cryptdlg enable_cryptdlg po
 wine_fn_config_dll cryptdll enable_cryptdll implib
+wine_fn_config_dll cryptext enable_cryptext
 wine_fn_config_dll cryptnet enable_cryptnet implib
 wine_fn_config_test dlls/cryptnet/tests cryptnet_test
 wine_fn_config_dll cryptui enable_cryptui implib,po
diff --git a/configure.ac b/configure.ac
index 4ee8133..04bcbd8 100644
--- a/configure.ac
+++ b/configure.ac
@@ -2741,6 +2741,7 @@ WINE_CONFIG_DLL(crypt32,,[implib,po])
 WINE_CONFIG_TEST(dlls/crypt32/tests)
 WINE_CONFIG_DLL(cryptdlg,,[po])
 WINE_CONFIG_DLL(cryptdll,,[implib])
+WINE_CONFIG_DLL(cryptext)
 WINE_CONFIG_DLL(cryptnet,,[implib])
 WINE_CONFIG_TEST(dlls/cryptnet/tests)
 WINE_CONFIG_DLL(cryptui,,[implib,po])
diff --git a/dlls/advapi32/security.c b/dlls/advapi32/security.c
index cc20033..097b0da 100644
--- a/dlls/advapi32/security.c
+++ b/dlls/advapi32/security.c
@@ -187,7 +187,6 @@ static const WCHAR CREATOR_OWNER_SERVER[] = { 'C','R','E','A','T','O','R',' ','O
 static const WCHAR CURRENT_USER[] = { 'C','U','R','R','E','N','T','_','U','S','E','R',0 };
 static const WCHAR DIALUP[] = { 'D','I','A','L','U','P',0 };
 static const WCHAR Digest_Authentication[] = { 'D','i','g','e','s','t',' ','A','u','t','h','e','n','t','i','c','a','t','i','o','n',0 };
-static const WCHAR DOMAIN[] = {'D','O','M','A','I','N',0};
 static const WCHAR Domain_Admins[] = { 'D','o','m','a','i','n',' ','A','d','m','i','n','s',0 };
 static const WCHAR Domain_Computers[] = { 'D','o','m','a','i','n',' ','C','o','m','p','u','t','e','r','s',0 };
 static const WCHAR Domain_Controllers[] = { 'D','o','m','a','i','n',' ','C','o','n','t','r','o','l','l','e','r','s',0 };
@@ -324,12 +323,8 @@ static const WCHAR SDDL_AUTO_INHERITED[]        = {'A','I',0};
  */
 static const WCHAR SDDL_ACCESS_ALLOWED[]        = {'A',0};
 static const WCHAR SDDL_ACCESS_DENIED[]         = {'D',0};
-static const WCHAR SDDL_OBJECT_ACCESS_ALLOWED[] = {'O','A',0};
-static const WCHAR SDDL_OBJECT_ACCESS_DENIED[]  = {'O','D',0};
 static const WCHAR SDDL_AUDIT[]                 = {'A','U',0};
 static const WCHAR SDDL_ALARM[]                 = {'A','L',0};
-static const WCHAR SDDL_OBJECT_AUDIT[]          = {'O','U',0};
-static const WCHAR SDDL_OBJECT_ALARMp[]         = {'O','L',0};
 
 /*
  * ACE flags
diff --git a/dlls/advpack/files.c b/dlls/advpack/files.c
index 1e555f7..c5efbb2 100644
--- a/dlls/advpack/files.c
+++ b/dlls/advpack/files.c
@@ -567,7 +567,7 @@ static LPSTR convert_file_list(LPCSTR FileList, DWORD *dwNumFiles)
     szConvertedList[dwLen - 1] = '\0';
 
     /* empty list */
-    if (!lstrlenA(szConvertedList))
+    if (!szConvertedList[0])
     {
         HeapFree(GetProcessHeap(), 0, szConvertedList);
         return NULL;
diff --git a/dlls/appwiz.cpl/addons.c b/dlls/appwiz.cpl/addons.c
index 3dfd28e..3a7d35d 100644
--- a/dlls/appwiz.cpl/addons.c
+++ b/dlls/appwiz.cpl/addons.c
@@ -65,8 +65,8 @@ WINE_DEFAULT_DEBUG_CHANNEL(appwizcpl);
 #define GECKO_SHA "???"
 #endif
 
-#define MONO_VERSION "4.5.2"
-#define MONO_SHA "73d6b8aa7a8921f43b22c6d930e8d7e421058187"
+#define MONO_VERSION "4.5.4"
+#define MONO_SHA "2b271d0bc92d5c9c45febd76fb11f9fcc29ea6d8"
 
 typedef struct {
     const char *version;
diff --git a/dlls/comctl32/string.c b/dlls/comctl32/string.c
index 4c52f18..112d9d3 100644
--- a/dlls/comctl32/string.c
+++ b/dlls/comctl32/string.c
@@ -291,7 +291,7 @@ LPSTR WINAPI StrChrA(LPCSTR lpszStr, WORD ch)
  * PARAMS
  *  lpszStr  [I] First string to compare
  *  lpszComp [I] Second string to compare
- *  iLen     [I] Maximum number of chars to compare.
+ *  iLen     [I] Number of chars to compare
  *
  * RETURNS
  *  An integer less than, equal to or greater than 0, indicating that
@@ -323,13 +323,15 @@ static LPSTR COMCTL32_StrStrHelperA(LPCSTR lpszStr, LPCSTR lpszSearch,
                                     INT (WINAPI *pStrCmpFn)(LPCSTR,LPCSTR,INT))
 {
   size_t iLen;
+  LPCSTR end;
 
   if (!lpszStr || !lpszSearch || !*lpszSearch)
     return NULL;
 
   iLen = strlen(lpszSearch);
+  end = lpszStr + strlen(lpszStr);
 
-  while (*lpszStr)
+  while (lpszStr + iLen <= end)
   {
     if (!pStrCmpFn(lpszStr, lpszSearch, iLen))
       return (LPSTR)lpszStr;
@@ -382,6 +384,7 @@ INT WINAPI StrToIntA (LPCSTR lpszStr)
 LPWSTR WINAPI StrStrIW(LPCWSTR lpszStr, LPCWSTR lpszSearch)
 {
   int iLen;
+  LPCWSTR end;
 
   TRACE("(%s,%s)\n", debugstr_w(lpszStr), debugstr_w(lpszSearch));
 
@@ -389,8 +392,9 @@ LPWSTR WINAPI StrStrIW(LPCWSTR lpszStr, LPCWSTR lpszSearch)
     return NULL;
 
   iLen = strlenW(lpszSearch);
+  end = lpszStr + strlenW(lpszStr);
 
-  while (*lpszStr)
+  while (lpszStr + iLen <= end)
   {
     if (!StrCmpNIW(lpszStr, lpszSearch, iLen))
       return (LPWSTR)lpszStr;
@@ -480,7 +484,7 @@ LPWSTR WINAPI StrChrW(LPCWSTR lpszStr, WCHAR ch)
  * PARAMS
  *  lpszStr  [I] First string to compare
  *  lpszComp [I] Second string to compare
- *  iLen     [I] Maximum number of chars to compare.
+ *  iLen     [I] Number of chars to compare
  *
  * RETURNS
  *  An integer less than, equal to or greater than 0, indicating that
@@ -670,18 +674,20 @@ LPSTR WINAPI StrRStrIA(LPCSTR lpszStr, LPCSTR lpszEnd, LPCSTR lpszSearch)
   if (!lpszStr || !lpszSearch || !*lpszSearch)
     return NULL;
 
-  if (!lpszEnd)
-    lpszEnd = lpszStr + lstrlenA(lpszStr);
-
   if (IsDBCSLeadByte(*lpszSearch))
-    ch1 = *lpszSearch << 8 | lpszSearch[1];
+    ch1 = *lpszSearch << 8 | (UCHAR)lpszSearch[1];
   else
     ch1 = *lpszSearch;
   iLen = lstrlenA(lpszSearch);
 
-  while (lpszStr <= lpszEnd  && *lpszStr)
+  if (!lpszEnd)
+    lpszEnd = lpszStr + lstrlenA(lpszStr);
+  else /* reproduce the broken behaviour on Windows */
+    lpszEnd += min(iLen - 1, lstrlenA(lpszEnd));
+
+  while (lpszStr + iLen <= lpszEnd && *lpszStr)
   {
-    ch2 = IsDBCSLeadByte(*lpszStr)? *lpszStr << 8 | lpszStr[1] : *lpszStr;
+    ch2 = IsDBCSLeadByte(*lpszStr)? *lpszStr << 8 | (UCHAR)lpszStr[1] : *lpszStr;
     if (!COMCTL32_ChrCmpIA(ch1, ch2))
     {
       if (!StrCmpNIA(lpszStr, lpszSearch, iLen))
@@ -707,12 +713,15 @@ LPWSTR WINAPI StrRStrIW(LPCWSTR lpszStr, LPCWSTR lpszEnd, LPCWSTR lpszSearch)
   if (!lpszStr || !lpszSearch || !*lpszSearch)
     return NULL;
 
+  iLen = strlenW(lpszSearch);
+
   if (!lpszEnd)
     lpszEnd = lpszStr + strlenW(lpszStr);
+  else /* reproduce the broken behaviour on Windows */
+    lpszEnd += min(iLen - 1, lstrlenW(lpszEnd));
 
-  iLen = strlenW(lpszSearch);
 
-  while (lpszStr <= lpszEnd  && *lpszStr)
+  while (lpszStr + iLen <= lpszEnd && *lpszStr)
   {
     if (!COMCTL32_ChrCmpIW(*lpszSearch, *lpszStr))
     {
diff --git a/dlls/comctl32/syslink.c b/dlls/comctl32/syslink.c
index a5ba3dd..eeb46b9 100644
--- a/dlls/comctl32/syslink.c
+++ b/dlls/comctl32/syslink.c
@@ -184,6 +184,26 @@ static VOID SYSLINK_ClearDoc (SYSLINK_INFO *infoPtr)
 }
 
 /***********************************************************************
+ * SYSLINK_StrCmpNIW
+ * Wrapper for StrCmpNIW to ensure 'len' is not too big.
+ */
+static INT SYSLINK_StrCmpNIW (LPCWSTR str, LPCWSTR comp, INT len)
+{
+    INT i;
+
+    for(i = 0; i < len; i++)
+    {
+        if(!str[i])
+        {
+            len = i + 1;
+            break;
+        }
+    }
+
+    return StrCmpNIW(str, comp, len);
+}
+
+/***********************************************************************
  * SYSLINK_ParseText
  * Parses the window text string and creates a document. Returns the
  * number of document items created.
@@ -203,7 +223,7 @@ static UINT SYSLINK_ParseText (SYSLINK_INFO *infoPtr, LPCWSTR Text)
     {
         if(*current == '<')
         {
-            if(!StrCmpNIW(current, SL_LINKOPEN, 2) && (CurrentType == slText))
+            if(!SYSLINK_StrCmpNIW(current, SL_LINKOPEN, 2) && (CurrentType == slText))
             {
                 BOOL ValidParam = FALSE, ValidLink = FALSE;
 
@@ -231,14 +251,14 @@ static UINT SYSLINK_ParseText (SYSLINK_INFO *infoPtr, LPCWSTR Text)
                     
 CheckParameter:
                     /* compare the current position with all known parameters */
-                    if(!StrCmpNIW(tmp, SL_HREF, 6))
+                    if(!SYSLINK_StrCmpNIW(tmp, SL_HREF, 6))
                     {
                         taglen += 6;
                         ValidParam = TRUE;
                         CurrentParameter = &lpUrl;
                         CurrentParameterLen = &lenUrl;
                     }
-                    else if(!StrCmpNIW(tmp, SL_ID, 4))
+                    else if(!SYSLINK_StrCmpNIW(tmp, SL_ID, 4))
                     {
                         taglen += 4;
                         ValidParam = TRUE;
@@ -312,7 +332,7 @@ CheckParameter:
                     }
                 }
             }
-            else if(!StrCmpNIW(current, SL_LINKCLOSE, 4) && (CurrentType == slLink) && firsttag)
+            else if(!SYSLINK_StrCmpNIW(current, SL_LINKCLOSE, 4) && (CurrentType == slLink) && firsttag)
             {
                 /* there's a <a...> tag opened, first add the previous text, if present */
                 if(textstart != NULL && textlen > 0 && firsttag > textstart)
diff --git a/dlls/comctl32/tests/button.c b/dlls/comctl32/tests/button.c
index eb4e924..badd8a7 100644
--- a/dlls/comctl32/tests/button.c
+++ b/dlls/comctl32/tests/button.c
@@ -427,13 +427,6 @@ static const struct message setcheck_ignored_seq[] =
     { 0 }
 };
 
-static const struct message setcheck_uncheck_seq[] =
-{
-    { BM_SETCHECK, sent },
-    { WM_APP, sent|wparam|lparam, 0, 0 },
-    { 0 }
-};
-
 static const struct message setcheck_static_seq[] =
 {
     { BM_SETCHECK, sent },
diff --git a/dlls/comctl32/tests/tab.c b/dlls/comctl32/tests/tab.c
index 2b7f6d3..f832fef 100644
--- a/dlls/comctl32/tests/tab.c
+++ b/dlls/comctl32/tests/tab.c
@@ -77,28 +77,6 @@ static HWND parent_wnd;
 
 static struct msg_sequence *sequences[NUM_MSG_SEQUENCES];
 
-static const struct message create_parent_wnd_seq[] = {
-    { WM_GETMINMAXINFO, sent },
-    { WM_NCCREATE, sent },
-    { WM_NCCALCSIZE, sent|wparam, 0 },
-    { WM_CREATE, sent },
-    { WM_SHOWWINDOW, sent|wparam, 1 },
-    { WM_WINDOWPOSCHANGING, sent|wparam, 0 },
-    { WM_WINDOWPOSCHANGING, sent|wparam, 0 },
-    { WM_ACTIVATEAPP, sent|wparam, 1 },
-    { WM_NCACTIVATE, sent|wparam, 1 },
-    { WM_ACTIVATE, sent|wparam, 1 },
-    { WM_IME_SETCONTEXT, sent|wparam|defwinproc|optional, 1 },
-    { WM_IME_NOTIFY, sent|defwinproc|optional },
-    { WM_SETFOCUS, sent|wparam|defwinproc, 0 },
-    /* Win9x adds SWP_NOZORDER below */
-    { WM_WINDOWPOSCHANGED, sent},
-    { WM_NCCALCSIZE, sent|wparam|optional, 1 },
-    { WM_SIZE, sent },
-    { WM_MOVE, sent },
-    { 0 }
-};
-
 static const struct message add_tab_to_parent[] = {
     { TCM_INSERTITEMA, sent },
     { TCM_INSERTITEMA, sent|optional },
@@ -158,12 +136,6 @@ static const struct message empty_sequence[] = {
     { 0 }
 };
 
-static const struct message set_min_tab_width_seq[] = {
-    { TCM_SETMINTABWIDTH, sent|wparam, 0 },
-    { TCM_SETMINTABWIDTH, sent|wparam, 0 },
-    { 0 }
-};
-
 static const struct message get_item_count_seq[] = {
     { TCM_GETITEMCOUNT, sent|wparam|lparam, 0, 0 },
     { 0 }
diff --git a/dlls/comdlg32/filedlg.c b/dlls/comdlg32/filedlg.c
index 2738467..e0939ef 100644
--- a/dlls/comdlg32/filedlg.c
+++ b/dlls/comdlg32/filedlg.c
@@ -1586,39 +1586,37 @@ static LRESULT FILEDLG95_InitControls(HWND hwnd)
   /* 2. (All platforms) If initdir is not null, then use it */
   if (!handledPath && fodInfos->initdir && *fodInfos->initdir)
   {
-      /* Work out the proper path as supplied one might be relative          */
-      /* (Here because supplying '.' as dir browses to My Computer)          */
-      if (!handledPath) {
-          WCHAR tmpBuf[MAX_PATH];
-          WCHAR tmpBuf2[MAX_PATH];
-          WCHAR *nameBit;
-          DWORD result;
-
-          lstrcpyW(tmpBuf, fodInfos->initdir);
-          if( PathFileExistsW(tmpBuf) ) {
-              /* initdir does not have to be a directory. If a file is
-               * specified, the dir part is taken */
-              if( PathIsDirectoryW(tmpBuf)) {
-                  PathAddBackslashW( tmpBuf );
-                  lstrcatW(tmpBuf, szwStar);
-              }
-              result = GetFullPathNameW(tmpBuf, MAX_PATH, tmpBuf2, &nameBit);
-              if (result) {
-                 *nameBit = 0x00;
-                 MemFree(fodInfos->initdir);
-                 fodInfos->initdir = MemAlloc((lstrlenW(tmpBuf2) + 1)*sizeof(WCHAR));
-                 lstrcpyW(fodInfos->initdir, tmpBuf2);
-                 handledPath = TRUE;
-                 TRACE("Value in InitDir changed to %s\n", debugstr_w(fodInfos->initdir));
-              }
-          }
-          else if (fodInfos->initdir)
-          {
-                    MemFree(fodInfos->initdir);
-                    fodInfos->initdir = NULL;
-                    TRACE("Value in InitDir is not an existing path, changed to (nil)\n");
-          }
-      }
+        /* Work out the proper path as supplied one might be relative          */
+        /* (Here because supplying '.' as dir browses to My Computer)          */
+        WCHAR tmpBuf[MAX_PATH];
+        WCHAR tmpBuf2[MAX_PATH];
+        WCHAR *nameBit;
+        DWORD result;
+
+        lstrcpyW(tmpBuf, fodInfos->initdir);
+        if (PathFileExistsW(tmpBuf)) {
+            /* initdir does not have to be a directory. If a file is
+             * specified, the dir part is taken */
+            if (PathIsDirectoryW(tmpBuf)) {
+                PathAddBackslashW(tmpBuf);
+                lstrcatW(tmpBuf, szwStar);
+            }
+            result = GetFullPathNameW(tmpBuf, MAX_PATH, tmpBuf2, &nameBit);
+            if (result) {
+                *nameBit = 0x00;
+                MemFree(fodInfos->initdir);
+                fodInfos->initdir = MemAlloc((lstrlenW(tmpBuf2) + 1) * sizeof(WCHAR));
+                lstrcpyW(fodInfos->initdir, tmpBuf2);
+                handledPath = TRUE;
+                TRACE("Value in InitDir changed to %s\n", debugstr_w(fodInfos->initdir));
+            }
+        }
+        else if (fodInfos->initdir)
+        {
+            MemFree(fodInfos->initdir);
+            fodInfos->initdir = NULL;
+            TRACE("Value in InitDir is not an existing path, changed to (nil)\n");
+        }
   }
 
   if (!handledPath && (!fodInfos->initdir || !*fodInfos->initdir))
diff --git a/dlls/comdlg32/filedlgbrowser.c b/dlls/comdlg32/filedlgbrowser.c
index 499ebb7..eed34f5 100644
--- a/dlls/comdlg32/filedlgbrowser.c
+++ b/dlls/comdlg32/filedlgbrowser.c
@@ -942,7 +942,7 @@ static HRESULT WINAPI IShellBrowserImpl_ICommDlgBrowser_IncludeObject(ICommDlgBr
         return S_OK;
 
     /* Check if there is a mask to apply if not */
-    if(!fodInfos->ShellInfos.lpstrCurrentFilter || !lstrlenW(fodInfos->ShellInfos.lpstrCurrentFilter))
+    if(!fodInfos->ShellInfos.lpstrCurrentFilter || !fodInfos->ShellInfos.lpstrCurrentFilter[0])
         return S_OK;
 
     if (SUCCEEDED(IShellFolder_GetDisplayNameOf(fodInfos->Shell.FOIShellFolder, pidl, SHGDN_INFOLDER | SHGDN_FORPARSING, &str)))
diff --git a/dlls/comdlg32/printdlg.c b/dlls/comdlg32/printdlg.c
index d52b47d..bedd9c4 100644
--- a/dlls/comdlg32/printdlg.c
+++ b/dlls/comdlg32/printdlg.c
@@ -1798,10 +1798,12 @@ static LRESULT PRINTDLG_WMCommandA(HWND hDlg, WPARAM wParam,
     case cmb2: /* Papersize */
       {
 	  DWORD Sel = SendDlgItemMessageA(hDlg, cmb2, CB_GETCURSEL, 0, 0);
-	  if(Sel != CB_ERR)
+	  if(Sel != CB_ERR) {
 	      lpdm->u1.s1.dmPaperSize = SendDlgItemMessageA(hDlg, cmb2,
 							    CB_GETITEMDATA,
 							    Sel, 0);
+	      GetDlgItemTextA(hDlg, cmb2, (char *)lpdm->dmFormName, CCHFORMNAME);
+	  }
       }
       break;
 
@@ -1954,10 +1956,12 @@ static LRESULT PRINTDLG_WMCommandW(HWND hDlg, WPARAM wParam,
     case cmb2: /* Papersize */
       {
 	  DWORD Sel = SendDlgItemMessageW(hDlg, cmb2, CB_GETCURSEL, 0, 0);
-	  if(Sel != CB_ERR)
+	  if(Sel != CB_ERR) {
 	      lpdm->u1.s1.dmPaperSize = SendDlgItemMessageW(hDlg, cmb2,
 							    CB_GETITEMDATA,
 							    Sel, 0);
+	      GetDlgItemTextW(hDlg, cmb2, lpdm->dmFormName, CCHFORMNAME);
+	  }
       }
       break;
 
diff --git a/dlls/comdlg32/tests/printdlg.c b/dlls/comdlg32/tests/printdlg.c
index 871807b..7e06c97 100644
--- a/dlls/comdlg32/tests/printdlg.c
+++ b/dlls/comdlg32/tests/printdlg.c
@@ -531,6 +531,7 @@ static void test_PrintDlgExW(void)
     if (!winetest_interactive)
     {
         skip("interactive PrintDlgEx tests (set WINETEST_INTERACTIVE=1)\n");
+        HeapFree(GetProcessHeap(), 0, pDlg);
         return;
     }
 
diff --git a/dlls/crypt32/tests/base64.c b/dlls/crypt32/tests/base64.c
index 8f19515..c6073aa 100644
--- a/dlls/crypt32/tests/base64.c
+++ b/dlls/crypt32/tests/base64.c
@@ -57,7 +57,7 @@ struct BinTests
 
 static const BYTE toEncode1[] = { 0 };
 static const BYTE toEncode2[] = { 1,2 };
-static const BYTE toEncode3[] = { 1,2,3 };
+/* static const BYTE toEncode3[] = { 1,2,3 }; */
 static const BYTE toEncode4[] =
  "abcdefghijlkmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"
  "abcdefghijlkmnopqrstuvwxyz01234567890ABCDEFGHIJKLMNOPQRSTUVWXYZ01234567890"
diff --git a/dlls/cryptext/Makefile.in b/dlls/cryptext/Makefile.in
new file mode 100644
index 0000000..e1a46ba
--- /dev/null
+++ b/dlls/cryptext/Makefile.in
@@ -0,0 +1,4 @@
+MODULE = cryptext.dll
+
+C_SRCS = \
+	cryptext_main.c
diff --git a/dlls/cryptext/cryptext.spec b/dlls/cryptext/cryptext.spec
new file mode 100644
index 0000000..0dba38e
--- /dev/null
+++ b/dlls/cryptext/cryptext.spec
@@ -0,0 +1,30 @@
+@ stub CryptExtAddCER
+@ stub CryptExtAddCERW
+@ stub CryptExtAddCRL
+@ stub CryptExtAddCRLW
+@ stub CryptExtAddCTL
+@ stub CryptExtAddCTLW
+@ stub CryptExtAddP7R
+@ stub CryptExtAddP7RW
+@ stdcall CryptExtAddPFX(str)
+@ stdcall CryptExtAddPFXW(wstr)
+@ stub CryptExtAddSPC
+@ stub CryptExtAddSPCW
+@ stub CryptExtOpenCAT
+@ stub CryptExtOpenCATW
+@ stub CryptExtOpenCER
+@ stub CryptExtOpenCERW
+@ stub CryptExtOpenCRL
+@ stub CryptExtOpenCRLW
+@ stub CryptExtOpenCTL
+@ stub CryptExtOpenCTLW
+@ stub CryptExtOpenP7R
+@ stub CryptExtOpenP7RW
+@ stub CryptExtOpenPKCS7
+@ stub CryptExtOpenPKCS7W
+@ stub CryptExtOpenSTR
+@ stub CryptExtOpenSTRW
+@ stub DllCanUnloadNow
+@ stub DllGetClassObject
+@ stub DllRegisterServer
+@ stub DllUnregisterServer
diff --git a/dlls/cryptext/cryptext_main.c b/dlls/cryptext/cryptext_main.c
new file mode 100644
index 0000000..473c326
--- /dev/null
+++ b/dlls/cryptext/cryptext_main.c
@@ -0,0 +1,63 @@
+/*
+ * Crypto Shell Extensions
+ *
+ * Copyright 2014 Austin English
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+
+#include <stdarg.h>
+
+#include "windef.h"
+#include "winbase.h"
+#include "wine/debug.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(cryptext);
+
+BOOL WINAPI DllMain(HINSTANCE instance, DWORD reason, LPVOID reserved)
+{
+    TRACE("(%p, %u, %p)\n", instance, reason, reserved);
+
+    switch (reason)
+    {
+        case DLL_WINE_PREATTACH:
+            return FALSE;    /* prefer native version */
+        case DLL_PROCESS_ATTACH:
+            DisableThreadLibraryCalls(instance);
+            break;
+    }
+
+    return TRUE;
+}
+
+/***********************************************************************
+ * CryptExtAddPFX (CRYPTEXT.@)
+ */
+HRESULT WINAPI CryptExtAddPFX(LPCSTR filename)
+{
+    FIXME("stub: %s\n", debugstr_a(filename));
+    return E_NOTIMPL;
+}
+
+/***********************************************************************
+ * CryptExtAddPFXW (CRYPTEXT.@)
+ */
+HRESULT WINAPI CryptExtAddPFXW(LPCWSTR filename)
+{
+    FIXME("stub: %s\n", debugstr_w(filename));
+    return E_NOTIMPL;
+}
diff --git a/dlls/d2d1/brush.c b/dlls/d2d1/brush.c
index 8837cee..6366086 100644
--- a/dlls/d2d1/brush.c
+++ b/dlls/d2d1/brush.c
@@ -226,9 +226,11 @@ static void STDMETHODCALLTYPE d2d_solid_color_brush_SetTransform(ID2D1SolidColor
 
 static float STDMETHODCALLTYPE d2d_solid_color_brush_GetOpacity(ID2D1SolidColorBrush *iface)
 {
-    FIXME("iface %p stub!\n", iface);
+    struct d2d_brush *brush = impl_from_ID2D1SolidColorBrush(iface);
 
-    return 0.0f;
+    TRACE("iface %p.\n", iface);
+
+    return brush->opacity;
 }
 
 static void STDMETHODCALLTYPE d2d_solid_color_brush_GetTransform(ID2D1SolidColorBrush *iface,
diff --git a/dlls/d3d10core/device.c b/dlls/d3d10core/device.c
index ad6bc4d..44a8085 100644
--- a/dlls/d3d10core/device.c
+++ b/dlls/d3d10core/device.c
@@ -2173,13 +2173,6 @@ static const struct ID3D10MultithreadVtbl d3d10_multithread_vtbl =
     d3d10_multithread_GetMultithreadProtected,
 };
 
-static void STDMETHODCALLTYPE d3d10_subresource_destroyed(void *parent) {}
-
-static const struct wined3d_parent_ops d3d10_subresource_parent_ops =
-{
-    d3d10_subresource_destroyed,
-};
-
 /* IWineDXGIDeviceParent IUnknown methods */
 
 static inline struct d3d10_device *device_from_dxgi_device_parent(IWineDXGIDeviceParent *iface)
diff --git a/dlls/d3d10core/tests/device.c b/dlls/d3d10core/tests/device.c
index 7387231..76830a4 100644
--- a/dlls/d3d10core/tests/device.c
+++ b/dlls/d3d10core/tests/device.c
@@ -22,6 +22,11 @@
 #include "wine/test.h"
 #include <limits.h>
 
+struct vec3
+{
+    float x, y, z;
+};
+
 static ULONG get_refcount(IUnknown *iface)
 {
     IUnknown_AddRef(iface);
@@ -2053,6 +2058,253 @@ float4 main(float4 color : COLOR) : SV_TARGET
     ok(!refcount, "Device has %u references left.\n", refcount);
 }
 
+static void test_blend(void)
+{
+    ID3D10RenderTargetView *backbuffer_rtv, *offscreen_rtv;
+    ID3D10BlendState *src_blend, *dst_blend;
+    ID3D10Texture2D *backbuffer, *offscreen;
+    D3D10_SUBRESOURCE_DATA buffer_data;
+    D3D10_TEXTURE2D_DESC texture_desc;
+    ID3D10InputLayout *input_layout;
+    D3D10_BUFFER_DESC buffer_desc;
+    D3D10_BLEND_DESC blend_desc;
+    unsigned int stride, offset;
+    IDXGISwapChain *swapchain;
+    ID3D10VertexShader *vs;
+    ID3D10PixelShader *ps;
+    ID3D10Device *device;
+    D3D10_VIEWPORT vp;
+    ID3D10Buffer *vb;
+    ULONG refcount;
+    DWORD color;
+    HWND window;
+    HRESULT hr;
+
+    static const DWORD vs_code[] =
+    {
+#if 0
+        struct vs_out
+        {
+            float4 position : SV_POSITION;
+            float4 color : COLOR;
+        };
+
+        struct vs_out main(float4 position : POSITION, float4 color : COLOR)
+        {
+            struct vs_out o;
+
+            o.position = position;
+            o.color = color;
+
+            return o;
+        }
+#endif
+        0x43425844, 0x5c73b061, 0x5c71125f, 0x3f8b345f, 0xce04b9ab, 0x00000001, 0x00000140, 0x00000003,
+        0x0000002c, 0x0000007c, 0x000000d0, 0x4e475349, 0x00000048, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000000, 0x00000003, 0x00000000, 0x00000f0f, 0x00000041, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x49534f50, 0x4e4f4954, 0x4c4f4300, 0xab00524f, 0x4e47534f,
+        0x0000004c, 0x00000002, 0x00000008, 0x00000038, 0x00000000, 0x00000001, 0x00000003, 0x00000000,
+        0x0000000f, 0x00000044, 0x00000000, 0x00000000, 0x00000003, 0x00000001, 0x0000000f, 0x505f5653,
+        0x5449534f, 0x004e4f49, 0x4f4c4f43, 0xabab0052, 0x52444853, 0x00000068, 0x00010040, 0x0000001a,
+        0x0300005f, 0x001010f2, 0x00000000, 0x0300005f, 0x001010f2, 0x00000001, 0x04000067, 0x001020f2,
+        0x00000000, 0x00000001, 0x03000065, 0x001020f2, 0x00000001, 0x05000036, 0x001020f2, 0x00000000,
+        0x00101e46, 0x00000000, 0x05000036, 0x001020f2, 0x00000001, 0x00101e46, 0x00000001, 0x0100003e,
+    };
+    static const DWORD ps_code[] =
+    {
+#if 0
+        struct vs_out
+        {
+            float4 position : SV_POSITION;
+            float4 color : COLOR;
+        };
+
+        float4 main(struct vs_out i) : SV_TARGET
+        {
+            return i.color;
+        }
+#endif
+        0x43425844, 0xe2087fa6, 0xa35fbd95, 0x8e585b3f, 0x67890f54, 0x00000001, 0x000000f4, 0x00000003,
+        0x0000002c, 0x00000080, 0x000000b4, 0x4e475349, 0x0000004c, 0x00000002, 0x00000008, 0x00000038,
+        0x00000000, 0x00000001, 0x00000003, 0x00000000, 0x0000000f, 0x00000044, 0x00000000, 0x00000000,
+        0x00000003, 0x00000001, 0x00000f0f, 0x505f5653, 0x5449534f, 0x004e4f49, 0x4f4c4f43, 0xabab0052,
+        0x4e47534f, 0x0000002c, 0x00000001, 0x00000008, 0x00000020, 0x00000000, 0x00000000, 0x00000003,
+        0x00000000, 0x0000000f, 0x545f5653, 0x45475241, 0xabab0054, 0x52444853, 0x00000038, 0x00000040,
+        0x0000000e, 0x03001062, 0x001010f2, 0x00000001, 0x03000065, 0x001020f2, 0x00000000, 0x05000036,
+        0x001020f2, 0x00000000, 0x00101e46, 0x00000001, 0x0100003e,
+    };
+    static const struct
+    {
+        struct vec3 position;
+        DWORD diffuse;
+    }
+    quads[] =
+    {
+        /* quad1 */
+        {{-1.0f, -1.0f, 0.1f}, 0x4000ff00},
+        {{-1.0f,  0.0f, 0.1f}, 0x4000ff00},
+        {{ 1.0f, -1.0f, 0.1f}, 0x4000ff00},
+        {{ 1.0f,  0.0f, 0.1f}, 0x4000ff00},
+        /* quad2 */
+        {{-1.0f,  0.0f, 0.1f}, 0xc0ff0000},
+        {{-1.0f,  1.0f, 0.1f}, 0xc0ff0000},
+        {{ 1.0f,  0.0f, 0.1f}, 0xc0ff0000},
+        {{ 1.0f,  1.0f, 0.1f}, 0xc0ff0000},
+    };
+    static const D3D10_INPUT_ELEMENT_DESC layout_desc[] =
+    {
+        {"POSITION", 0, DXGI_FORMAT_R32G32B32_FLOAT, 0,  0, D3D10_INPUT_PER_VERTEX_DATA, 0},
+        {"COLOR",    0, DXGI_FORMAT_R8G8B8A8_UNORM,  0, 12, D3D10_INPUT_PER_VERTEX_DATA, 0},
+    };
+    static const float blend_factor[] = {1.0f, 1.0f, 1.0f, 1.0f};
+    static const float red[] = {1.0f, 0.0f, 0.0f, 0.5f};
+
+    if (!(device = create_device()))
+    {
+        skip("Failed to create device, skipping tests.\n");
+        return;
+    }
+    window = CreateWindowA("static", "d3d10core_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    swapchain = create_swapchain(device, window, TRUE);
+    hr = IDXGISwapChain_GetBuffer(swapchain, 0, &IID_ID3D10Texture2D, (void **)&backbuffer);
+    ok(SUCCEEDED(hr), "Failed to get buffer, hr %#x.\n", hr);
+
+    hr = ID3D10Device_CreateInputLayout(device, layout_desc, sizeof(layout_desc) / sizeof(*layout_desc),
+            vs_code, sizeof(vs_code), &input_layout);
+    ok(SUCCEEDED(hr), "Failed to create input layout, hr %#x.\n", hr);
+
+    buffer_desc.ByteWidth = sizeof(quads);
+    buffer_desc.Usage = D3D10_USAGE_DEFAULT;
+    buffer_desc.BindFlags = D3D10_BIND_VERTEX_BUFFER;
+    buffer_desc.CPUAccessFlags = 0;
+    buffer_desc.MiscFlags = 0;
+
+    buffer_data.pSysMem = quads;
+    buffer_data.SysMemPitch = 0;
+    buffer_data.SysMemSlicePitch = 0;
+
+    hr = ID3D10Device_CreateBuffer(device, &buffer_desc, &buffer_data, &vb);
+    ok(SUCCEEDED(hr), "Failed to create vertex buffer, hr %#x.\n", hr);
+    hr = ID3D10Device_CreateVertexShader(device, vs_code, sizeof(vs_code), &vs);
+    ok(SUCCEEDED(hr), "Failed to create vertex shader, hr %#x.\n", hr);
+    hr = ID3D10Device_CreatePixelShader(device, ps_code, sizeof(ps_code), &ps);
+    ok(SUCCEEDED(hr), "Failed to create pixel shader, hr %#x.\n", hr);
+
+    hr = ID3D10Device_CreateRenderTargetView(device, (ID3D10Resource *)backbuffer, NULL, &backbuffer_rtv);
+    ok(SUCCEEDED(hr), "Failed to create rendertarget view, hr %#x.\n", hr);
+
+    memset(&blend_desc, 0, sizeof(blend_desc));
+    blend_desc.BlendEnable[0] = TRUE;
+    blend_desc.SrcBlend = D3D10_BLEND_SRC_ALPHA;
+    blend_desc.DestBlend = D3D10_BLEND_INV_SRC_ALPHA;
+    blend_desc.BlendOp = D3D10_BLEND_OP_ADD;
+    blend_desc.SrcBlendAlpha = D3D10_BLEND_SRC_ALPHA;
+    blend_desc.DestBlendAlpha = D3D10_BLEND_INV_SRC_ALPHA;
+    blend_desc.BlendOpAlpha = D3D10_BLEND_OP_ADD;
+    blend_desc.RenderTargetWriteMask[0] = D3D10_COLOR_WRITE_ENABLE_ALL;
+
+    hr = ID3D10Device_CreateBlendState(device, &blend_desc, &src_blend);
+    ok(SUCCEEDED(hr), "Failed to create blend state, hr %#x.\n", hr);
+
+    blend_desc.SrcBlend = D3D10_BLEND_DEST_ALPHA;
+    blend_desc.DestBlend = D3D10_BLEND_INV_DEST_ALPHA;
+    blend_desc.SrcBlendAlpha = D3D10_BLEND_DEST_ALPHA;
+    blend_desc.DestBlendAlpha = D3D10_BLEND_INV_DEST_ALPHA;
+
+    hr = ID3D10Device_CreateBlendState(device, &blend_desc, &dst_blend);
+    ok(SUCCEEDED(hr), "Failed to create blend state, hr %#x.\n", hr);
+
+    ID3D10Device_OMSetRenderTargets(device, 1, &backbuffer_rtv, NULL);
+    ID3D10Device_IASetInputLayout(device, input_layout);
+    ID3D10Device_IASetPrimitiveTopology(device, D3D10_PRIMITIVE_TOPOLOGY_TRIANGLESTRIP);
+    stride = sizeof(*quads);
+    offset = 0;
+    ID3D10Device_IASetVertexBuffers(device, 0, 1, &vb, &stride, &offset);
+    ID3D10Device_VSSetShader(device, vs);
+    ID3D10Device_PSSetShader(device, ps);
+
+    vp.TopLeftX = 0;
+    vp.TopLeftY = 0;
+    vp.Width = 640;
+    vp.Height = 480;
+    vp.MinDepth = 0.0f;
+    vp.MaxDepth = 1.0f;
+    ID3D10Device_RSSetViewports(device, 1, &vp);
+
+    ID3D10Device_ClearRenderTargetView(device, backbuffer_rtv, red);
+
+    ID3D10Device_OMSetBlendState(device, src_blend, blend_factor, D3D10_DEFAULT_SAMPLE_MASK);
+    ID3D10Device_Draw(device, 4, 0);
+    ID3D10Device_OMSetBlendState(device, dst_blend, blend_factor, D3D10_DEFAULT_SAMPLE_MASK);
+    ID3D10Device_Draw(device, 4, 4);
+
+    color = get_texture_color(backbuffer, 320, 360);
+    ok(compare_color(color, 0x700040bf, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(backbuffer, 320, 120);
+    ok(compare_color(color, 0xa080007f, 1), "Got unexpected color 0x%08x.\n", color);
+
+    texture_desc.Width = 128;
+    texture_desc.Height = 128;
+    texture_desc.MipLevels = 1;
+    texture_desc.ArraySize = 1;
+    texture_desc.Format = DXGI_FORMAT_B8G8R8X8_UNORM;
+    texture_desc.SampleDesc.Count = 1;
+    texture_desc.SampleDesc.Quality = 0;
+    texture_desc.Usage = D3D10_USAGE_DEFAULT;
+    texture_desc.BindFlags = D3D10_BIND_SHADER_RESOURCE | D3D10_BIND_RENDER_TARGET;
+    texture_desc.CPUAccessFlags = 0;
+    texture_desc.MiscFlags = 0;
+
+    /* DXGI_FORMAT_B8G8R8X8_UNORM is not supported on all implementations. */
+    if (FAILED(ID3D10Device_CreateTexture2D(device, &texture_desc, NULL, &offscreen)))
+    {
+        skip("DXGI_FORMAT_B8G8R8X8_UNORM not supported, skipping tests.\n");
+        goto done;
+    }
+
+    hr = ID3D10Device_CreateRenderTargetView(device, (ID3D10Resource *)offscreen, NULL, &offscreen_rtv);
+    ok(SUCCEEDED(hr), "Failed to create rendertarget view, hr %#x.\n", hr);
+
+    ID3D10Device_OMSetRenderTargets(device, 1, &offscreen_rtv, NULL);
+
+    vp.TopLeftX = 0;
+    vp.TopLeftY = 0;
+    vp.Width = 128;
+    vp.Height = 128;
+    vp.MinDepth = 0.0f;
+    vp.MaxDepth = 1.0f;
+    ID3D10Device_RSSetViewports(device, 1, &vp);
+
+    ID3D10Device_ClearRenderTargetView(device, offscreen_rtv, red);
+
+    ID3D10Device_OMSetBlendState(device, src_blend, blend_factor, D3D10_DEFAULT_SAMPLE_MASK);
+    ID3D10Device_Draw(device, 4, 0);
+    ID3D10Device_OMSetBlendState(device, dst_blend, blend_factor, D3D10_DEFAULT_SAMPLE_MASK);
+    ID3D10Device_Draw(device, 4, 4);
+
+    color = get_texture_color(offscreen, 64, 96) & 0x00ffffff;
+    ok(compare_color(color, 0x00bf4000, 1), "Got unexpected color 0x%08x.\n", color);
+    color = get_texture_color(offscreen, 64, 32) & 0x00ffffff;
+    ok(compare_color(color, 0x000000ff, 1), "Got unexpected color 0x%08x.\n", color);
+
+    ID3D10RenderTargetView_Release(offscreen_rtv);
+    ID3D10Texture2D_Release(offscreen);
+done:
+    ID3D10BlendState_Release(dst_blend);
+    ID3D10BlendState_Release(src_blend);
+    ID3D10PixelShader_Release(ps);
+    ID3D10VertexShader_Release(vs);
+    ID3D10Buffer_Release(vb);
+    ID3D10InputLayout_Release(input_layout);
+    ID3D10RenderTargetView_Release(backbuffer_rtv);
+    ID3D10Texture2D_Release(backbuffer);
+    IDXGISwapChain_Release(swapchain);
+    refcount = ID3D10Device_Release(device);
+    ok(!refcount, "Device has %u references left.\n", refcount);
+    DestroyWindow(window);
+}
+
 START_TEST(device)
 {
     test_create_texture2d();
@@ -2069,4 +2321,5 @@ START_TEST(device)
     test_device_removed_reason();
     test_scissor();
     test_clear_state();
+    test_blend();
 }
diff --git a/dlls/d3d8/device.c b/dlls/d3d8/device.c
index dd0b9ee..4c17e7c 100644
--- a/dlls/d3d8/device.c
+++ b/dlls/d3d8/device.c
@@ -557,11 +557,36 @@ static HRESULT WINAPI d3d8_device_CreateAdditionalSwapChain(IDirect3DDevice8 *if
     struct d3d8_device *device = impl_from_IDirect3DDevice8(iface);
     struct wined3d_swapchain_desc desc;
     struct d3d8_swapchain *object;
+    UINT i, count;
     HRESULT hr;
 
     TRACE("iface %p, present_parameters %p, swapchain %p.\n",
             iface, present_parameters, swapchain);
 
+    if (!present_parameters->Windowed)
+    {
+        WARN("Trying to create an additional fullscreen swapchain, returning D3DERR_INVALIDCALL.\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    wined3d_mutex_lock();
+    count = wined3d_device_get_swapchain_count(device->wined3d_device);
+    for (i = 0; i < count; ++i)
+    {
+        struct wined3d_swapchain *wined3d_swapchain;
+
+        wined3d_swapchain = wined3d_device_get_swapchain(device->wined3d_device, i);
+        wined3d_swapchain_get_desc(wined3d_swapchain, &desc);
+
+        if (!desc.windowed)
+        {
+            wined3d_mutex_unlock();
+            WARN("Trying to create an additional swapchain in fullscreen mode, returning D3DERR_INVALIDCALL.\n");
+            return D3DERR_INVALIDCALL;
+        }
+    }
+    wined3d_mutex_unlock();
+
     wined3d_swapchain_desc_from_present_parameters(&desc, present_parameters);
     if (SUCCEEDED(hr = d3d8_swapchain_create(device, &desc, &object)))
         *swapchain = &object->IDirect3DSwapChain8_iface;
diff --git a/dlls/d3d8/tests/device.c b/dlls/d3d8/tests/device.c
index bf7f181..99fe70a 100644
--- a/dlls/d3d8/tests/device.c
+++ b/dlls/d3d8/tests/device.c
@@ -262,12 +262,16 @@ static void test_swapchain(void)
     IDirect3DDevice8 *device;
     IDirect3D8 *d3d;
     ULONG refcount;
-    HWND window;
+    HWND window, window2;
     HRESULT hr;
+    struct device_desc device_desc;
 
     window = CreateWindowA("d3d8_test_wc", "d3d8_test", WS_OVERLAPPEDWINDOW,
             0, 0, 640, 480, NULL, NULL, NULL, NULL);
     ok(!!window, "Failed to create a window.\n");
+    window2 = CreateWindowA("d3d8_test_wc", "d3d8_test", WS_OVERLAPPEDWINDOW,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    ok(!!window2, "Failed to create a window.\n");
     d3d = Direct3DCreate8(D3D_SDK_VERSION);
     ok(!!d3d, "Failed to create a D3D object.\n");
     if (!(device = create_device(d3d, window, NULL)))
@@ -356,10 +360,42 @@ static void test_swapchain(void)
     IDirect3DSwapChain8_Release(swapchain3);
     IDirect3DSwapChain8_Release(swapchain2);
     IDirect3DSwapChain8_Release(swapchain1);
+
+    d3dpp.Windowed = FALSE;
+    d3dpp.hDeviceWindow = window;
+    d3dpp.BackBufferCount = 1;
+    hr = IDirect3DDevice8_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.hDeviceWindow = window2;
+    hr = IDirect3DDevice8_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+
+    device_desc.width = registry_mode.dmPelsWidth;
+    device_desc.height = registry_mode.dmPelsHeight;
+    device_desc.device_window = window;
+    device_desc.flags = CREATE_DEVICE_FULLSCREEN;
+    hr = reset_device(device, &device_desc);
+    ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+
+    d3dpp.hDeviceWindow = window;
+    hr = IDirect3DDevice8_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.hDeviceWindow = window2;
+    hr = IDirect3DDevice8_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.Windowed = TRUE;
+    d3dpp.hDeviceWindow = window;
+    hr = IDirect3DDevice8_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.hDeviceWindow = window2;
+    hr = IDirect3DDevice8_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+
     refcount = IDirect3DDevice8_Release(device);
     ok(!refcount, "Device has %u references left.\n", refcount);
 cleanup:
     IDirect3D8_Release(d3d);
+    DestroyWindow(window2);
     DestroyWindow(window);
 }
 
@@ -723,6 +759,7 @@ static void test_cursor(void)
     HCURSOR cur;
     HWND window;
     HRESULT hr;
+    BOOL ret;
 
     pGetCursorInfo = (void *)GetProcAddress(user32_handle, "GetCursorInfo");
     if (!pGetCursorInfo)
@@ -731,14 +768,19 @@ static void test_cursor(void)
         return;
     }
 
+    window = CreateWindowA("d3d8_test_wc", "d3d8_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    ok(!!window, "Failed to create a window.\n");
+
+    ret = SetCursorPos(50, 50);
+    ok(ret, "Failed to set cursor position.\n");
+    flush_events();
+
     memset(&info, 0, sizeof(info));
     info.cbSize = sizeof(info);
     ok(pGetCursorInfo(&info), "GetCursorInfo failed\n");
     cur = info.hCursor;
 
-    window = CreateWindowA("d3d8_test_wc", "d3d8_test", WS_OVERLAPPEDWINDOW,
-            0, 0, 640, 480, NULL, NULL, NULL, NULL);
-    ok(!!window, "Failed to create a window.\n");
     d3d = Direct3DCreate8(D3D_SDK_VERSION);
     ok(!!d3d, "Failed to create a D3D object.\n");
     if (!(device = create_device(d3d, window, NULL)))
@@ -781,12 +823,11 @@ static void test_cursor(void)
     hr = IDirect3DDevice8_ShowCursor(device, TRUE);
     ok(hr == TRUE, "IDirect3DDevice8_ShowCursor returned %#08x\n", hr);
 
-    /* GDI cursor unchanged */
     memset(&info, 0, sizeof(info));
     info.cbSize = sizeof(info);
     ok(pGetCursorInfo(&info), "GetCursorInfo failed\n");
     ok(info.flags & CURSOR_SHOWING, "The gdi cursor is hidden (%08x)\n", info.flags);
-    ok(info.hCursor == cur, "The cursor handle is %p\n", info.hCursor); /* unchanged */
+    ok(info.hCursor != cur, "The cursor handle is %p\n", info.hCursor);
 
     refcount = IDirect3DDevice8_Release(device);
     ok(!refcount, "Device has %u references left.\n", refcount);
@@ -2136,9 +2177,11 @@ struct message
 {
     UINT message;
     enum message_window window;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
 };
 
-static const struct message *expect_messages;
+static const struct message *expect_messages, *unexpected_messages;
 static HWND device_window, focus_window;
 
 struct wndproc_thread_param
@@ -2176,7 +2219,22 @@ static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM
                 break;
         };
 
-        if (hwnd == w && expect_messages->message == message) ++expect_messages;
+        if (hwnd == w && expect_messages->message == message)
+        {
+            if (expect_messages->check_wparam)
+                ok(wparam == expect_messages->expect_wparam,
+                        "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                        wparam, message, expect_messages->expect_wparam);
+
+            ++expect_messages;
+        }
+    }
+
+    if (unexpected_messages)
+    {
+        const struct message *i;
+        for (i = unexpected_messages; i->message; i++)
+            ok(i->message != message, "Got unexpected message %x on window %p.\n", message, hwnd);
     }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
@@ -2227,21 +2285,129 @@ static void test_wndproc(void)
     ULONG ref;
     DWORD res, tid;
     HWND tmp;
+    UINT i, adapter_mode_count;
+    HRESULT hr;
+    D3DDISPLAYMODE d3ddm;
+    DWORD d3d_width = 0, d3d_height = 0, user32_width = 0, user32_height = 0;
+    DEVMODEW devmode;
+    LONG change_ret;
+    BOOL ret;
 
-    static const struct message messages[] =
+    static const struct message create_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FOCUS_WINDOW,   FALSE,  0},
+        /* Do not test wparam here. If device creation succeeds,
+         * wparam is WA_ACTIVE. If device creation fails (testbot)
+         * wparam is set to WA_INACTIVE on some Windows versions. */
+        {WM_ACTIVATE,           FOCUS_WINDOW,   FALSE,  0},
+        {WM_SETFOCUS,           FOCUS_WINDOW,   FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW,  FALSE,  0},
+        {WM_MOVE,               DEVICE_WINDOW,  FALSE,  0},
+        {WM_SIZE,               DEVICE_WINDOW,  FALSE,  0},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages[] =
+    {
+        /* WM_ACTIVATE (wparam = WA_INACTIVE) is sent on Windows. It is
+         * not reliable on X11 WMs. When the window focus follows the
+         * mouse pointer the message is not sent.
+         * {WM_ACTIVATE,           FOCUS_WINDOW,   TRUE,   WA_INACTIVE}, */
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        /* WM_DISPLAYCHANGE is sent to the focus window too, but the order is
+         * not deterministic. */
+        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW,  FALSE,  0},
+        /* Windows sends WM_ACTIVATE to the device window, indicating that
+         * SW_SHOWMINIMIZED is used instead of SW_MINIMIZE. Yet afterwards
+         * the foreground and focus window are NULL. On Wine SW_SHOWMINIMIZED
+         * leaves the device window active, breaking re-activation in the
+         * lost device test.
+         * {WM_ACTIVATE,           DEVICE_WINDOW,  TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   DEVICE_WINDOW,  FALSE,  0},
+        {WM_SIZE,               DEVICE_WINDOW,  TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        /* WM_ACTIVATEAPP is sent to the device window too, but the order is
+         * not deterministic. It may be sent after the focus window handling
+         * or before. */
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message reactivate_messages[] =
     {
-        {WM_WINDOWPOSCHANGING,  FOCUS_WINDOW},
-        {WM_ACTIVATE,           FOCUS_WINDOW},
-        {WM_SETFOCUS,           FOCUS_WINDOW},
-        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW},
-        {WM_MOVE,               DEVICE_WINDOW},
-        {WM_SIZE,               DEVICE_WINDOW},
-        {0,                     0},
+        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW,  FALSE,  0},
+        {WM_WINDOWPOSCHANGED,   DEVICE_WINDOW,  FALSE,  0},
+        {WM_MOVE,               DEVICE_WINDOW,  FALSE,  0},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   TRUE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_hidden[] =
+    {
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_hidden_unexpected[] =
+    {
+        /* KDE randomly does something with the hidden window during the
+         * mode change that sometimes generates a WM_WINDOWPOSCHANGING
+         * message. A WM_WINDOWPOSCHANGED message is not generated, so
+         * just flag WM_WINDOWPOSCHANGED as bad. */
+        {WM_WINDOWPOSCHANGED,   0,              FALSE,  0},
+        {0,                     0,              FALSE,  0},
     };
 
     d3d8 = Direct3DCreate8(D3D_SDK_VERSION);
     ok(!!d3d8, "Failed to create a D3D object.\n");
 
+    adapter_mode_count = IDirect3D8_GetAdapterModeCount(d3d8, D3DADAPTER_DEFAULT);
+    for (i = 0; i < adapter_mode_count; ++i)
+    {
+        hr = IDirect3D8_EnumAdapterModes(d3d8, D3DADAPTER_DEFAULT, i, &d3ddm);
+        ok(SUCCEEDED(hr), "Failed to enumerate display mode, hr %#x.\n", hr);
+
+        if (d3ddm.Format != D3DFMT_X8R8G8B8)
+            continue;
+        if (d3ddm.Width == registry_mode.dmPelsWidth && d3ddm.Height == registry_mode.dmPelsHeight)
+            continue;
+        /* The r200 driver on Windows XP enumerates modes like 320x200 and 320x240 but
+         * refuses to create a device at these sizes. */
+        if (d3ddm.Width < 640 || d3ddm.Height < 480)
+            continue;
+
+        if (!user32_width)
+        {
+            user32_width = d3ddm.Width;
+            user32_height = d3ddm.Height;
+            continue;
+        }
+
+        /* Make sure the d3d mode is smaller in width or height and at most
+         * equal in the other dimension than the mode passed to
+         * ChangeDisplaySettings. Otherwise Windows shrinks the window to
+         * the ChangeDisplaySettings parameters + 12. */
+        if (d3ddm.Width == user32_width && d3ddm.Height == user32_height)
+            continue;
+        if (d3ddm.Width <= user32_width && d3ddm.Height <= user32_height)
+        {
+            d3d_width = d3ddm.Width;
+            d3d_height = d3ddm.Height;
+            break;
+        }
+        if (user32_width <= d3ddm.Width && user32_height <= d3ddm.Height)
+        {
+            d3d_width = user32_width;
+            d3d_height = user32_height;
+            user32_width = d3ddm.Width;
+            user32_height = d3ddm.Height;
+            break;
+        }
+    }
+
+    if (!d3d_width)
+    {
+        skip("Could not find adequate modes, skipping mode tests.\n");
+        IDirect3D8_Release(d3d8);
+        return;
+    }
+
     wc.lpfnWndProc = test_proc;
     wc.lpszClassName = "d3d8_test_wndproc_wc";
     ok(RegisterClassA(&wc), "Failed to register window class.\n");
@@ -2251,12 +2417,18 @@ static void test_wndproc(void)
     thread_params.test_finished = CreateEventA(NULL, FALSE, FALSE, NULL);
     ok(!!thread_params.test_finished, "CreateEvent failed, last error %#x.\n", GetLastError());
 
+    memset(&devmode, 0, sizeof(devmode));
+    devmode.dmSize = sizeof(devmode);
+    devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+    devmode.dmPelsWidth = user32_width;
+    devmode.dmPelsHeight = user32_height;
+    change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
+    ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
+
     focus_window = CreateWindowA("d3d8_test_wndproc_wc", "d3d8_test",
-            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION , 0, 0, registry_mode.dmPelsWidth,
-            registry_mode.dmPelsHeight, 0, 0, 0, 0);
+            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION , 0, 0, user32_width, user32_height, 0, 0, 0, 0);
     device_window = CreateWindowA("d3d8_test_wndproc_wc", "d3d8_test",
-            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION , 0, 0, registry_mode.dmPelsWidth,
-            registry_mode.dmPelsHeight, 0, 0, 0, 0);
+            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION , 0, 0, user32_width, user32_height, 0, 0, 0, 0);
     thread = CreateThread(NULL, 0, wndproc_thread, &thread_params, 0, &tid);
     ok(!!thread, "Failed to create thread, last error %#x.\n", GetLastError());
 
@@ -2286,11 +2458,11 @@ static void test_wndproc(void)
 
     flush_events();
 
-    expect_messages = messages;
+    expect_messages = create_messages;
 
     device_desc.device_window = device_window;
-    device_desc.width = registry_mode.dmPelsWidth;
-    device_desc.height = registry_mode.dmPelsHeight;
+    device_desc.width = d3d_width;
+    device_desc.height = d3d_height;
     device_desc.flags = CREATE_DEVICE_FULLSCREEN;
     if (!(device = create_device(d3d8, focus_window, &device_desc)))
     {
@@ -2312,8 +2484,6 @@ static void test_wndproc(void)
     SetForegroundWindow(focus_window);
     flush_events();
 
-    filter_messages = focus_window;
-
     proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
     ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
             (LONG_PTR)test_proc, proc);
@@ -2321,9 +2491,112 @@ static void test_wndproc(void)
     proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
     ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n", (LONG_PTR)test_proc);
 
+    /* Change the mode while the device is in use and then drop focus. */
+    devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+    devmode.dmPelsWidth = user32_width;
+    devmode.dmPelsHeight = user32_height;
+    change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
+    ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x, i=%u.\n", change_ret, i);
+
+    /* Wine doesn't (yet) mark the device not reset when the mode is changed, thus the todo_wine.
+     * But sometimes focus-follows-mouse WMs also temporarily drop window focus, which makes
+     * mark the device lost, then not reset, causing the test to succeed for the wrong reason. */
+    hr = IDirect3DDevice8_TestCooperativeLevel(device);
+    if (hr == D3DERR_DEVICENOTRESET)
+        ok(hr == D3DERR_DEVICENOTRESET, "Got unexpected hr %#x.\n", hr);
+    else
+        todo_wine ok(hr == D3DERR_DEVICENOTRESET, "Got unexpected hr %#x.\n", hr);
+
+    expect_messages = focus_loss_messages;
+    /* SetForegroundWindow is a poor replacement for the user pressing alt-tab or
+     * manually changing the focus. It generates the same messages, but the task
+     * bar still shows the previous foreground window as active, and the window has
+     * an inactive titlebar if reactivated with SetForegroundWindow. Reactivating
+     * the device is difficult, see below. */
+    SetForegroundWindow(GetDesktopWindow());
+    ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it.\n",
+            expect_messages->message, expect_messages->window);
+    expect_messages = NULL;
+    tmp = GetFocus();
+    ok(tmp != device_window, "The device window is active.\n");
+    ok(tmp != focus_window, "The focus window is active.\n");
+
+    /* The Present call is necessary to make native realize the device is lost. */
+    hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
+    ok(hr == D3DERR_DEVICELOST, "Got unexpected hr %#x.\n", hr);
+    hr = IDirect3DDevice8_TestCooperativeLevel(device);
+    /* Focus-follows-mouse WMs prematurely reactivate our window. */
+    if (hr == D3DERR_DEVICENOTRESET)
+        todo_wine ok(hr == D3DERR_DEVICELOST, "Got unexpected hr %#x.\n", hr);
+    else
+        ok(hr == D3DERR_DEVICELOST, "Got unexpected hr %#x.\n", hr);
+
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+            && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    /* I have to minimize and restore the focus window, otherwise native d3d9 fails
+     * device::reset with D3DERR_DEVICELOST. This does not happen when the window
+     * restore is triggered by the user. */
+    expect_messages = reactivate_messages;
+    ShowWindow(focus_window, SW_MINIMIZE);
+    ShowWindow(focus_window, SW_RESTORE);
+    /* Set focus twice to make KDE and fvwm in focus-follows-mouse mode happy. */
+    SetForegroundWindow(focus_window);
+    flush_events();
+    SetForegroundWindow(focus_window);
+    flush_events(); /* WM_WINDOWPOSCHANGING etc arrive after SetForegroundWindow returns. */
+    ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+            expect_messages->message, expect_messages->window, i);
+    expect_messages = NULL;
+
+    hr = IDirect3DDevice8_TestCooperativeLevel(device);
+    ok(hr == D3DERR_DEVICENOTRESET, "Got unexpected hr %#x.\n", hr);
+
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+            && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    hr = reset_device(device, &device_desc);
+    ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+
+    ShowWindow(device_window, SW_HIDE);
+    flush_events();
+
+    expect_messages = focus_loss_messages_hidden;
+    unexpected_messages = focus_loss_messages_hidden_unexpected;
+    SetForegroundWindow(GetDesktopWindow());
+    ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it.\n",
+            expect_messages->message, expect_messages->window);
+    expect_messages = NULL;
+    unexpected_messages = NULL;
+
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth, "Got unexpect width %u.\n", devmode.dmPelsWidth);
+    ok(devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect height %u.\n", devmode.dmPelsHeight);
+
+    ShowWindow(focus_window, SW_MINIMIZE);
+    ShowWindow(focus_window, SW_RESTORE);
+    SetForegroundWindow(focus_window);
+    flush_events();
+
+    /* Releasing a device in lost state breaks follow-up tests on native. */
+    hr = reset_device(device, &device_desc);
+    ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+
+    filter_messages = focus_window;
     ref = IDirect3DDevice8_Release(device);
     ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
 
+    /* Fix up the mode until Wine's device release behavior is fixed. */
+    change_ret = ChangeDisplaySettingsW(NULL, CDS_FULLSCREEN);
+    ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
+
     proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
     ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
             (LONG_PTR)test_proc, proc);
@@ -2791,6 +3064,7 @@ static void test_window_style(void)
     IDirect3D8 *d3d8;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
 
     focus_window = CreateWindowA("d3d8_test_wc", "d3d8_test", WS_OVERLAPPEDWINDOW,
             0, 0, registry_mode.dmPelsWidth / 2, registry_mode.dmPelsHeight / 2, 0, 0, 0, 0);
@@ -2864,6 +3138,36 @@ static void test_window_style(void)
     ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x.\n",
             focus_exstyle, style);
 
+    device_desc.flags = CREATE_DEVICE_FULLSCREEN;
+    hr = reset_device(device, &device_desc);
+    ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+
+    style = GetWindowLongA(device_window, GWL_STYLE);
+    expected_style = device_style | WS_MINIMIZE | WS_VISIBLE;
+    todo_wine ok(style == expected_style, "Expected device window style %#x, got %#x.\n",
+            expected_style, style);
+    style = GetWindowLongA(device_window, GWL_EXSTYLE);
+    expected_style = device_exstyle | WS_EX_TOPMOST;
+    todo_wine ok(style == expected_style, "Expected device window extended style %#x, got %#x.\n",
+            expected_style, style);
+
+    style = GetWindowLongA(focus_window, GWL_STYLE);
+    ok(style == focus_style, "Expected focus window style %#x, got %#x.\n",
+            focus_style, style);
+    style = GetWindowLongA(focus_window, GWL_EXSTYLE);
+    ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x.\n",
+            focus_exstyle, style);
+
+    /* Follow-up tests fail on native if the device is destroyed while lost. */
+    ShowWindow(focus_window, SW_MINIMIZE);
+    ShowWindow(focus_window, SW_RESTORE);
+    ret = SetForegroundWindow(focus_window);
+    ok(ret, "Failed to set foreground window.\n");
+    flush_events();
+    hr = reset_device(device, &device_desc);
+    ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
 
     ref = IDirect3DDevice8_Release(device);
     ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
diff --git a/dlls/d3d8/tests/visual.c b/dlls/d3d8/tests/visual.c
index b21c9f0..af182d0 100644
--- a/dlls/d3d8/tests/visual.c
+++ b/dlls/d3d8/tests/visual.c
@@ -2104,7 +2104,7 @@ done:
     DestroyWindow(window);
 }
 
-static void alpha_test(void)
+static void test_blend(void)
 {
     IDirect3DSurface8 *backbuffer, *offscreen, *depthstencil;
     IDirect3DTexture8 *offscreenTexture;
@@ -4998,7 +4998,7 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
-    ok(color_match(color, 0x00ff0000, 1),
+    todo_wine ok(color_match(color, 0x00ff0000, 1),
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice8_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
@@ -5393,7 +5393,7 @@ START_TEST(visual)
     fog_test();
     z_range_test();
     offscreen_test();
-    alpha_test();
+    test_blend();
     test_scalar_instructions();
     fog_with_shader_test();
     cnd_test();
diff --git a/dlls/d3d9/device.c b/dlls/d3d9/device.c
index ca902a2..67a5629 100644
--- a/dlls/d3d9/device.c
+++ b/dlls/d3d9/device.c
@@ -503,11 +503,36 @@ static HRESULT WINAPI DECLSPEC_HOTPATCH d3d9_device_CreateAdditionalSwapChain(ID
     struct d3d9_device *device = impl_from_IDirect3DDevice9Ex(iface);
     struct wined3d_swapchain_desc desc;
     struct d3d9_swapchain *object;
+    UINT i, count;
     HRESULT hr;
 
     TRACE("iface %p, present_parameters %p, swapchain %p.\n",
             iface, present_parameters, swapchain);
 
+    if (!present_parameters->Windowed)
+    {
+        WARN("Trying to create an additional fullscreen swapchain, returning D3DERR_INVALIDCALL.\n");
+        return D3DERR_INVALIDCALL;
+    }
+
+    wined3d_mutex_lock();
+    count = wined3d_device_get_swapchain_count(device->wined3d_device);
+    for (i = 0; i < count; ++i)
+    {
+        struct wined3d_swapchain *wined3d_swapchain;
+
+        wined3d_swapchain = wined3d_device_get_swapchain(device->wined3d_device, i);
+        wined3d_swapchain_get_desc(wined3d_swapchain, &desc);
+
+        if (!desc.windowed)
+        {
+            wined3d_mutex_unlock();
+            WARN("Trying to create an additional swapchain in fullscreen mode, returning D3DERR_INVALIDCALL.\n");
+            return D3DERR_INVALIDCALL;
+        }
+    }
+    wined3d_mutex_unlock();
+
     wined3d_swapchain_desc_from_present_parameters(&desc, present_parameters);
     if (SUCCEEDED(hr = d3d9_swapchain_create(device, &desc, &object)))
         *swapchain = (IDirect3DSwapChain9 *)&object->IDirect3DSwapChain9Ex_iface;
diff --git a/dlls/d3d9/directx.c b/dlls/d3d9/directx.c
index 6280d12..dc36be1 100644
--- a/dlls/d3d9/directx.c
+++ b/dlls/d3d9/directx.c
@@ -640,6 +640,9 @@ BOOL d3d9_init(struct d3d9 *d3d9, BOOL extended)
 
     if (!extended)
         flags |= WINED3D_VIDMEM_ACCOUNTING;
+    else
+        flags |= WINED3D_RESTORE_MODE_ON_ACTIVATE;
+
     d3d9->IDirect3D9Ex_iface.lpVtbl = &d3d9_vtbl;
     d3d9->refcount = 1;
 
diff --git a/dlls/d3d9/tests/d3d9ex.c b/dlls/d3d9/tests/d3d9ex.c
index bbb95b0..226e338 100644
--- a/dlls/d3d9/tests/d3d9ex.c
+++ b/dlls/d3d9/tests/d3d9ex.c
@@ -1702,9 +1702,11 @@ struct message
 {
     UINT message;
     enum message_window window;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
 };
 
-static const struct message *expect_messages;
+static const struct message *expect_messages, *unexpected_messages;
 static HWND device_window, focus_window;
 
 struct wndproc_thread_param
@@ -1743,7 +1745,21 @@ static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM
         };
 
         if (hwnd == w && expect_messages->message == message)
+        {
+            if (expect_messages->check_wparam)
+                ok(wparam == expect_messages->expect_wparam,
+                        "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                        wparam, message, expect_messages->expect_wparam);
+
             ++expect_messages;
+        }
+    }
+
+    if (unexpected_messages)
+    {
+        const struct message *i;
+        for (i = unexpected_messages; i->message; i++)
+            ok(i->message != message, "Got unexpected message %x on window %p.\n", message, hwnd);
     }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
@@ -1795,14 +1811,140 @@ static void test_wndproc(void)
     ULONG ref;
     DWORD res, tid;
     HWND tmp;
+    UINT i, adapter_mode_count;
+    HRESULT hr;
+    D3DDISPLAYMODE d3ddm;
+    DWORD d3d_width = 0, d3d_height = 0, user32_width = 0, user32_height = 0;
+    DEVMODEW devmode;
+    LONG change_ret;
+    BOOL ret;
+    IDirect3D9Ex *d3d9ex;
 
-    static const struct message messages[] =
+    static const struct message create_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FOCUS_WINDOW,   FALSE,  0},
+        /* Do not test wparam here. If device creation succeeds,
+         * wparam is WA_ACTIVE. If device creation fails (testbot)
+         * wparam is set to WA_INACTIVE on some Windows versions. */
+        {WM_ACTIVATE,           FOCUS_WINDOW,   FALSE,  0},
+        {WM_SETFOCUS,           FOCUS_WINDOW,   FALSE,  0},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages[] =
+    {
+        /* WM_ACTIVATE (wparam = WA_INACTIVE) is sent on Windows. It is
+         * not reliable on X11 WMs. When the window focus follows the
+         * mouse pointer the message is not sent.
+         * {WM_ACTIVATE,           FOCUS_WINDOW,   TRUE,   WA_INACTIVE}, */
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        /* WM_DISPLAYCHANGE is sent to the focus window too, but the order is
+         * not deterministic. */
+        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW,  FALSE,  0},
+        /* Windows sends WM_ACTIVATE to the device window, indicating that
+         * SW_SHOWMINIMIZED is used instead of SW_MINIMIZE. Yet afterwards
+         * the foreground and focus window are NULL. On Wine SW_SHOWMINIMIZED
+         * leaves the device window active, breaking re-activation in the
+         * lost device test.
+         * {WM_ACTIVATE,           DEVICE_WINDOW,  TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   DEVICE_WINDOW,  FALSE,  0},
+        {WM_SIZE,               DEVICE_WINDOW,  TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        /* WM_ACTIVATEAPP is sent to the device window too, but the order is
+         * not deterministic. It may be sent after the focus window handling
+         * or before. */
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_nowc[] =
+    {
+        /* WM_ACTIVATE (wparam = WA_INACTIVE) is sent on Windows. It is
+         * not reliable on X11 WMs. When the window focus follows the
+         * mouse pointer the message is not sent.
+         * {WM_ACTIVATE,           FOCUS_WINDOW,   TRUE,   WA_INACTIVE}, */
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_hidden[] =
     {
-        {WM_WINDOWPOSCHANGING,  FOCUS_WINDOW},
-        {WM_ACTIVATE,           FOCUS_WINDOW},
-        {WM_SETFOCUS,           FOCUS_WINDOW},
-        {0,                     0},
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        {0,                     0,              FALSE,  0},
     };
+    static const struct message focus_loss_messages_hidden_unexpected[] =
+    {
+        /* KDE randomly does something with the hidden window during the
+         * mode change that sometimes generates a WM_WINDOWPOSCHANGING
+         * message. A WM_WINDOWPOSCHANGED message is not generated, so
+         * just flag WM_WINDOWPOSCHANGED as bad. */
+        {WM_WINDOWPOSCHANGED,   0,              FALSE,  0},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct
+    {
+        DWORD create_flags;
+        const struct message *focus_loss_messages;
+    }
+    tests[] =
+    {
+        {0,                               focus_loss_messages},
+        {CREATE_DEVICE_NOWINDOWCHANGES,   focus_loss_messages_nowc},
+    };
+
+    hr = pDirect3DCreate9Ex(D3D_SDK_VERSION, &d3d9ex);
+    if (FAILED(hr))
+    {
+        skip("Direct3D9Ex is not available (%#x)\n", hr);
+        return;
+    }
+
+    adapter_mode_count = IDirect3D9Ex_GetAdapterModeCount(d3d9ex, D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8);
+    for (i = 0; i < adapter_mode_count; ++i)
+    {
+        hr = IDirect3D9Ex_EnumAdapterModes(d3d9ex, D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8, i, &d3ddm);
+        ok(SUCCEEDED(hr), "Failed to enumerate display mode, hr %#x.\n", hr);
+
+        if (d3ddm.Width == registry_mode.dmPelsWidth && d3ddm.Height == registry_mode.dmPelsHeight)
+            continue;
+        /* The r200 driver on Windows XP enumerates modes like 320x200 and 320x240 but
+         * refuses to create a device at these sizes. */
+        if (d3ddm.Width < 640 || d3ddm.Height < 480)
+            continue;
+
+        if (!user32_width)
+        {
+            user32_width = d3ddm.Width;
+            user32_height = d3ddm.Height;
+            continue;
+        }
+
+        /* Make sure the d3d mode is smaller in width or height and at most
+         * equal in the other dimension than the mode passed to
+         * ChangeDisplaySettings. Otherwise Windows shrinks the window to
+         * the ChangeDisplaySettings parameters + 12. */
+        if (d3ddm.Width == user32_width && d3ddm.Height == user32_height)
+            continue;
+        if (d3ddm.Width <= user32_width && d3ddm.Height <= user32_height)
+        {
+            d3d_width = d3ddm.Width;
+            d3d_height = d3ddm.Height;
+            break;
+        }
+        if (user32_width <= d3ddm.Width && user32_height <= d3ddm.Height)
+        {
+            d3d_width = user32_width;
+            d3d_height = user32_height;
+            user32_width = d3ddm.Width;
+            user32_height = d3ddm.Height;
+            break;
+        }
+    }
+
+    if (!d3d_width)
+    {
+        skip("Could not find adequate modes, skipping mode tests.\n");
+        IDirect3D9Ex_Release(d3d9ex);
+        return;
+    }
 
     wc.lpfnWndProc = test_proc;
     wc.lpszClassName = "d3d9_test_wndproc_wc";
@@ -1813,121 +1955,226 @@ static void test_wndproc(void)
     thread_params.test_finished = CreateEventA(NULL, FALSE, FALSE, NULL);
     ok(!!thread_params.test_finished, "CreateEvent failed, last error %#x.\n", GetLastError());
 
-    focus_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
-            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, registry_mode.dmPelsWidth,
-            registry_mode.dmPelsHeight, 0, 0, 0, 0);
-    device_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
-            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, registry_mode.dmPelsWidth,
-            registry_mode.dmPelsHeight, 0, 0, 0, 0);
-    thread = CreateThread(NULL, 0, wndproc_thread, &thread_params, 0, &tid);
-    ok(!!thread, "Failed to create thread, last error %#x.\n", GetLastError());
+    memset(&devmode, 0, sizeof(devmode));
+    devmode.dmSize = sizeof(devmode);
 
-    res = WaitForSingleObject(thread_params.window_created, INFINITE);
-    ok(res == WAIT_OBJECT_0, "Wait failed (%#x), last error %#x.\n", res, GetLastError());
+    for (i = 0; i < sizeof(tests) / sizeof(*tests); ++i)
+    {
+        devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+        devmode.dmPelsWidth = user32_width;
+        devmode.dmPelsHeight = user32_height;
+        change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
+        ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
+        focus_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
+                WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, user32_width, user32_height, 0, 0, 0, 0);
+        device_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
+                WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, user32_width, user32_height, 0, 0, 0, 0);
+        thread = CreateThread(NULL, 0, wndproc_thread, &thread_params, 0, &tid);
+        ok(!!thread, "Failed to create thread, last error %#x.\n", GetLastError());
 
-    trace("device_window %p, focus_window %p, dummy_window %p.\n",
-            device_window, focus_window, thread_params.dummy_window);
+        res = WaitForSingleObject(thread_params.window_created, INFINITE);
+        ok(res == WAIT_OBJECT_0, "Wait failed (%#x), last error %#x.\n", res, GetLastError());
 
-    tmp = GetFocus();
-    ok(tmp == device_window, "Expected focus %p, got %p.\n", device_window, tmp);
-    if (thread_params.running_in_foreground)
-    {
-        tmp = GetForegroundWindow();
-        ok(tmp == thread_params.dummy_window, "Expected foreground window %p, got %p.\n",
-                thread_params.dummy_window, tmp);
-    }
-    else
-        skip("Not running in foreground, skip foreground window test\n");
+        proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
+                (LONG_PTR)test_proc, proc);
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
+                (LONG_PTR)test_proc, proc);
 
-    flush_events();
+        trace("device_window %p, focus_window %p, dummy_window %p.\n",
+                device_window, focus_window, thread_params.dummy_window);
 
-    expect_messages = messages;
+        tmp = GetFocus();
+        ok(tmp == device_window, "Expected focus %p, got %p.\n", device_window, tmp);
+        if (thread_params.running_in_foreground)
+        {
+            tmp = GetForegroundWindow();
+            ok(tmp == thread_params.dummy_window, "Expected foreground window %p, got %p.\n",
+                    thread_params.dummy_window, tmp);
+        }
+        else
+            skip("Not running in foreground, skip foreground window test\n");
 
-    device_desc.device_window = device_window;
-    device_desc.width = registry_mode.dmPelsWidth;
-    device_desc.height = registry_mode.dmPelsHeight;
-    device_desc.flags = CREATE_DEVICE_FULLSCREEN;
-    if (!(device = create_device(focus_window, &device_desc)))
-    {
-        skip("Failed to create a D3D device, skipping tests.\n");
-        goto done;
-    }
+        flush_events();
 
-    ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it.\n",
-            expect_messages->message, expect_messages->window);
-    expect_messages = NULL;
+        expect_messages = create_messages;
 
-    if (0) /* Disabled until we can make this work in a reliable way on Wine. */
-    {
-        tmp = GetFocus();
-        ok(tmp == focus_window, "Expected focus %p, got %p.\n", focus_window, tmp);
-        tmp = GetForegroundWindow();
-        ok(tmp == focus_window, "Expected foreground window %p, got %p.\n", focus_window, tmp);
-    }
-    SetForegroundWindow(focus_window);
-    flush_events();
+        device_desc.device_window = device_window;
+        device_desc.width = d3d_width;
+        device_desc.height = d3d_height;
+        device_desc.flags = CREATE_DEVICE_FULLSCREEN | tests[i].create_flags;
+        if (!(device = create_device(focus_window, &device_desc)))
+        {
+            skip("Failed to create a D3D device, skipping tests.\n");
+            goto done;
+        }
 
-    filter_messages = focus_window;
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
 
-    proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
+        if (0) /* Disabled until we can make this work in a reliable way on Wine. */
+        {
+            tmp = GetFocus();
+            ok(tmp == focus_window, "Expected focus %p, got %p.\n", focus_window, tmp);
+            tmp = GetForegroundWindow();
+            ok(tmp == focus_window, "Expected foreground window %p, got %p.\n", focus_window, tmp);
+        }
+        SetForegroundWindow(focus_window);
+        flush_events();
+
+        proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
+                (LONG_PTR)test_proc, proc);
+
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n",
+                (LONG_PTR)test_proc);
+
+        /* Change the mode while the device is in use and then drop focus. */
+        devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+        devmode.dmPelsWidth = user32_width;
+        devmode.dmPelsHeight = user32_height;
+        change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
+        ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x, i=%u.\n", change_ret, i);
+
+        /* Native needs a present call to pick up the mode change. */
+        hr = IDirect3DDevice9Ex_Present(device, NULL, NULL, NULL, NULL);
+        todo_wine ok(hr == S_PRESENT_MODE_CHANGED, "Got unexpected hr %#x, i=%u.\n", hr, i);
+        hr = IDirect3DDevice9Ex_CheckDeviceState(device, device_window);
+        todo_wine ok(hr == S_PRESENT_MODE_CHANGED, "Got unexpected hr %#x, i=%u.\n", hr, i);
+
+        expect_messages = tests[i].focus_loss_messages;
+        /* SetForegroundWindow is a poor replacement for the user pressing alt-tab or
+         * manually changing the focus. It generates the same messages, but the task
+         * bar still shows the previous foreground window as active, and the window has
+         * an inactive titlebar if reactivated with SetForegroundWindow. Reactivating
+         * the device is difficult, see below. */
+        SetForegroundWindow(GetDesktopWindow());
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
+        tmp = GetFocus();
+        ok(tmp != device_window, "The device window is active, i=%u.\n", i);
+        ok(tmp != focus_window, "The focus window is active, i=%u.\n", i);
+
+        hr = IDirect3DDevice9Ex_CheckDeviceState(device, device_window);
+        ok(hr == S_PRESENT_OCCLUDED, "Got unexpected hr %#x, i=%u.\n", hr, i);
+
+        ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+        ok(ret, "Failed to get display mode.\n");
+        ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+                && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+                devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+        /* In d3d9ex the device and focus windows have to be minimized and restored,
+         * otherwise native does not notice that focus has been restored. This is
+         * independent of D3DCREATE_NOWINDOWCHANGES. */
+        ShowWindow(device_window, SW_MINIMIZE);
+        ShowWindow(device_window, SW_RESTORE);
+
+        /* Reactivation messages like in d3d8/9 are random in native d3d9ex.
+         * Sometimes they are sent, sometimes they are not (tested on Vista
+         * and Windows 7). The minimizing and restoring of the device window
+         * may have something to do with this, but if the messages are sent,
+         * they are generated by the 3 calls below. */
+        ShowWindow(focus_window, SW_MINIMIZE);
+        ShowWindow(focus_window, SW_RESTORE);
+        /* Set focus twice to make KDE and fvwm in focus-follows-mouse mode happy. */
+        SetForegroundWindow(focus_window);
+        flush_events();
+        SetForegroundWindow(focus_window);
+        flush_events();
+
+        /* Calling Reset is not necessary in d3d9ex. */
+        hr = IDirect3DDevice9Ex_CheckDeviceState(device, device_window);
+        ok(hr == S_OK, "Got unexpected hr %#x, i=%u.\n", hr, i);
+
+        ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+        ok(ret, "Failed to get display mode.\n");
+        ok(devmode.dmPelsWidth == d3d_width
+                && devmode.dmPelsHeight == d3d_height, "Got unexpect screen size %ux%u.\n",
+                devmode.dmPelsWidth, devmode.dmPelsHeight);
 
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n", (LONG_PTR)test_proc);
+        hr = reset_device(device, &device_desc);
+        ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
 
-    ref = IDirect3DDevice9Ex_Release(device);
-    ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+        ShowWindow(device_window, SW_HIDE);
+        flush_events();
+
+        expect_messages = focus_loss_messages_hidden;
+        unexpected_messages = focus_loss_messages_hidden_unexpected;
+        SetForegroundWindow(GetDesktopWindow());
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
+        unexpected_messages = NULL;
+
+        ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+        ok(ret, "Failed to get display mode.\n");
+        ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth, "Got unexpect width %u.\n", devmode.dmPelsWidth);
+        ok(devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect height %u.\n", devmode.dmPelsHeight);
+
+        ShowWindow(device_window, SW_RESTORE);
+        ShowWindow(focus_window, SW_MINIMIZE);
+        ShowWindow(focus_window, SW_RESTORE);
+        SetForegroundWindow(focus_window);
+        flush_events();
+
+        filter_messages = focus_window;
+        ref = IDirect3DDevice9Ex_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u, i=%u.\n", ref, i);
 
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
+        /* Fix up the mode until Wine's device release behavior is fixed. */
+        change_ret = ChangeDisplaySettingsW(NULL, CDS_FULLSCREEN);
+        ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    device_desc.device_window = focus_window;
-    if (!(device = create_device(focus_window, &device_desc)))
-    {
-        skip("Failed to create a D3D device, skipping tests.\n");
-        goto done;
-    }
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx, i=%u.\n",
+                (LONG_PTR)test_proc, proc, i);
 
-    ref = IDirect3DDevice9Ex_Release(device);
-    ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+        device_desc.device_window = focus_window;
+        if (!(device = create_device(focus_window, &device_desc)))
+        {
+            skip("Failed to create a D3D device, skipping tests.\n");
+            goto done;
+        }
 
-    device_desc.device_window = device_window;
-    if (!(device = create_device(focus_window, &device_desc)))
-    {
-        skip("Failed to create a D3D device, skipping tests.\n");
-        goto done;
-    }
+        ref = IDirect3DDevice9Ex_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u, i=%u.\n", ref, i);
 
-    proc = SetWindowLongPtrA(focus_window, GWLP_WNDPROC, (LONG_PTR)DefWindowProcA);
-    ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n", (LONG_PTR)test_proc);
+        device_desc.device_window = device_window;
+        if (!(device = create_device(focus_window, &device_desc)))
+        {
+            skip("Failed to create a D3D device, skipping tests.\n");
+            goto done;
+        }
 
-    ref = IDirect3DDevice9Ex_Release(device);
-    ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+        proc = SetWindowLongPtrA(focus_window, GWLP_WNDPROC, (LONG_PTR)DefWindowProcA);
+        ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n",
+                (LONG_PTR)test_proc);
 
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)DefWindowProcA, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)DefWindowProcA, proc);
+        ref = IDirect3DDevice9Ex_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)DefWindowProcA, "Expected wndproc %#lx, got %#lx.\n",
+                (LONG_PTR)DefWindowProcA, proc);
 
 done:
-    filter_messages = NULL;
+        filter_messages = NULL;
+        DestroyWindow(device_window);
+        DestroyWindow(focus_window);
+        SetEvent(thread_params.test_finished);
+        WaitForSingleObject(thread, INFINITE);
+        CloseHandle(thread);
+    }
 
-    SetEvent(thread_params.test_finished);
-    WaitForSingleObject(thread, INFINITE);
     CloseHandle(thread_params.test_finished);
     CloseHandle(thread_params.window_created);
-    CloseHandle(thread);
 
-    DestroyWindow(device_window);
-    DestroyWindow(focus_window);
     UnregisterClassA("d3d9_test_wndproc_wc", GetModuleHandleA(NULL));
 }
 
@@ -2135,24 +2382,27 @@ done:
 static void test_window_style(void)
 {
     RECT focus_rect, device_rect, fullscreen_rect, r, r2;
-    LONG device_style, device_exstyle;
+    LONG device_style, device_exstyle, expected_style;
     LONG focus_style, focus_exstyle;
     struct device_desc device_desc;
     LONG style;
     IDirect3DDevice9Ex *device;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
     static const struct
     {
         LONG style_flags;
         DWORD device_flags;
+        LONG focus_loss_style;
+        LONG create2_style, create2_exstyle;
     }
     tests[] =
     {
-        {0,             0},
-        {WS_VISIBLE,    0},
-        {0,             CREATE_DEVICE_NOWINDOWCHANGES},
-        {WS_VISIBLE,    CREATE_DEVICE_NOWINDOWCHANGES},
+        {0,             0,                              0,              WS_VISIBLE, WS_EX_TOPMOST},
+        {WS_VISIBLE,    0,                              WS_MINIMIZE,    WS_VISIBLE, WS_EX_TOPMOST},
+        {0,             CREATE_DEVICE_NOWINDOWCHANGES,  0,              0,          0},
+        {WS_VISIBLE,    CREATE_DEVICE_NOWINDOWCHANGES,  0,              0,          0},
     };
     unsigned int i;
 
@@ -2240,6 +2490,78 @@ static void test_window_style(void)
         ref = IDirect3DDevice9Ex_Release(device);
         ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
 
+        style = GetWindowLongA(device_window, GWL_STYLE);
+        if (device_style & WS_VISIBLE)
+            ok(style == device_style, "Expected device window style %#x, got %#x, i=%u.\n",
+                device_style, style, i);
+        else
+            todo_wine ok(style == device_style, "Expected device window style %#x, got %#x, i=%u.\n",
+                    device_style, style, i);
+        style = GetWindowLongA(device_window, GWL_EXSTYLE);
+        todo_wine ok(style == device_exstyle, "Expected device window extended style %#x, got %#x, i=%u.\n",
+                device_exstyle, style, i);
+
+        style = GetWindowLongA(focus_window, GWL_STYLE);
+        ok(style == focus_style, "Expected focus window style %#x, got %#x, i=%u.\n",
+                focus_style, style, i);
+        style = GetWindowLongA(focus_window, GWL_EXSTYLE);
+        ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x, i=%u.\n",
+                focus_exstyle, style, i);
+
+        /* The second time a device is created on the window the window becomes visible and
+         * topmost if D3DCREATE_NOWINDOWCHANGES is not set. */
+        device_desc.flags = CREATE_DEVICE_FULLSCREEN | tests[i].device_flags;
+        device = create_device(focus_window, &device_desc);
+        ok(!!device, "Failed to create a D3D device.\n");
+        style = GetWindowLongA(device_window, GWL_STYLE);
+        expected_style = device_style | tests[i].create2_style;
+        todo_wine ok(style == expected_style, "Expected device window style %#x, got %#x, i=%u.\n",
+                expected_style, style, i);
+        expected_style = device_exstyle | tests[i].create2_exstyle;
+        style = GetWindowLongA(device_window, GWL_EXSTYLE);
+        todo_wine ok(style == expected_style, "Expected device window extended style %#x, got %#x, i=%u.\n",
+                expected_style, style, i);
+
+        style = GetWindowLongA(focus_window, GWL_STYLE);
+        ok(style == focus_style, "Expected focus window style %#x, got %#x, i=%u.\n",
+                focus_style, style, i);
+        style = GetWindowLongA(focus_window, GWL_EXSTYLE);
+        ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x, i=%u.\n",
+                focus_exstyle, style, i);
+        ref = IDirect3DDevice9Ex_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+
+        DestroyWindow(device_window);
+        DestroyWindow(focus_window);
+        focus_window = CreateWindowA("d3d9_test_wc", "d3d9_test", WS_OVERLAPPEDWINDOW | tests[i].style_flags,
+                0, 0, registry_mode.dmPelsWidth / 2, registry_mode.dmPelsHeight / 2, 0, 0, 0, 0);
+        device_window = CreateWindowA("d3d9_test_wc", "d3d9_test", WS_OVERLAPPEDWINDOW | tests[i].style_flags,
+                0, 0, registry_mode.dmPelsWidth / 2, registry_mode.dmPelsHeight / 2, 0, 0, 0, 0);
+
+        device_desc.device_window = device_window;
+        device = create_device(focus_window, &device_desc);
+        ok(!!device, "Failed to create a D3D device.\n");
+        ret = SetForegroundWindow(GetDesktopWindow());
+        ok(ret, "Failed to set foreground window.\n");
+
+        style = GetWindowLongA(device_window, GWL_STYLE);
+        expected_style = device_style | tests[i].focus_loss_style;
+        todo_wine ok(style == expected_style, "Expected device window style %#x, got %#x, i=%u.\n",
+                expected_style, style, i);
+        style = GetWindowLongA(device_window, GWL_EXSTYLE);
+        todo_wine ok(style == device_exstyle, "Expected device window extended style %#x, got %#x, i=%u.\n",
+                device_exstyle, style, i);
+
+        style = GetWindowLongA(focus_window, GWL_STYLE);
+        ok(style == focus_style, "Expected focus window style %#x, got %#x, i=%u.\n",
+                focus_style, style, i);
+        style = GetWindowLongA(focus_window, GWL_EXSTYLE);
+        ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x, i=%u.\n",
+                focus_exstyle, style, i);
+
+        ref = IDirect3DDevice9Ex_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+
         DestroyWindow(device_window);
         DestroyWindow(focus_window);
     }
diff --git a/dlls/d3d9/tests/device.c b/dlls/d3d9/tests/device.c
index 1a5008a..cd6a9bd 100644
--- a/dlls/d3d9/tests/device.c
+++ b/dlls/d3d9/tests/device.c
@@ -1058,12 +1058,16 @@ static void test_swapchain(void)
     IDirect3DDevice9 *device;
     IDirect3D9 *d3d;
     ULONG refcount;
-    HWND window;
+    HWND window, window2;
     HRESULT hr;
+    struct device_desc device_desc;
 
     window = CreateWindowA("d3d9_test_wc", "d3d9_test", WS_OVERLAPPEDWINDOW,
             0, 0, 640, 480, NULL, NULL, NULL, NULL);
     ok(!!window, "Failed to create a window.\n");
+    window2 = CreateWindowA("d3d9_test_wc", "d3d9_test", WS_OVERLAPPEDWINDOW,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    ok(!!window2, "Failed to create a window.\n");
     d3d = Direct3DCreate9(D3D_SDK_VERSION);
     ok(!!d3d, "Failed to create a D3D object.\n");
     if (!(device = create_device(d3d, window, NULL)))
@@ -1176,10 +1180,42 @@ static void test_swapchain(void)
     IDirect3DSwapChain9_Release(swapchain3);
     IDirect3DSwapChain9_Release(swapchain2);
     IDirect3DSwapChain9_Release(swapchain1);
+
+    d3dpp.Windowed = FALSE;
+    d3dpp.hDeviceWindow = window;
+    d3dpp.BackBufferCount = 1;
+    hr = IDirect3DDevice9_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.hDeviceWindow = window2;
+    hr = IDirect3DDevice9_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+
+    device_desc.width = registry_mode.dmPelsWidth;
+    device_desc.height = registry_mode.dmPelsHeight;
+    device_desc.device_window = window;
+    device_desc.flags = CREATE_DEVICE_FULLSCREEN;
+    hr = reset_device(device, &device_desc);
+    ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+
+    d3dpp.hDeviceWindow = window;
+    hr = IDirect3DDevice9_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.hDeviceWindow = window2;
+    hr = IDirect3DDevice9_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.Windowed = TRUE;
+    d3dpp.hDeviceWindow = window;
+    hr = IDirect3DDevice9_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+    d3dpp.hDeviceWindow = window2;
+    hr = IDirect3DDevice9_CreateAdditionalSwapChain(device, &d3dpp, &swapchain1);
+    ok(hr == D3DERR_INVALIDCALL, "Got unexpected hr %#x\n", hr);
+
     refcount = IDirect3DDevice9_Release(device);
     ok(!refcount, "Device has %u references left.\n", refcount);
 cleanup:
     IDirect3D9_Release(d3d);
+    DestroyWindow(window2);
     DestroyWindow(window);
 }
 
@@ -1535,15 +1571,20 @@ static void test_cursor(void)
     HCURSOR cur;
     HWND window;
     HRESULT hr;
+    BOOL ret;
 
+    window = CreateWindowA("d3d9_test_wc", "d3d9_test", WS_OVERLAPPEDWINDOW | WS_VISIBLE,
+            0, 0, 640, 480, NULL, NULL, NULL, NULL);
+    ok(!!window, "Failed to create a window.\n");
+
+    ret = SetCursorPos(50, 50);
+    ok(ret, "Failed to set cursor position.\n");
+    flush_events();
     memset(&info, 0, sizeof(info));
     info.cbSize = sizeof(info);
     ok(GetCursorInfo(&info), "GetCursorInfo failed\n");
     cur = info.hCursor;
 
-    window = CreateWindowA("d3d9_test_wc", "d3d9_test", WS_OVERLAPPEDWINDOW,
-            0, 0, 640, 480, NULL, NULL, NULL, NULL);
-    ok(!!window, "Failed to create a window.\n");
     d3d = Direct3DCreate9(D3D_SDK_VERSION);
     ok(!!d3d, "Failed to create a D3D object.\n");
     if (!(device = create_device(d3d, window, NULL)))
@@ -1587,12 +1628,11 @@ static void test_cursor(void)
     hr = IDirect3DDevice9_ShowCursor(device, TRUE);
     ok(hr == TRUE, "IDirect3DDevice9_ShowCursor returned %08x\n", hr);
 
-    /* GDI cursor unchanged */
     memset(&info, 0, sizeof(info));
     info.cbSize = sizeof(info);
     ok(GetCursorInfo(&info), "GetCursorInfo failed\n");
     ok(info.flags & CURSOR_SHOWING, "The gdi cursor is hidden (%08x)\n", info.flags);
-    ok(info.hCursor == cur, "The cursor handle is %p\n", info.hCursor); /* unchanged */
+    ok(info.hCursor != cur, "The cursor handle is %p\n", info.hCursor);
 
     refcount = IDirect3DDevice9_Release(device);
     ok(!refcount, "Device has %u references left.\n", refcount);
@@ -3091,9 +3131,11 @@ struct message
 {
     UINT message;
     enum message_window window;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
 };
 
-static const struct message *expect_messages;
+static const struct message *expect_messages, *unexpected_messages;
 static HWND device_window, focus_window;
 
 struct wndproc_thread_param
@@ -3131,7 +3173,22 @@ static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM
                 break;
         };
 
-        if (hwnd == w && expect_messages->message == message) ++expect_messages;
+        if (hwnd == w && expect_messages->message == message)
+        {
+            if (expect_messages->check_wparam)
+                ok(wparam == expect_messages->expect_wparam,
+                        "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                        wparam, message, expect_messages->expect_wparam);
+
+            ++expect_messages;
+        }
+    }
+
+    if (unexpected_messages)
+    {
+        const struct message *i;
+        for (i = unexpected_messages; i->message; i++)
+            ok(i->message != message, "Got unexpected message %x on window %p.\n", message, hwnd);
     }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
@@ -3182,18 +3239,151 @@ static void test_wndproc(void)
     ULONG ref;
     DWORD res, tid;
     HWND tmp;
+    UINT i, adapter_mode_count;
+    HRESULT hr;
+    D3DDISPLAYMODE d3ddm;
+    DWORD d3d_width = 0, d3d_height = 0, user32_width = 0, user32_height = 0;
+    DEVMODEW devmode;
+    LONG change_ret;
+    BOOL ret;
 
-    static const struct message messages[] =
+    static const struct message create_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FOCUS_WINDOW,   FALSE,  0},
+        /* Do not test wparam here. If device creation succeeds,
+         * wparam is WA_ACTIVE. If device creation fails (testbot)
+         * wparam is set to WA_INACTIVE on some Windows versions. */
+        {WM_ACTIVATE,           FOCUS_WINDOW,   FALSE,  0},
+        {WM_SETFOCUS,           FOCUS_WINDOW,   FALSE,  0},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages[] =
+    {
+        /* WM_ACTIVATE (wparam = WA_INACTIVE) is sent on Windows. It is
+         * not reliable on X11 WMs. When the window focus follows the
+         * mouse pointer the message is not sent.
+         * {WM_ACTIVATE,           FOCUS_WINDOW,   TRUE,   WA_INACTIVE}, */
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        /* WM_DISPLAYCHANGE is sent to the focus window too, but the order is
+         * not deterministic. */
+        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW,  FALSE,  0},
+        /* Windows sends WM_ACTIVATE to the device window, indicating that
+         * SW_SHOWMINIMIZED is used instead of SW_MINIMIZE. Yet afterwards
+         * the foreground and focus window are NULL. On Wine SW_SHOWMINIMIZED
+         * leaves the device window active, breaking re-activation in the
+         * lost device test.
+         * {WM_ACTIVATE,           DEVICE_WINDOW,  TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   DEVICE_WINDOW,  FALSE,  0},
+        {WM_SIZE,               DEVICE_WINDOW,  TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        /* WM_ACTIVATEAPP is sent to the device window too, but the order is
+         * not deterministic. It may be sent after the focus window handling
+         * or before. */
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_nowc[] =
+    {
+        /* WM_ACTIVATE (wparam = WA_INACTIVE) is sent on Windows. It is
+         * not reliable on X11 WMs. When the window focus follows the
+         * mouse pointer the message is not sent.
+         * {WM_ACTIVATE,           FOCUS_WINDOW,   TRUE,   WA_INACTIVE}, */
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message reactivate_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  DEVICE_WINDOW,  FALSE,  0},
+        {WM_WINDOWPOSCHANGED,   DEVICE_WINDOW,  FALSE,  0},
+        /* optional WM_MOVE here if size changed */
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   TRUE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message reactivate_messages_nowc[] =
+    {
+        /* We're activating the device window before activating the
+         * focus window, so no ACTIVATEAPP message is sent. */
+        {WM_ACTIVATE,           FOCUS_WINDOW,   TRUE,   WA_ACTIVE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_hidden[] =
+    {
+        {WM_DISPLAYCHANGE,      DEVICE_WINDOW,  FALSE,  0},
+        {WM_ACTIVATEAPP,        FOCUS_WINDOW,   TRUE,   FALSE},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct message focus_loss_messages_hidden_unexpected[] =
+    {
+        /* KDE randomly does something with the hidden window during the
+         * mode change that sometimes generates a WM_WINDOWPOSCHANGING
+         * message. A WM_WINDOWPOSCHANGED message is not generated, so
+         * just flag WM_WINDOWPOSCHANGED as bad. */
+        {WM_WINDOWPOSCHANGED,   0,              FALSE,  0},
+        {0,                     0,              FALSE,  0},
+    };
+    static const struct
+    {
+        DWORD create_flags;
+        const struct message *focus_loss_messages, *reactivate_messages;
+    }
+    tests[] =
     {
-        {WM_WINDOWPOSCHANGING,  FOCUS_WINDOW},
-        {WM_ACTIVATE,           FOCUS_WINDOW},
-        {WM_SETFOCUS,           FOCUS_WINDOW},
-        {0,                     0},
+        {0,                               focus_loss_messages,      reactivate_messages},
+        {CREATE_DEVICE_NOWINDOWCHANGES,   focus_loss_messages_nowc, reactivate_messages_nowc},
     };
 
     d3d9 = Direct3DCreate9(D3D_SDK_VERSION);
     ok(!!d3d9, "Failed to create a D3D object.\n");
 
+    adapter_mode_count = IDirect3D9_GetAdapterModeCount(d3d9, D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8);
+    for (i = 0; i < adapter_mode_count; ++i)
+    {
+        hr = IDirect3D9_EnumAdapterModes(d3d9, D3DADAPTER_DEFAULT, D3DFMT_X8R8G8B8, i, &d3ddm);
+        ok(SUCCEEDED(hr), "Failed to enumerate display mode, hr %#x.\n", hr);
+
+        if (d3ddm.Width == registry_mode.dmPelsWidth && d3ddm.Height == registry_mode.dmPelsHeight)
+            continue;
+        /* The r200 driver on Windows XP enumerates modes like 320x200 and 320x240 but
+         * refuses to create a device at these sizes. */
+        if (d3ddm.Width < 640 || d3ddm.Height < 480)
+            continue;
+
+        if (!user32_width)
+        {
+            user32_width = d3ddm.Width;
+            user32_height = d3ddm.Height;
+            continue;
+        }
+
+        /* Make sure the d3d mode is smaller in width or height and at most
+         * equal in the other dimension than the mode passed to
+         * ChangeDisplaySettings. Otherwise Windows shrinks the window to
+         * the ChangeDisplaySettings parameters + 12. */
+        if (d3ddm.Width == user32_width && d3ddm.Height == user32_height)
+            continue;
+        if (d3ddm.Width <= user32_width && d3ddm.Height <= user32_height)
+        {
+            d3d_width = d3ddm.Width;
+            d3d_height = d3ddm.Height;
+            break;
+        }
+        if (user32_width <= d3ddm.Width && user32_height <= d3ddm.Height)
+        {
+            d3d_width = user32_width;
+            d3d_height = user32_height;
+            user32_width = d3ddm.Width;
+            user32_height = d3ddm.Height;
+            break;
+        }
+    }
+
+    if (!d3d_width)
+    {
+        skip("Could not find adequate modes, skipping mode tests.\n");
+        IDirect3D9_Release(d3d9);
+        return;
+    }
+
     wc.lpfnWndProc = test_proc;
     wc.lpszClassName = "d3d9_test_wndproc_wc";
     ok(RegisterClassA(&wc), "Failed to register window class.\n");
@@ -3203,122 +3393,239 @@ static void test_wndproc(void)
     thread_params.test_finished = CreateEventA(NULL, FALSE, FALSE, NULL);
     ok(!!thread_params.test_finished, "CreateEvent failed, last error %#x.\n", GetLastError());
 
-    focus_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
-            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, registry_mode.dmPelsWidth,
-            registry_mode.dmPelsHeight, 0, 0, 0, 0);
-    device_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
-            WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, registry_mode.dmPelsWidth,
-            registry_mode.dmPelsHeight, 0, 0, 0, 0);
-    thread = CreateThread(NULL, 0, wndproc_thread, &thread_params, 0, &tid);
-    ok(!!thread, "Failed to create thread, last error %#x.\n", GetLastError());
+    memset(&devmode, 0, sizeof(devmode));
+    devmode.dmSize = sizeof(devmode);
+    for (i = 0; i < sizeof(tests) / sizeof(*tests); ++i)
+    {
+        devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+        devmode.dmPelsWidth = user32_width;
+        devmode.dmPelsHeight = user32_height;
+        change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
+        ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    res = WaitForSingleObject(thread_params.window_created, INFINITE);
-    ok(res == WAIT_OBJECT_0, "Wait failed (%#x), last error %#x.\n", res, GetLastError());
+        focus_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
+                WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, user32_width, user32_height, 0, 0, 0, 0);
+        device_window = CreateWindowA("d3d9_test_wndproc_wc", "d3d9_test",
+                WS_MAXIMIZE | WS_VISIBLE | WS_CAPTION, 0, 0, user32_width, user32_height, 0, 0, 0, 0);
+        thread = CreateThread(NULL, 0, wndproc_thread, &thread_params, 0, &tid);
+        ok(!!thread, "Failed to create thread, last error %#x.\n", GetLastError());
 
-    proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
+        res = WaitForSingleObject(thread_params.window_created, INFINITE);
+        ok(res == WAIT_OBJECT_0, "Wait failed (%#x), last error %#x.\n", res, GetLastError());
 
-    trace("device_window %p, focus_window %p, dummy_window %p.\n",
-            device_window, focus_window, thread_params.dummy_window);
+        proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
+                (LONG_PTR)test_proc, proc);
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
+                (LONG_PTR)test_proc, proc);
 
-    tmp = GetFocus();
-    ok(tmp == device_window, "Expected focus %p, got %p.\n", device_window, tmp);
-    if (thread_params.running_in_foreground)
-    {
-        tmp = GetForegroundWindow();
-        ok(tmp == thread_params.dummy_window, "Expected foreground window %p, got %p.\n",
-                thread_params.dummy_window, tmp);
-    }
-    else
-        skip("Not running in foreground, skip foreground window test\n");
+        trace("device_window %p, focus_window %p, dummy_window %p.\n",
+                device_window, focus_window, thread_params.dummy_window);
 
-    flush_events();
+        tmp = GetFocus();
+        ok(tmp == device_window, "Expected focus %p, got %p.\n", device_window, tmp);
+        if (thread_params.running_in_foreground)
+        {
+            tmp = GetForegroundWindow();
+            ok(tmp == thread_params.dummy_window, "Expected foreground window %p, got %p.\n",
+                    thread_params.dummy_window, tmp);
+        }
+        else
+            skip("Not running in foreground, skip foreground window test\n");
 
-    expect_messages = messages;
+        flush_events();
 
-    device_desc.device_window = device_window;
-    device_desc.width = registry_mode.dmPelsWidth;
-    device_desc.height = registry_mode.dmPelsHeight;
-    device_desc.flags = CREATE_DEVICE_FULLSCREEN;
-    if (!(device = create_device(d3d9, focus_window, &device_desc)))
-    {
-        skip("Failed to create a D3D device, skipping tests.\n");
-        goto done;
-    }
+        expect_messages = create_messages;
 
-    ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it.\n",
-            expect_messages->message, expect_messages->window);
-    expect_messages = NULL;
+        device_desc.device_window = device_window;
+        device_desc.width = d3d_width;
+        device_desc.height = d3d_height;
+        device_desc.flags = CREATE_DEVICE_FULLSCREEN | tests[i].create_flags;
+        if (!(device = create_device(d3d9, focus_window, &device_desc)))
+        {
+            skip("Failed to create a D3D device, skipping tests.\n");
+            goto done;
+        }
 
-    if (0) /* Disabled until we can make this work in a reliable way on Wine. */
-    {
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
+
+        if (0) /* Disabled until we can make this work in a reliable way on Wine. */
+        {
+            tmp = GetFocus();
+            ok(tmp == focus_window, "Expected focus %p, got %p.\n", focus_window, tmp);
+            tmp = GetForegroundWindow();
+            ok(tmp == focus_window, "Expected foreground window %p, got %p.\n", focus_window, tmp);
+        }
+        SetForegroundWindow(focus_window);
+        flush_events();
+
+        proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx, i=%u.\n",
+                (LONG_PTR)test_proc, proc, i);
+
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx, i=%u.\n",
+                (LONG_PTR)test_proc, i);
+
+        /* Change the mode while the device is in use and then drop focus. */
+        devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+        devmode.dmPelsWidth = user32_width;
+        devmode.dmPelsHeight = user32_height;
+        change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
+        ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x, i=%u.\n", change_ret, i);
+
+        /* Wine doesn't (yet) mark the device not reset when the mode is changed, thus the todo_wine.
+         * But sometimes focus-follows-mouse WMs also temporarily drop window focus, which makes
+         * mark the device lost, then not reset, causing the test to succeed for the wrong reason. */
+        hr = IDirect3DDevice9_TestCooperativeLevel(device);
+        if (hr == D3DERR_DEVICENOTRESET)
+            ok(hr == D3DERR_DEVICENOTRESET, "Got unexpected hr %#x.\n", hr);
+        else
+            todo_wine ok(hr == D3DERR_DEVICENOTRESET, "Got unexpected hr %#x.\n", hr);
+
+        expect_messages = tests[i].focus_loss_messages;
+        /* SetForegroundWindow is a poor replacement for the user pressing alt-tab or
+         * manually changing the focus. It generates the same messages, but the task
+         * bar still shows the previous foreground window as active, and the window has
+         * an inactive titlebar if reactivated with SetForegroundWindow. Reactivating
+         * the device is difficult, see below. */
+        SetForegroundWindow(GetDesktopWindow());
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
         tmp = GetFocus();
-        ok(tmp == focus_window, "Expected focus %p, got %p.\n", focus_window, tmp);
-        tmp = GetForegroundWindow();
-        ok(tmp == focus_window, "Expected foreground window %p, got %p.\n", focus_window, tmp);
-    }
-    SetForegroundWindow(focus_window);
-    flush_events();
+        ok(tmp != device_window, "The device window is active, i=%u.\n", i);
+        ok(tmp != focus_window, "The focus window is active, i=%u.\n", i);
+
+        hr = IDirect3DDevice9_TestCooperativeLevel(device);
+        ok(hr == D3DERR_DEVICELOST, "Got unexpected hr %#x.\n", hr);
+
+        ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+        ok(ret, "Failed to get display mode.\n");
+        ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+                && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+                devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+        /* This is needed on native with D3DCREATE_NOWINDOWCHANGES, and it needs to be
+         * done before the focus window is restored. This makes sense to some extent
+         * because minimizing the window on focus loss is the application's job if this
+         * flag is set. */
+        if (tests[i].create_flags & CREATE_DEVICE_NOWINDOWCHANGES)
+        {
+            ShowWindow(device_window, SW_MINIMIZE);
+            ShowWindow(device_window, SW_RESTORE);
+        }
+        flush_events();
+
+        /* I have to minimize and restore the focus window, otherwise native d3d9 fails
+         * device::reset with D3DERR_DEVICELOST. This does not happen when the window
+         * restore is triggered by the user. */
+        expect_messages = tests[i].reactivate_messages;
+        ShowWindow(focus_window, SW_MINIMIZE);
+        ShowWindow(focus_window, SW_RESTORE);
+        /* Set focus twice to make KDE and fvwm in focus-follows-mouse mode happy. */
+        SetForegroundWindow(focus_window);
+        flush_events();
+        SetForegroundWindow(focus_window);
+        flush_events(); /* WM_WINDOWPOSCHANGING etc arrive after SetForegroundWindow returns. */
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
+
+        hr = IDirect3DDevice9_TestCooperativeLevel(device);
+        ok(hr == D3DERR_DEVICENOTRESET, "Got unexpected hr %#x.\n", hr);
+
+        ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+        ok(ret, "Failed to get display mode.\n");
+        ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+                && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+                devmode.dmPelsWidth, devmode.dmPelsHeight);
 
-    filter_messages = focus_window;
+        hr = reset_device(device, &device_desc);
+        ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
 
-    proc = GetWindowLongPtrA(device_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
+        ShowWindow(device_window, SW_HIDE);
+        flush_events();
+
+        expect_messages = focus_loss_messages_hidden;
+        unexpected_messages = focus_loss_messages_hidden_unexpected;
+        SetForegroundWindow(GetDesktopWindow());
+        ok(!expect_messages->message, "Expected message %#x for window %#x, but didn't receive it, i=%u.\n",
+                expect_messages->message, expect_messages->window, i);
+        expect_messages = NULL;
+        unexpected_messages = NULL;
+
+        ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+        ok(ret, "Failed to get display mode.\n");
+        ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth, "Got unexpect width %u.\n", devmode.dmPelsWidth);
+        ok(devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect height %u.\n", devmode.dmPelsHeight);
+
+        ShowWindow(device_window, SW_RESTORE);
+        ShowWindow(focus_window, SW_MINIMIZE);
+        ShowWindow(focus_window, SW_RESTORE);
+        SetForegroundWindow(focus_window);
+        flush_events();
+
+        /* Releasing a device in lost state breaks follow-up tests on native. */
+        hr = reset_device(device, &device_desc);
+        ok(SUCCEEDED(hr), "Failed to reset device, hr %#x, i=%u.\n", hr, i);
 
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n", (LONG_PTR)test_proc);
+        filter_messages = focus_window;
 
-    ref = IDirect3DDevice9_Release(device);
-    ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+        ref = IDirect3DDevice9_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u, i=%u.\n", ref, i);
 
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)test_proc, proc);
+        /* Fix up the mode until Wine's device release behavior is fixed. */
+        change_ret = ChangeDisplaySettingsW(NULL, CDS_FULLSCREEN);
+        ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    device_desc.device_window = focus_window;
-    if (!(device = create_device(d3d9, focus_window, &device_desc)))
-    {
-        skip("Failed to create a D3D device, skipping tests.\n");
-        goto done;
-    }
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)test_proc, "Expected wndproc %#lx, got %#lx, i=%u.\n",
+                (LONG_PTR)test_proc, proc, i);
 
-    ref = IDirect3DDevice9_Release(device);
-    ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+        device_desc.device_window = focus_window;
+        if (!(device = create_device(d3d9, focus_window, &device_desc)))
+        {
+            skip("Failed to create a D3D device, skipping tests.\n");
+            goto done;
+        }
 
-    device_desc.device_window = device_window;
-    if (!(device = create_device(d3d9, focus_window, &device_desc)))
-    {
-        skip("Failed to create a D3D device, skipping tests.\n");
-        goto done;
-    }
+        ref = IDirect3DDevice9_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u, i=%u.\n", ref, i);
 
-    proc = SetWindowLongPtrA(focus_window, GWLP_WNDPROC, (LONG_PTR)DefWindowProcA);
-    ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx.\n", (LONG_PTR)test_proc);
+        device_desc.device_window = device_window;
+        if (!(device = create_device(d3d9, focus_window, &device_desc)))
+        {
+            skip("Failed to create a D3D device, skipping tests.\n");
+            goto done;
+        }
 
-    ref = IDirect3DDevice9_Release(device);
-    ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
+        proc = SetWindowLongPtrA(focus_window, GWLP_WNDPROC, (LONG_PTR)DefWindowProcA);
+        ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx, i=%u.\n",
+                (LONG_PTR)test_proc, i);
 
-    proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
-    ok(proc == (LONG_PTR)DefWindowProcA, "Expected wndproc %#lx, got %#lx.\n",
-            (LONG_PTR)DefWindowProcA, proc);
+        ref = IDirect3DDevice9_Release(device);
+        ok(ref == 0, "The device was not properly freed: refcount %u, i=%u.\n", ref, i);
+
+        proc = GetWindowLongPtrA(focus_window, GWLP_WNDPROC);
+        ok(proc == (LONG_PTR)DefWindowProcA, "Expected wndproc %#lx, got %#lx, i=%u.\n",
+                (LONG_PTR)DefWindowProcA, proc, i);
 
 done:
-    filter_messages = NULL;
-    IDirect3D9_Release(d3d9);
+        filter_messages = NULL;
+        DestroyWindow(device_window);
+        DestroyWindow(focus_window);
+        SetEvent(thread_params.test_finished);
+        WaitForSingleObject(thread, INFINITE);
+        CloseHandle(thread);
+    }
 
-    SetEvent(thread_params.test_finished);
-    WaitForSingleObject(thread, INFINITE);
+    IDirect3D9_Release(d3d9);
     CloseHandle(thread_params.test_finished);
     CloseHandle(thread_params.window_created);
-    CloseHandle(thread);
-
-    DestroyWindow(device_window);
-    DestroyWindow(focus_window);
     UnregisterClassA("d3d9_test_wndproc_wc", GetModuleHandleA(NULL));
 }
 
@@ -3540,8 +3847,10 @@ static void test_reset_fullscreen(void)
     struct device_desc device_desc;
     static const struct message messages[] =
     {
-        {WM_ACTIVATEAPP,    FOCUS_WINDOW},
-        {0,                     0},
+        /* Windows usually sends wparam = TRUE, except on the testbot,
+         * where it randomly sends FALSE. Ignore it. */
+        {WM_ACTIVATEAPP,    FOCUS_WINDOW,   FALSE,  0},
+        {0,                 0,              FALSE,  0},
     };
 
     d3d = Direct3DCreate9(D3D_SDK_VERSION);
@@ -3690,15 +3999,16 @@ static void test_window_style(void)
     IDirect3D9 *d3d9;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
     static const struct
     {
         DWORD device_flags;
-        LONG style, exstyle;
+        LONG style, focus_loss_style, exstyle;
     }
     tests[] =
     {
-        {0,                               WS_VISIBLE, WS_EX_TOPMOST},
-        {CREATE_DEVICE_NOWINDOWCHANGES,   0},
+        {0,                                 WS_VISIBLE, WS_MINIMIZE,    WS_EX_TOPMOST},
+        {CREATE_DEVICE_NOWINDOWCHANGES,     0,          0,              0},
     };
     unsigned int i;
 
@@ -3793,6 +4103,39 @@ static void test_window_style(void)
         ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x, i=%u.\n",
                 focus_exstyle, style, i);
 
+        device_desc.flags = CREATE_DEVICE_FULLSCREEN;
+        hr = reset_device(device, &device_desc);
+        ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+        ret = SetForegroundWindow(GetDesktopWindow());
+        ok(ret, "Failed to set foreground window.\n");
+
+        style = GetWindowLongA(device_window, GWL_STYLE);
+        expected_style = device_style | tests[i].focus_loss_style | tests[i].style;
+        todo_wine ok(style == expected_style, "Expected device window style %#x, got %#x.\n",
+                expected_style, style);
+        style = GetWindowLongA(device_window, GWL_EXSTYLE);
+        expected_style = device_exstyle | tests[i].exstyle;
+        todo_wine ok(style == expected_style, "Expected device window extended style %#x, got %#x.\n",
+                expected_style, style);
+
+        style = GetWindowLongA(focus_window, GWL_STYLE);
+        ok(style == focus_style, "Expected focus window style %#x, got %#x.\n",
+                focus_style, style);
+        style = GetWindowLongA(focus_window, GWL_EXSTYLE);
+        ok(style == focus_exstyle, "Expected focus window extended style %#x, got %#x.\n",
+                focus_exstyle, style);
+
+        /* In d3d8 follow-up tests fail on native if the device is destroyed while
+         * lost. This doesn't happen in d3d9 on my test machine but it still seems
+         * like a good idea to reset it first. */
+        ShowWindow(focus_window, SW_MINIMIZE);
+        ShowWindow(focus_window, SW_RESTORE);
+        ret = SetForegroundWindow(focus_window);
+        ok(ret, "Failed to set foreground window.\n");
+        flush_events();
+        hr = reset_device(device, &device_desc);
+        ok(SUCCEEDED(hr), "Failed to reset device, hr %#x.\n", hr);
+
         ref = IDirect3DDevice9_Release(device);
         ok(ref == 0, "The device was not properly freed: refcount %u.\n", ref);
 
diff --git a/dlls/d3d9/tests/visual.c b/dlls/d3d9/tests/visual.c
index 8cc4157..c3e4d6f 100644
--- a/dlls/d3d9/tests/visual.c
+++ b/dlls/d3d9/tests/visual.c
@@ -7776,7 +7776,7 @@ done:
     DestroyWindow(window);
 }
 
-static void alpha_test(void)
+static void test_blend(void)
 {
     IDirect3DSurface9 *backbuffer, *offscreen;
     IDirect3DTexture9 *offscreenTexture;
@@ -16457,7 +16457,7 @@ static void add_dirty_rect_test(void)
     fill_surface(surface_managed, 0x0000ff00, D3DLOCK_NO_DIRTY_UPDATE);
     add_dirty_rect_test_draw(device);
     color = getPixelColor(device, 320, 240);
-    ok(color_match(color, 0x00ff0000, 1),
+    todo_wine ok(color_match(color, 0x00ff0000, 1),
             "Expected color 0x00ff0000, got 0x%08x.\n", color);
     hr = IDirect3DDevice9_Present(device, NULL, NULL, NULL, NULL);
     ok(SUCCEEDED(hr), "Failed to present, hr %#x.\n", hr);
@@ -17003,7 +17003,7 @@ START_TEST(visual)
     maxmip_test();
     offscreen_test();
     ds_size_test();
-    alpha_test();
+    test_blend();
     shademode_test();
     srgbtexture_test();
     release_buffer_test();
diff --git a/dlls/d3dx9_36/tests/surface.c b/dlls/d3dx9_36/tests/surface.c
index 4490dc3..5846281 100644
--- a/dlls/d3dx9_36/tests/surface.c
+++ b/dlls/d3dx9_36/tests/surface.c
@@ -30,13 +30,6 @@ static inline int get_ref(IUnknown *obj)
     return IUnknown_Release(obj);
 }
 
-#define check_ref(obj, exp) _check_ref(__LINE__, obj, exp)
-static inline void _check_ref(unsigned int line, IUnknown *obj, int exp)
-{
-    int ref = get_ref(obj);
-    ok_(__FILE__, line)(exp == ref, "Invalid refcount. Expected %d, got %d\n", exp, ref);
-}
-
 #define check_release(obj, exp) _check_release(__LINE__, obj, exp)
 static inline void _check_release(unsigned int line, IUnknown *obj, int exp)
 {
@@ -608,13 +601,6 @@ static void test_D3DXGetImageInfo(void)
     if(testbitmap_ok) DeleteFileA("testbitmap.bmp");
 }
 
-#define check_pixel_1bpp(lockrect, x, y, color) _check_pixel_1bpp(__LINE__, lockrect, x, y, color)
-static inline void _check_pixel_1bpp(unsigned int line, const D3DLOCKED_RECT *lockrect, int x, int y, BYTE expected_color)
-{
-    BYTE color = ((BYTE*)lockrect->pBits)[x + y * lockrect->Pitch];
-    ok_(__FILE__, line)(color == expected_color, "Got color 0x%02x, expected 0x%02x\n", color, expected_color);
-}
-
 #define check_pixel_2bpp(lockrect, x, y, color) _check_pixel_2bpp(__LINE__, lockrect, x, y, color)
 static inline void _check_pixel_2bpp(unsigned int line, const D3DLOCKED_RECT *lockrect, int x, int y, WORD expected_color)
 {
diff --git a/dlls/dbghelp/pe_module.c b/dlls/dbghelp/pe_module.c
index f43d971..b793edb 100644
--- a/dlls/dbghelp/pe_module.c
+++ b/dlls/dbghelp/pe_module.c
@@ -515,7 +515,7 @@ static BOOL pe_load_stabs(const struct process* pcs, struct module* module)
 static BOOL pe_load_dwarf(struct module* module)
 {
     struct image_file_map*      fmap = &module->format_info[DFI_PE]->u.pe_info->fmap;
-    BOOL                        ret = FALSE;
+    BOOL                        ret;
 
     ret = dwarf2_parse(module,
                        module->module.BaseOfImage - fmap->u.pe.ntheader.OptionalHeader.ImageBase,
diff --git a/dlls/ddraw/ddraw.c b/dlls/ddraw/ddraw.c
index 36eb679..fce1c22 100644
--- a/dlls/ddraw/ddraw.c
+++ b/dlls/ddraw/ddraw.c
@@ -28,9 +28,7 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(ddraw);
 
-static struct wined3d_display_mode original_mode;
 static const struct ddraw *exclusive_ddraw;
-static BOOL restore_mode;
 
 /* Device identifier. Don't relay it to WineD3D */
 static const DDDEVICEIDENTIFIER2 deviceidentifier =
@@ -684,11 +682,8 @@ static HRESULT WINAPI ddraw7_RestoreDisplayMode(IDirectDraw7 *iface)
         return DDERR_NOEXCLUSIVEMODE;
     }
 
-    if (SUCCEEDED(hr = wined3d_set_adapter_display_mode(ddraw->wined3d, WINED3DADAPTER_DEFAULT, &original_mode)))
-    {
+    if (SUCCEEDED(hr = wined3d_set_adapter_display_mode(ddraw->wined3d, WINED3DADAPTER_DEFAULT, NULL)))
         ddraw->flags &= ~DDRAW_RESTORE_MODE;
-        restore_mode = FALSE;
-    }
 
     wined3d_mutex_unlock();
 
@@ -1097,10 +1092,6 @@ static HRESULT WINAPI ddraw7_SetDisplayMode(IDirectDraw7 *iface, DWORD width, DW
         return DD_OK;
     }
 
-    if (!restore_mode && FAILED(hr = wined3d_get_adapter_display_mode(ddraw->wined3d,
-            WINED3DADAPTER_DEFAULT, &original_mode, NULL)))
-        ERR("Failed to get current display mode, hr %#x.\n", hr);
-
     switch (bpp)
     {
         case 8:  format = WINED3DFMT_P8_UINT;        break;
@@ -1121,10 +1112,7 @@ static HRESULT WINAPI ddraw7_SetDisplayMode(IDirectDraw7 *iface, DWORD width, DW
      * can't be changed if a surface is locked or some drawing is in progress. */
     /* TODO: Lose the primary surface. */
     if (SUCCEEDED(hr = wined3d_set_adapter_display_mode(ddraw->wined3d, WINED3DADAPTER_DEFAULT, &mode)))
-    {
         ddraw->flags |= DDRAW_RESTORE_MODE;
-        restore_mode = TRUE;
-    }
 
     wined3d_mutex_unlock();
 
@@ -4862,7 +4850,7 @@ HRESULT ddraw_init(struct ddraw *ddraw, enum wined3d_device_type device_type)
     ddraw->numIfaces = 1;
     ddraw->ref7 = 1;
 
-    flags = WINED3D_LEGACY_DEPTH_BIAS | WINED3D_VIDMEM_ACCOUNTING;
+    flags = WINED3D_LEGACY_DEPTH_BIAS | WINED3D_VIDMEM_ACCOUNTING | WINED3D_RESTORE_MODE_ON_ACTIVATE;
     if (!(ddraw->wined3d = wined3d_create(flags)))
     {
         if (!(ddraw->wined3d = wined3d_create(flags | WINED3D_NO3D)))
diff --git a/dlls/ddraw/surface.c b/dlls/ddraw/surface.c
index 556d32f..ad48bfe 100644
--- a/dlls/ddraw/surface.c
+++ b/dlls/ddraw/surface.c
@@ -6165,6 +6165,10 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
     DDSURFACEDESC2 *desc = &surface->surface_desc;
     struct wined3d_resource_desc wined3d_desc;
     unsigned int version = texture->version;
+    UINT row_pitch, slice_pitch;
+    struct wined3d_resource *resource = wined3d_surface_get_resource(wined3d_surface);
+
+    wined3d_resource_get_pitch(resource, &row_pitch, &slice_pitch);
 
     surface->IDirectDrawSurface7_iface.lpVtbl = &ddraw_surface7_vtbl;
     surface->IDirectDrawSurface4_iface.lpVtbl = &ddraw_surface4_vtbl;
@@ -6195,7 +6199,7 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
     }
 
     *desc = texture->surface_desc;
-    wined3d_resource_get_desc(wined3d_surface_get_resource(wined3d_surface), &wined3d_desc);
+    wined3d_resource_get_desc(resource, &wined3d_desc);
     desc->dwWidth = wined3d_desc.width;
     desc->dwHeight = wined3d_desc.height;
     surface->first_attached = surface;
@@ -6205,14 +6209,16 @@ void ddraw_surface_init(struct ddraw_surface *surface, struct ddraw *ddraw, stru
         if (desc->dwFlags & DDSD_LPSURFACE)
             desc->u1.dwLinearSize = ~0u;
         else
-            desc->u1.dwLinearSize = wined3d_surface_get_pitch(wined3d_surface) * ((desc->dwHeight + 3) / 4);
+        {
+            desc->u1.dwLinearSize = row_pitch * ((desc->dwHeight + 3) / 4);
+        }
         desc->dwFlags |= DDSD_LINEARSIZE;
         desc->dwFlags &= ~(DDSD_LPSURFACE | DDSD_PITCH);
     }
     else
     {
         if (!(desc->dwFlags & DDSD_LPSURFACE))
-            desc->u1.lPitch = wined3d_surface_get_pitch(wined3d_surface);
+            desc->u1.lPitch = row_pitch;
         desc->dwFlags |= DDSD_PITCH;
         desc->dwFlags &= ~(DDSD_LPSURFACE | DDSD_LINEARSIZE);
     }
diff --git a/dlls/ddraw/tests/ddraw1.c b/dlls/ddraw/tests/ddraw1.c
index 0ae204c..6ab51fa 100644
--- a/dlls/ddraw/tests/ddraw1.c
+++ b/dlls/ddraw/tests/ddraw1.c
@@ -428,12 +428,26 @@ static void destroy_material(IDirect3DMaterial *material)
     IDirect3DMaterial_Release(material);
 }
 
-static const UINT *expect_messages;
+struct message
+{
+    UINT message;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
+};
+
+static const struct message *expect_messages;
 
 static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
 {
-    if (expect_messages && message == *expect_messages)
+    if (expect_messages && message == expect_messages->message)
+    {
+        if (expect_messages->check_wparam)
+            ok (wparam == expect_messages->expect_wparam,
+                    "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                    wparam, message, expect_messages->expect_wparam);
+
         ++expect_messages;
+    }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
 }
@@ -1878,15 +1892,15 @@ static void test_wndproc(void)
     HRESULT hr;
     ULONG ref;
 
-    static const UINT messages[] =
+    static struct message messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_MOVE,
-        WM_SIZE,
-        WM_WINDOWPOSCHANGING,
-        WM_ACTIVATE,
-        WM_SETFOCUS,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_ACTIVATE,           FALSE,  0},
+        {WM_SETFOCUS,           FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     /* DDSCL_EXCLUSIVE replaces the window's window proc. */
@@ -1906,7 +1920,7 @@ static void test_wndproc(void)
     expect_messages = messages;
     hr = IDirectDraw_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     proc = GetWindowLongPtrA(window, GWLP_WNDPROC);
     ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx, got %#lx.\n",
@@ -1995,12 +2009,13 @@ static void test_wndproc(void)
 
 static void test_window_style(void)
 {
-    LONG style, exstyle, tmp;
+    LONG style, exstyle, tmp, expected_style;
     RECT fullscreen_rect, r;
     IDirectDraw *ddraw;
     HWND window;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
 
     window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW,
             0, 0, 100, 100, 0, 0, 0, 0);
@@ -2026,6 +2041,20 @@ static void test_window_style(void)
     GetClientRect(window, &r);
     todo_wine ok(!EqualRect(&r, &fullscreen_rect), "Client rect and window rect are equal.\n");
 
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    todo_wine ok(tmp == style, "Expected window style %#x, got %#x.\n", style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
+
+    ret = SetForegroundWindow(window);
+    ok(ret, "Failed to set foreground window.\n");
+    /* Windows 7 (but not Vista and XP) show the window when it receives focus. Hide it again,
+     * the next tests expect this. */
+    ShowWindow(window, SW_HIDE);
+
     hr = IDirectDraw_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
@@ -2034,6 +2063,26 @@ static void test_window_style(void)
     tmp = GetWindowLongA(window, GWL_EXSTYLE);
     todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
 
+    ShowWindow(window, SW_SHOW);
+    hr = IDirectDraw_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE | WS_MINIMIZE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
     ref = IDirectDraw_Release(ddraw);
     ok(ref == 0, "The ddraw object was not properly freed: refcount %u.\n", ref);
 
@@ -2147,19 +2196,48 @@ static void test_coop_level_mode_set(void)
     BOOL ret;
     LONG change_ret;
 
-    static const UINT exclusive_messages[] =
+    static const struct message exclusive_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_loss_messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_WINDOWPOSCHANGED,
-        WM_SIZE,
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_ACTIVATE,           TRUE,   WA_INACTIVE},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        /* Like d3d8 and d3d9 ddraw seems to use SW_SHOWMINIMIZED instead of
+         * SW_MINIMIZED, causing a recursive window activation that does not
+         * produe the same result in Wine yet. Ignore the difference for now.
+         * {WM_ACTIVATE,           TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        TRUE,   FALSE},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_restore_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* From the ShowWindow(SW_RESTORE). */
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* Generated by ddraw, matches d3d9 behavior. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching previous message. */
+        {WM_SIZE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_DISPLAYCHANGE,      FALSE,  0}, /* Ddraw restores mode. */
+        /* Native redundantly sets the window size here. */
+        {WM_ACTIVATEAPP,        TRUE,   TRUE}, /* End of ddraw's hooks. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching the one from ShowWindow. */
+        {WM_MOVE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_SIZE,               TRUE,   SIZE_RESTORED}, /* DefWindowProc. */
+        {0,                     FALSE,  0},
     };
 
-    static const UINT normal_messages[] =
+    static const struct message normal_messages[] =
     {
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     ddraw = create_ddraw();
@@ -2234,7 +2312,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.ddraw_width && screen_size.cy == param.ddraw_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2280,7 +2358,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.user32_width && screen_size.cy == param.user32_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2291,6 +2369,37 @@ static void test_coop_level_mode_set(void)
             user32_rect.left, user32_rect.top, user32_rect.right, user32_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
+    expect_messages = exclusive_focus_loss_messages;
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+            && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    expect_messages = exclusive_focus_restore_messages;
+    ShowWindow(window, SW_RESTORE);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+
+    GetWindowRect(window, &r);
+    ok(EqualRect(&r, &ddraw_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+            ddraw_rect.left, ddraw_rect.top, ddraw_rect.right, ddraw_rect.bottom,
+            r.left, r.top, r.right, r.bottom);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == param.ddraw_width
+            && devmode.dmPelsHeight == param.ddraw_height, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    hr = IDirectDraw_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+    /* Normally the primary should be restored here. Unfortunately this causes the
+     * GetSurfaceDesc call after the next display mode change to crash on the Windows 8
+     * testbot. Another Restore call would presumably avoid the crash, but it also moots
+     * the point of the GetSurfaceDesc call. */
+
     PeekMessageA(&msg, 0, 0, 0, PM_NOREMOVE);
     expect_messages = exclusive_messages;
     screen_size.cx = 0;
@@ -2299,15 +2408,15 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    todo_wine ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
-    todo_wine ok(screen_size.cx == registry_mode.dmPelsWidth
+    ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
             "Expected screen size %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight, screen_size.cx, screen_size.cy);
 
     GetWindowRect(window, &r);
-    todo_wine ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+    ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
             registry_rect.left, registry_rect.top, registry_rect.right, registry_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
@@ -2382,10 +2491,13 @@ static void test_coop_level_mode_set(void)
     screen_size.cx = 0;
     screen_size.cy = 0;
 
+    devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+    devmode.dmPelsWidth = param.user32_width;
+    devmode.dmPelsHeight = param.user32_height;
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2409,7 +2521,7 @@ static void test_coop_level_mode_set(void)
     }
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2453,7 +2565,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2472,7 +2584,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -2548,7 +2660,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2565,7 +2677,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2609,7 +2721,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2628,7 +2740,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
diff --git a/dlls/ddraw/tests/ddraw2.c b/dlls/ddraw/tests/ddraw2.c
index 334d89e..b79aed6 100644
--- a/dlls/ddraw/tests/ddraw2.c
+++ b/dlls/ddraw/tests/ddraw2.c
@@ -361,12 +361,26 @@ static void destroy_material(IDirect3DMaterial2 *material)
     IDirect3DMaterial2_Release(material);
 }
 
-static const UINT *expect_messages;
+struct message
+{
+    UINT message;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
+};
+
+static const struct message *expect_messages;
 
 static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
 {
-    if (expect_messages && message == *expect_messages)
+    if (expect_messages && message == expect_messages->message)
+    {
+        if (expect_messages->check_wparam)
+            ok (wparam == expect_messages->expect_wparam,
+                    "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                    wparam, message, expect_messages->expect_wparam);
+
         ++expect_messages;
+    }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
 }
@@ -2066,15 +2080,15 @@ static void test_wndproc(void)
     HRESULT hr;
     ULONG ref;
 
-    static const UINT messages[] =
+    static struct message messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_MOVE,
-        WM_SIZE,
-        WM_WINDOWPOSCHANGING,
-        WM_ACTIVATE,
-        WM_SETFOCUS,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_ACTIVATE,           FALSE,  0},
+        {WM_SETFOCUS,           FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     /* DDSCL_EXCLUSIVE replaces the window's window proc. */
@@ -2094,7 +2108,7 @@ static void test_wndproc(void)
     expect_messages = messages;
     hr = IDirectDraw2_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     proc = GetWindowLongPtrA(window, GWLP_WNDPROC);
     ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx, got %#lx.\n",
@@ -2183,12 +2197,13 @@ static void test_wndproc(void)
 
 static void test_window_style(void)
 {
-    LONG style, exstyle, tmp;
+    LONG style, exstyle, tmp, expected_style;
     RECT fullscreen_rect, r;
     IDirectDraw2 *ddraw;
     HWND window;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
 
     window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW,
             0, 0, 100, 100, 0, 0, 0, 0);
@@ -2214,6 +2229,20 @@ static void test_window_style(void)
     GetClientRect(window, &r);
     todo_wine ok(!EqualRect(&r, &fullscreen_rect), "Client rect and window rect are equal.\n");
 
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    todo_wine ok(tmp == style, "Expected window style %#x, got %#x.\n", style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
+
+    ret = SetForegroundWindow(window);
+    ok(ret, "Failed to set foreground window.\n");
+    /* Windows 7 (but not Vista and XP) show the window when it receives focus. Hide it again,
+     * the next tests expect this. */
+    ShowWindow(window, SW_HIDE);
+
     hr = IDirectDraw2_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
@@ -2222,6 +2251,26 @@ static void test_window_style(void)
     tmp = GetWindowLongA(window, GWL_EXSTYLE);
     todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
 
+    ShowWindow(window, SW_SHOW);
+    hr = IDirectDraw2_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE | WS_MINIMIZE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
     ref = IDirectDraw2_Release(ddraw);
     ok(ref == 0, "The ddraw object was not properly freed: refcount %u.\n", ref);
 
@@ -2346,19 +2395,48 @@ static void test_coop_level_mode_set(void)
     BOOL ret;
     LONG change_ret;
 
-    static const UINT exclusive_messages[] =
+    static const struct message exclusive_messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_WINDOWPOSCHANGED,
-        WM_SIZE,
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_loss_messages[] =
+    {
+        {WM_ACTIVATE,           TRUE,   WA_INACTIVE},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        /* Like d3d8 and d3d9 ddraw seems to use SW_SHOWMINIMIZED instead of
+         * SW_MINIMIZED, causing a recursive window activation that does not
+         * produe the same result in Wine yet. Ignore the difference for now.
+         * {WM_ACTIVATE,           TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        TRUE,   FALSE},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_restore_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* From the ShowWindow(SW_RESTORE). */
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* Generated by ddraw, matches d3d9 behavior. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching previous message. */
+        {WM_SIZE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_DISPLAYCHANGE,      FALSE,  0}, /* Ddraw restores mode. */
+        /* Native redundantly sets the window size here. */
+        {WM_ACTIVATEAPP,        TRUE,   TRUE}, /* End of ddraw's hooks. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching the one from ShowWindow. */
+        {WM_MOVE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_SIZE,               TRUE,   SIZE_RESTORED}, /* DefWindowProc. */
+        {0,                     FALSE,  0},
     };
 
-    static const UINT normal_messages[] =
+    static const struct message normal_messages[] =
     {
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     ddraw = create_ddraw();
@@ -2438,7 +2516,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.ddraw_width && screen_size.cy == param.ddraw_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2484,7 +2562,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.user32_width && screen_size.cy == param.user32_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2495,6 +2573,39 @@ static void test_coop_level_mode_set(void)
             user32_rect.left, user32_rect.top, user32_rect.right, user32_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
+    expect_messages = exclusive_focus_loss_messages;
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+    memset(&devmode, 0, sizeof(devmode));
+    devmode.dmSize = sizeof(devmode);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+            && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    expect_messages = exclusive_focus_restore_messages;
+    ShowWindow(window, SW_RESTORE);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+
+    GetWindowRect(window, &r);
+    ok(EqualRect(&r, &ddraw_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+            ddraw_rect.left, ddraw_rect.top, ddraw_rect.right, ddraw_rect.bottom,
+            r.left, r.top, r.right, r.bottom);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == param.ddraw_width
+            && devmode.dmPelsHeight == param.ddraw_height, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    hr = IDirectDraw2_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+    /* Normally the primary should be restored here. Unfortunately this causes the
+     * GetSurfaceDesc call after the next display mode change to crash on the Windows 8
+     * testbot. Another Restore call would presumably avoid the crash, but it also moots
+     * the point of the GetSurfaceDesc call. */
+
     PeekMessageA(&msg, 0, 0, 0, PM_NOREMOVE);
     expect_messages = exclusive_messages;
     screen_size.cx = 0;
@@ -2503,15 +2614,15 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw2_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    todo_wine ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
-    todo_wine ok(screen_size.cx == registry_mode.dmPelsWidth
+    ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
             "Expected screen size %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight, screen_size.cx, screen_size.cy);
 
     GetWindowRect(window, &r);
-    todo_wine ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+    ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
             registry_rect.left, registry_rect.top, registry_rect.right, registry_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
@@ -2586,10 +2697,13 @@ static void test_coop_level_mode_set(void)
     screen_size.cx = 0;
     screen_size.cy = 0;
 
+    devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+    devmode.dmPelsWidth = param.user32_width;
+    devmode.dmPelsHeight = param.user32_height;
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2613,7 +2727,7 @@ static void test_coop_level_mode_set(void)
     }
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2657,7 +2771,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2676,7 +2790,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -2752,7 +2866,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2769,7 +2883,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2813,7 +2927,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw2_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2832,7 +2946,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -2874,7 +2988,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw2_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
@@ -2945,7 +3059,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw2_SetCooperativeLevel(ddraw, window2, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n",
             screen_size.cx, screen_size.cy);
diff --git a/dlls/ddraw/tests/ddraw4.c b/dlls/ddraw/tests/ddraw4.c
index ab03f39..fb20d70 100644
--- a/dlls/ddraw/tests/ddraw4.c
+++ b/dlls/ddraw/tests/ddraw4.c
@@ -391,12 +391,26 @@ static void destroy_material(IDirect3DMaterial3 *material)
     IDirect3DMaterial3_Release(material);
 }
 
-static const UINT *expect_messages;
+struct message
+{
+    UINT message;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
+};
+
+static const struct message *expect_messages;
 
 static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
 {
-    if (expect_messages && message == *expect_messages)
+    if (expect_messages && message == expect_messages->message)
+    {
+        if (expect_messages->check_wparam)
+            ok (wparam == expect_messages->expect_wparam,
+                    "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                    wparam, message, expect_messages->expect_wparam);
+
         ++expect_messages;
+    }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
 }
@@ -2253,15 +2267,15 @@ static void test_wndproc(void)
     HRESULT hr;
     ULONG ref;
 
-    static const UINT messages[] =
+    static struct message messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_MOVE,
-        WM_SIZE,
-        WM_WINDOWPOSCHANGING,
-        WM_ACTIVATE,
-        WM_SETFOCUS,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_ACTIVATE,           FALSE,  0},
+        {WM_SETFOCUS,           FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     /* DDSCL_EXCLUSIVE replaces the window's window proc. */
@@ -2281,7 +2295,7 @@ static void test_wndproc(void)
     expect_messages = messages;
     hr = IDirectDraw4_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     proc = GetWindowLongPtrA(window, GWLP_WNDPROC);
     ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx, got %#lx.\n",
@@ -2370,12 +2384,13 @@ static void test_wndproc(void)
 
 static void test_window_style(void)
 {
-    LONG style, exstyle, tmp;
+    LONG style, exstyle, tmp, expected_style;
     RECT fullscreen_rect, r;
     IDirectDraw4 *ddraw;
     HWND window;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
 
     window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW,
             0, 0, 100, 100, 0, 0, 0, 0);
@@ -2401,6 +2416,20 @@ static void test_window_style(void)
     GetClientRect(window, &r);
     todo_wine ok(!EqualRect(&r, &fullscreen_rect), "Client rect and window rect are equal.\n");
 
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    todo_wine ok(tmp == style, "Expected window style %#x, got %#x.\n", style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
+
+    ret = SetForegroundWindow(window);
+    ok(ret, "Failed to set foreground window.\n");
+    /* Windows 7 (but not Vista and XP) show the window when it receives focus. Hide it again,
+     * the next tests expect this. */
+    ShowWindow(window, SW_HIDE);
+
     hr = IDirectDraw4_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
@@ -2409,6 +2438,26 @@ static void test_window_style(void)
     tmp = GetWindowLongA(window, GWL_EXSTYLE);
     todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
 
+    ShowWindow(window, SW_SHOW);
+    hr = IDirectDraw4_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE | WS_MINIMIZE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
     ref = IDirectDraw4_Release(ddraw);
     ok(ref == 0, "The ddraw object was not properly freed: refcount %u.\n", ref);
 
@@ -2497,7 +2546,7 @@ static HRESULT CALLBACK test_coop_level_mode_set_enum_cb(DDSURFACEDESC2 *surface
 {
     struct test_coop_level_mode_set_enum_param *param = context;
 
-    if (U1(U4(surface_desc)->ddpfPixelFormat).dwRGBBitCount != registry_mode.dmBitsPerPel)
+    if (U1(U4(*surface_desc).ddpfPixelFormat).dwRGBBitCount != registry_mode.dmBitsPerPel)
         return DDENUMRET_OK;
     if (surface_desc->dwWidth == registry_mode.dmPelsWidth
             && surface_desc->dwHeight == registry_mode.dmPelsHeight)
@@ -2533,19 +2582,48 @@ static void test_coop_level_mode_set(void)
     BOOL ret;
     LONG change_ret;
 
-    static const UINT exclusive_messages[] =
+    static const struct message exclusive_messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_WINDOWPOSCHANGED,
-        WM_SIZE,
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_loss_messages[] =
+    {
+        {WM_ACTIVATE,           TRUE,   WA_INACTIVE},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        /* Like d3d8 and d3d9 ddraw seems to use SW_SHOWMINIMIZED instead of
+         * SW_MINIMIZED, causing a recursive window activation that does not
+         * produe the same result in Wine yet. Ignore the difference for now.
+         * {WM_ACTIVATE,           TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        TRUE,   FALSE},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_restore_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* From the ShowWindow(SW_RESTORE). */
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* Generated by ddraw, matches d3d9 behavior. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching previous message. */
+        {WM_SIZE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_DISPLAYCHANGE,      FALSE,  0}, /* Ddraw restores mode. */
+        /* Native redundantly sets the window size here. */
+        {WM_ACTIVATEAPP,        TRUE,   TRUE}, /* End of ddraw's hooks. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching the one from ShowWindow. */
+        {WM_MOVE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_SIZE,               TRUE,   SIZE_RESTORED}, /* DefWindowProc. */
+        {0,                     FALSE,  0},
     };
 
-    static const UINT normal_messages[] =
+    static const struct message normal_messages[] =
     {
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     ddraw = create_ddraw();
@@ -2625,7 +2703,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.ddraw_width && screen_size.cy == param.ddraw_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2671,7 +2749,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.user32_width && screen_size.cy == param.user32_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2682,6 +2760,39 @@ static void test_coop_level_mode_set(void)
             user32_rect.left, user32_rect.top, user32_rect.right, user32_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
+    expect_messages = exclusive_focus_loss_messages;
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+    memset(&devmode, 0, sizeof(devmode));
+    devmode.dmSize = sizeof(devmode);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+            && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    expect_messages = exclusive_focus_restore_messages;
+    ShowWindow(window, SW_RESTORE);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+
+    GetWindowRect(window, &r);
+    ok(EqualRect(&r, &ddraw_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+            ddraw_rect.left, ddraw_rect.top, ddraw_rect.right, ddraw_rect.bottom,
+            r.left, r.top, r.right, r.bottom);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == param.ddraw_width
+            && devmode.dmPelsHeight == param.ddraw_height, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    hr = IDirectDraw4_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+    /* Normally the primary should be restored here. Unfortunately this causes the
+     * GetSurfaceDesc call after the next display mode change to crash on the Windows 8
+     * testbot. Another Restore call would presumably avoid the crash, but it also moots
+     * the point of the GetSurfaceDesc call. */
+
     PeekMessageA(&msg, 0, 0, 0, PM_NOREMOVE);
     expect_messages = exclusive_messages;
     screen_size.cx = 0;
@@ -2690,15 +2801,15 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw4_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    todo_wine ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
-    todo_wine ok(screen_size.cx == registry_mode.dmPelsWidth
+    ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
             "Expected screen size %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight, screen_size.cx, screen_size.cy);
 
     GetWindowRect(window, &r);
-    todo_wine ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+    ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
             registry_rect.left, registry_rect.top, registry_rect.right, registry_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
@@ -2773,10 +2884,13 @@ static void test_coop_level_mode_set(void)
     screen_size.cx = 0;
     screen_size.cy = 0;
 
+    devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+    devmode.dmPelsWidth = param.user32_width;
+    devmode.dmPelsHeight = param.user32_height;
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2793,7 +2907,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2837,7 +2951,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw4_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2856,7 +2970,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -2932,7 +3046,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2949,7 +3063,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2993,7 +3107,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw4_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -3012,7 +3126,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -3054,7 +3168,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw4_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
@@ -3125,7 +3239,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw4_SetCooperativeLevel(ddraw, window2, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n",
             screen_size.cx, screen_size.cy);
diff --git a/dlls/ddraw/tests/ddraw7.c b/dlls/ddraw/tests/ddraw7.c
index f505c65..9263e1e 100644
--- a/dlls/ddraw/tests/ddraw7.c
+++ b/dlls/ddraw/tests/ddraw7.c
@@ -324,12 +324,26 @@ static IDirect3DDevice7 *create_device(HWND window, DWORD coop_level)
     return device;
 }
 
-static const UINT *expect_messages;
+struct message
+{
+    UINT message;
+    BOOL check_wparam;
+    WPARAM expect_wparam;
+};
+
+static const struct message *expect_messages;
 
 static LRESULT CALLBACK test_proc(HWND hwnd, UINT message, WPARAM wparam, LPARAM lparam)
 {
-    if (expect_messages && message == *expect_messages)
+    if (expect_messages && message == expect_messages->message)
+    {
+        if (expect_messages->check_wparam)
+            ok (wparam == expect_messages->expect_wparam,
+                    "Got unexpected wparam %lx for message %x, expected %lx.\n",
+                    wparam, message, expect_messages->expect_wparam);
+
         ++expect_messages;
+    }
 
     return DefWindowProcA(hwnd, message, wparam, lparam);
 }
@@ -1931,15 +1945,15 @@ static void test_wndproc(void)
     HRESULT hr;
     ULONG ref;
 
-    static const UINT messages[] =
+    static struct message messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_MOVE,
-        WM_SIZE,
-        WM_WINDOWPOSCHANGING,
-        WM_ACTIVATE,
-        WM_SETFOCUS,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_ACTIVATE,           FALSE,  0},
+        {WM_SETFOCUS,           FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     /* DDSCL_EXCLUSIVE replaces the window's window proc. */
@@ -1959,7 +1973,7 @@ static void test_wndproc(void)
     expect_messages = messages;
     hr = IDirectDraw7_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     proc = GetWindowLongPtrA(window, GWLP_WNDPROC);
     ok(proc != (LONG_PTR)test_proc, "Expected wndproc != %#lx, got %#lx.\n",
@@ -2048,12 +2062,13 @@ static void test_wndproc(void)
 
 static void test_window_style(void)
 {
-    LONG style, exstyle, tmp;
+    LONG style, exstyle, tmp, expected_style;
     RECT fullscreen_rect, r;
     IDirectDraw7 *ddraw;
     HWND window;
     HRESULT hr;
     ULONG ref;
+    BOOL ret;
 
     window = CreateWindowA("static", "ddraw_test", WS_OVERLAPPEDWINDOW,
             0, 0, 100, 100, 0, 0, 0, 0);
@@ -2079,6 +2094,20 @@ static void test_window_style(void)
     GetClientRect(window, &r);
     todo_wine ok(!EqualRect(&r, &fullscreen_rect), "Client rect and window rect are equal.\n");
 
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    todo_wine ok(tmp == style, "Expected window style %#x, got %#x.\n", style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
+
+    ret = SetForegroundWindow(window);
+    ok(ret, "Failed to set foreground window.\n");
+    /* Windows 7 (but not Vista and XP) show the window when it receives focus. Hide it again,
+     * the next tests expect this. */
+    ShowWindow(window, SW_HIDE);
+
     hr = IDirectDraw7_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
@@ -2087,6 +2116,26 @@ static void test_window_style(void)
     tmp = GetWindowLongA(window, GWL_EXSTYLE);
     todo_wine ok(tmp == exstyle, "Expected window extended style %#x, got %#x.\n", exstyle, tmp);
 
+    ShowWindow(window, SW_SHOW);
+    hr = IDirectDraw7_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    tmp = GetWindowLongA(window, GWL_STYLE);
+    expected_style = style | WS_VISIBLE | WS_MINIMIZE;
+    todo_wine ok(tmp == expected_style, "Expected window style %#x, got %#x.\n", expected_style, tmp);
+    tmp = GetWindowLongA(window, GWL_EXSTYLE);
+    expected_style = exstyle | WS_EX_TOPMOST;
+    todo_wine ok(tmp == expected_style, "Expected window extended style %#x, got %#x.\n", expected_style, tmp);
+
     ref = IDirectDraw7_Release(ddraw);
     ok(ref == 0, "The ddraw object was not properly freed: refcount %u.\n", ref);
 
@@ -2174,7 +2223,7 @@ static HRESULT CALLBACK test_coop_level_mode_set_enum_cb(DDSURFACEDESC2 *surface
 {
     struct test_coop_level_mode_set_enum_param *param = context;
 
-    if (U1(U4(surface_desc)->ddpfPixelFormat).dwRGBBitCount != registry_mode.dmBitsPerPel)
+    if (U1(U4(*surface_desc).ddpfPixelFormat).dwRGBBitCount != registry_mode.dmBitsPerPel)
         return DDENUMRET_OK;
     if (surface_desc->dwWidth == registry_mode.dmPelsWidth
             && surface_desc->dwHeight == registry_mode.dmPelsHeight)
@@ -2210,19 +2259,48 @@ static void test_coop_level_mode_set(void)
     BOOL ret;
     LONG change_ret;
 
-    static const UINT exclusive_messages[] =
+    static const struct message exclusive_messages[] =
     {
-        WM_WINDOWPOSCHANGING,
-        WM_WINDOWPOSCHANGED,
-        WM_SIZE,
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_SIZE,               FALSE,  0},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_loss_messages[] =
+    {
+        {WM_ACTIVATE,           TRUE,   WA_INACTIVE},
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {WM_WINDOWPOSCHANGING,  FALSE,  0},
+        /* Like d3d8 and d3d9 ddraw seems to use SW_SHOWMINIMIZED instead of
+         * SW_MINIMIZED, causing a recursive window activation that does not
+         * produe the same result in Wine yet. Ignore the difference for now.
+         * {WM_ACTIVATE,           TRUE,   0x200000 | WA_ACTIVE}, */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0},
+        {WM_MOVE,               FALSE,  0},
+        {WM_SIZE,               TRUE,   SIZE_MINIMIZED},
+        {WM_ACTIVATEAPP,        TRUE,   FALSE},
+        {0,                     FALSE,  0},
+    };
+    static const struct message exclusive_focus_restore_messages[] =
+    {
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* From the ShowWindow(SW_RESTORE). */
+        {WM_WINDOWPOSCHANGING,  FALSE,  0}, /* Generated by ddraw, matches d3d9 behavior. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching previous message. */
+        {WM_SIZE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_DISPLAYCHANGE,      FALSE,  0}, /* Ddraw restores mode. */
+        /* Native redundantly sets the window size here. */
+        {WM_ACTIVATEAPP,        TRUE,   TRUE}, /* End of ddraw's hooks. */
+        {WM_WINDOWPOSCHANGED,   FALSE,  0}, /* Matching the one from ShowWindow. */
+        {WM_MOVE,               FALSE,  0}, /* DefWindowProc. */
+        {WM_SIZE,               TRUE,   SIZE_RESTORED}, /* DefWindowProc. */
+        {0,                     FALSE,  0},
     };
 
-    static const UINT normal_messages[] =
+    static const struct message normal_messages[] =
     {
-        WM_DISPLAYCHANGE,
-        0,
+        {WM_DISPLAYCHANGE,      FALSE,  0},
+        {0,                     FALSE,  0},
     };
 
     ddraw = create_ddraw();
@@ -2302,7 +2380,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.ddraw_width && screen_size.cy == param.ddraw_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2348,7 +2426,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == param.user32_width && screen_size.cy == param.user32_height,
             "Expected screen size %ux%u, got %ux%u.\n",
@@ -2359,6 +2437,39 @@ static void test_coop_level_mode_set(void)
             user32_rect.left, user32_rect.top, user32_rect.right, user32_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
+    expect_messages = exclusive_focus_loss_messages;
+    ret = SetForegroundWindow(GetDesktopWindow());
+    ok(ret, "Failed to set foreground window.\n");
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+    memset(&devmode, 0, sizeof(devmode));
+    devmode.dmSize = sizeof(devmode);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+            && devmode.dmPelsHeight == registry_mode.dmPelsHeight, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    expect_messages = exclusive_focus_restore_messages;
+    ShowWindow(window, SW_RESTORE);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
+
+    GetWindowRect(window, &r);
+    ok(EqualRect(&r, &ddraw_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+            ddraw_rect.left, ddraw_rect.top, ddraw_rect.right, ddraw_rect.bottom,
+            r.left, r.top, r.right, r.bottom);
+    ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
+    ok(ret, "Failed to get display mode.\n");
+    ok(devmode.dmPelsWidth == param.ddraw_width
+            && devmode.dmPelsHeight == param.ddraw_height, "Got unexpect screen size %ux%u.\n",
+            devmode.dmPelsWidth, devmode.dmPelsHeight);
+
+    hr = IDirectDraw7_SetCooperativeLevel(ddraw, window, DDSCL_EXCLUSIVE | DDSCL_FULLSCREEN);
+    ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
+    /* Normally the primary should be restored here. Unfortunately this causes the
+     * GetSurfaceDesc call after the next display mode change to crash on the Windows 8
+     * testbot. Another Restore call would presumably avoid the crash, but it also moots
+     * the point of the GetSurfaceDesc call. */
+
     PeekMessageA(&msg, 0, 0, 0, PM_NOREMOVE);
     expect_messages = exclusive_messages;
     screen_size.cx = 0;
@@ -2367,15 +2478,15 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw7_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    todo_wine ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
-    todo_wine ok(screen_size.cx == registry_mode.dmPelsWidth
+    ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
             "Expected screen size %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight, screen_size.cx, screen_size.cy);
 
     GetWindowRect(window, &r);
-    todo_wine ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
+    ok(EqualRect(&r, &registry_rect), "Expected {%d, %d, %d, %d}, got {%d, %d, %d, %d}.\n",
             registry_rect.left, registry_rect.top, registry_rect.right, registry_rect.bottom,
             r.left, r.top, r.right, r.bottom);
 
@@ -2450,10 +2561,13 @@ static void test_coop_level_mode_set(void)
     screen_size.cx = 0;
     screen_size.cy = 0;
 
+    devmode.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT;
+    devmode.dmPelsWidth = param.user32_width;
+    devmode.dmPelsHeight = param.user32_height;
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2470,7 +2584,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2514,7 +2628,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2533,7 +2647,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -2609,7 +2723,7 @@ static void test_coop_level_mode_set(void)
     change_ret = ChangeDisplaySettingsW(&devmode, CDS_FULLSCREEN);
     ok(change_ret == DISP_CHANGE_SUCCESSFUL, "Failed to change display mode, ret %#x.\n", change_ret);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2626,7 +2740,7 @@ static void test_coop_level_mode_set(void)
     hr = set_display_mode(ddraw, param.ddraw_width, param.ddraw_height);
     ok(SUCCEEDED(hr), "Failed to set display mode, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2670,7 +2784,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw7_RestoreDisplayMode(ddraw);
     ok(SUCCEEDED(hr), "RestoreDisplayMode failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n", screen_size.cx, screen_size.cy);
 
@@ -2689,7 +2803,7 @@ static void test_coop_level_mode_set(void)
 
     ret = EnumDisplaySettingsW(NULL, ENUM_CURRENT_SETTINGS, &devmode);
     ok(ret, "Failed to get display mode.\n");
-    todo_wine ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
+    ok(devmode.dmPelsWidth == registry_mode.dmPelsWidth
             && devmode.dmPelsHeight == registry_mode.dmPelsHeight,
             "Expected resolution %ux%u, got %ux%u.\n",
             registry_mode.dmPelsWidth, registry_mode.dmPelsHeight,
@@ -2731,7 +2845,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw7_SetCooperativeLevel(ddraw, window, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(screen_size.cx == registry_mode.dmPelsWidth
             && screen_size.cy == registry_mode.dmPelsHeight,
@@ -2802,7 +2916,7 @@ static void test_coop_level_mode_set(void)
     hr = IDirectDraw7_SetCooperativeLevel(ddraw, window2, DDSCL_NORMAL);
     ok(SUCCEEDED(hr), "SetCooperativeLevel failed, hr %#x.\n", hr);
 
-    ok(!*expect_messages, "Expected message %#x, but didn't receive it.\n", *expect_messages);
+    ok(!expect_messages->message, "Expected message %#x, but didn't receive it.\n", expect_messages->message);
     expect_messages = NULL;
     ok(!screen_size.cx && !screen_size.cy, "Got unexpected screen size %ux%u.\n",
             screen_size.cx, screen_size.cy);
diff --git a/dlls/ddraw/tests/visual.c b/dlls/ddraw/tests/visual.c
index 0385044..94d6984 100644
--- a/dlls/ddraw/tests/visual.c
+++ b/dlls/ddraw/tests/visual.c
@@ -929,7 +929,7 @@ out:
     }
 }
 
-static void alpha_test(IDirect3DDevice7 *device)
+static void test_blend(IDirect3DDevice7 *device)
 {
     HRESULT hr;
     IDirectDrawSurface7 *backbuffer = NULL, *offscreen = NULL;
@@ -3277,7 +3277,7 @@ START_TEST(visual)
     clear_test(Direct3DDevice);
     fog_test(Direct3DDevice);
     offscreen_test(Direct3DDevice);
-    alpha_test(Direct3DDevice);
+    test_blend(Direct3DDevice);
     rhw_zero_test(Direct3DDevice);
     cubemap_test(Direct3DDevice);
 
diff --git a/dlls/difxapi/difxapi.spec b/dlls/difxapi/difxapi.spec
index 33a805b..3e2f859 100644
--- a/dlls/difxapi/difxapi.spec
+++ b/dlls/difxapi/difxapi.spec
@@ -8,3 +8,5 @@
 @ stdcall DriverPackagePreinstallW(wstr long)
 @ stdcall DriverPackageUninstallA(str long ptr ptr)
 @ stdcall DriverPackageUninstallW(wstr long ptr ptr)
+@ stdcall SetDifxLogCallbackA(ptr ptr)
+@ stdcall SetDifxLogCallbackW(ptr ptr)
diff --git a/dlls/difxapi/main.c b/dlls/difxapi/main.c
index 8a2679c..7b7b1d6 100644
--- a/dlls/difxapi/main.c
+++ b/dlls/difxapi/main.c
@@ -86,3 +86,13 @@ VOID WINAPI DIFXAPISetLogCallbackW(DIFXAPILOGCALLBACK_W cb, VOID *ctx)
 {
     FIXME("(%p, %p) stub\n", cb, ctx);
 }
+
+VOID WINAPI SetDifxLogCallbackA(DIFXLOGCALLBACK_A cb, VOID *ctx)
+{
+    FIXME("(%p, %p) stub\n", cb, ctx);
+}
+
+VOID WINAPI SetDifxLogCallbackW(DIFXLOGCALLBACK_W cb, VOID *ctx)
+{
+    FIXME("(%p, %p) stub\n", cb, ctx);
+}
diff --git a/dlls/dinput/dinput_main.c b/dlls/dinput/dinput_main.c
index 14d5285..18840b2 100644
--- a/dlls/dinput/dinput_main.c
+++ b/dlls/dinput/dinput_main.c
@@ -79,10 +79,6 @@ static inline IDirectInputImpl *impl_from_IDirectInput8W( IDirectInput8W *iface
     return CONTAINING_RECORD( iface, IDirectInputImpl, IDirectInput8W_iface );
 }
 
-static inline IDirectInputDeviceImpl *impl_from_IDirectInputDevice8A(IDirectInputDevice8A *iface)
-{
-    return CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8A_iface);
-}
 static inline IDirectInputDeviceImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W *iface)
 {
     return CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface);
diff --git a/dlls/dinput/joystick.c b/dlls/dinput/joystick.c
index 0d61f57..edbb64e 100644
--- a/dlls/dinput/joystick.c
+++ b/dlls/dinput/joystick.c
@@ -400,16 +400,38 @@ HRESULT WINAPI JoystickAGenericImpl_SetProperty(LPDIRECTINPUTDEVICE8A iface, REF
     return JoystickWGenericImpl_SetProperty(IDirectInputDevice8W_from_impl(This), rguid, ph);
 }
 
+#define DEBUG_TYPE(x) case (x): str = #x; break
 void _dump_DIDEVCAPS(const DIDEVCAPS *lpDIDevCaps)
 {
+    int type = GET_DIDEVICE_TYPE(lpDIDevCaps->dwDevType);
+    const char *str;
     TRACE("dwSize: %d\n", lpDIDevCaps->dwSize);
     TRACE("dwFlags: %08x\n", lpDIDevCaps->dwFlags);
-    TRACE("dwDevType: %08x %s\n", lpDIDevCaps->dwDevType,
-          lpDIDevCaps->dwDevType == DIDEVTYPE_DEVICE ? "DIDEVTYPE_DEVICE" :
-          lpDIDevCaps->dwDevType == DIDEVTYPE_MOUSE ? "DIDEVTYPE_MOUSE" :
-          lpDIDevCaps->dwDevType == DIDEVTYPE_KEYBOARD ? "DIDEVTYPE_KEYBOARD" :
-          lpDIDevCaps->dwDevType == DIDEVTYPE_JOYSTICK ? "DIDEVTYPE_JOYSTICK" :
-          lpDIDevCaps->dwDevType == DIDEVTYPE_HID ? "DIDEVTYPE_HID" : "UNKNOWN");
+    switch(type)
+    {
+        /* Directx <= 7 definitions */
+        DEBUG_TYPE(DIDEVTYPE_DEVICE);
+        DEBUG_TYPE(DIDEVTYPE_MOUSE);
+        DEBUG_TYPE(DIDEVTYPE_KEYBOARD);
+        DEBUG_TYPE(DIDEVTYPE_JOYSTICK);
+        DEBUG_TYPE(DIDEVTYPE_HID);
+        /* Directx >= 8 definitions */
+        DEBUG_TYPE(DI8DEVTYPE_DEVICE);
+        DEBUG_TYPE(DI8DEVTYPE_MOUSE);
+        DEBUG_TYPE(DI8DEVTYPE_KEYBOARD);
+        DEBUG_TYPE(DI8DEVTYPE_JOYSTICK);
+        DEBUG_TYPE(DI8DEVTYPE_GAMEPAD);
+        DEBUG_TYPE(DI8DEVTYPE_DRIVING);
+        DEBUG_TYPE(DI8DEVTYPE_FLIGHT);
+        DEBUG_TYPE(DI8DEVTYPE_1STPERSON);
+        DEBUG_TYPE(DI8DEVTYPE_DEVICECTRL);
+        DEBUG_TYPE(DI8DEVTYPE_SCREENPOINTER);
+        DEBUG_TYPE(DI8DEVTYPE_REMOTE);
+        DEBUG_TYPE(DI8DEVTYPE_SUPPLEMENTAL);
+        default: str = "UNKNOWN";
+    }
+
+    TRACE("dwDevType: %08x %s\n", lpDIDevCaps->dwDevType, str);
     TRACE("dwAxes: %d\n", lpDIDevCaps->dwAxes);
     TRACE("dwButtons: %d\n", lpDIDevCaps->dwButtons);
     TRACE("dwPOVs: %d\n", lpDIDevCaps->dwPOVs);
@@ -421,6 +443,7 @@ void _dump_DIDEVCAPS(const DIDEVCAPS *lpDIDevCaps)
         TRACE("dwFFDriverVersion: %d\n", lpDIDevCaps->dwFFDriverVersion);
     }
 }
+#undef DEBUG_TYPE
 
 HRESULT WINAPI JoystickWGenericImpl_GetCapabilities(LPDIRECTINPUTDEVICE8W iface, LPDIDEVCAPS lpDIDevCaps)
 {
diff --git a/dlls/dinput/joystick_linux.c b/dlls/dinput/joystick_linux.c
index 4d40124..697dded 100644
--- a/dlls/dinput/joystick_linux.c
+++ b/dlls/dinput/joystick_linux.c
@@ -107,10 +107,7 @@ static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W
     return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
            JoystickGenericImpl, base), JoystickImpl, generic);
 }
-static inline IDirectInputDevice8A *IDirectInputDevice8A_from_impl(JoystickImpl *This)
-{
-    return &This->generic.base.IDirectInputDevice8A_iface;
-}
+
 static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickImpl *This)
 {
     return &This->generic.base.IDirectInputDevice8W_iface;
diff --git a/dlls/dinput/joystick_linuxinput.c b/dlls/dinput/joystick_linuxinput.c
index 76adabc..4b4d69c 100644
--- a/dlls/dinput/joystick_linuxinput.c
+++ b/dlls/dinput/joystick_linuxinput.c
@@ -143,10 +143,7 @@ static inline JoystickImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W
     return CONTAINING_RECORD(CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface),
            JoystickGenericImpl, base), JoystickImpl, generic);
 }
-static inline IDirectInputDevice8A *IDirectInputDevice8A_from_impl(JoystickImpl *This)
-{
-    return &This->generic.base.IDirectInputDevice8A_iface;
-}
+
 static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(JoystickImpl *This)
 {
     return &This->generic.base.IDirectInputDevice8W_iface;
diff --git a/dlls/dinput/mouse.c b/dlls/dinput/mouse.c
index 03fc0b0..132efce 100644
--- a/dlls/dinput/mouse.c
+++ b/dlls/dinput/mouse.c
@@ -85,10 +85,7 @@ static inline SysMouseImpl *impl_from_IDirectInputDevice8W(IDirectInputDevice8W
 {
     return CONTAINING_RECORD(CONTAINING_RECORD(iface, IDirectInputDeviceImpl, IDirectInputDevice8W_iface), SysMouseImpl, base);
 }
-static inline IDirectInputDevice8A *IDirectInputDevice8A_from_impl(SysMouseImpl *This)
-{
-    return &This->base.IDirectInputDevice8A_iface;
-}
+
 static inline IDirectInputDevice8W *IDirectInputDevice8W_from_impl(SysMouseImpl *This)
 {
     return &This->base.IDirectInputDevice8W_iface;
diff --git a/dlls/dwrite/Makefile.in b/dlls/dwrite/Makefile.in
index 2090883..ded14db 100644
--- a/dlls/dwrite/Makefile.in
+++ b/dlls/dwrite/Makefile.in
@@ -1,12 +1,14 @@
 MODULE    = dwrite.dll
 IMPORTLIB = dwrite
 IMPORTS   = user32 gdi32
+EXTRAINCL = $(FREETYPE_CFLAGS)
 
 C_SRCS = \
 	analyzer.c \
 	bidi.c \
 	bracket.c \
 	font.c \
+	freetype.c \
 	gdiinterop.c \
 	layout.c \
 	linebreak.c \
diff --git a/dlls/dwrite/bidi.c b/dlls/dwrite/bidi.c
index 48a7a06..69eae5a 100644
--- a/dlls/dwrite/bidi.c
+++ b/dlls/dwrite/bidi.c
@@ -513,12 +513,6 @@ static inline int get_prev_valid_char_from_run(IsolatedRun *run, int index)
     return index;
 }
 
-static inline int iso_previousChar(IsolatedRun *run, int index)
-{
-    if (index <= 0) return -1;
-    return index--;
-}
-
 static inline void iso_dump_types(const char* header, IsolatedRun *run)
 {
     int i, len = 0;
diff --git a/dlls/dwrite/dwrite_private.h b/dlls/dwrite/dwrite_private.h
index d1c42ce..c600f3e 100644
--- a/dlls/dwrite/dwrite_private.h
+++ b/dlls/dwrite/dwrite_private.h
@@ -108,6 +108,7 @@ extern HRESULT create_localfontfileloader(IDWriteLocalFontFileLoader** iface) DE
 extern HRESULT create_fontface(DWRITE_FONT_FACE_TYPE,UINT32,IDWriteFontFile* const*,UINT32,DWRITE_FONT_SIMULATIONS,IDWriteFontFace2**) DECLSPEC_HIDDEN;
 extern HRESULT create_font_collection(IDWriteFactory*,IDWriteFontFileEnumerator*,BOOL,IDWriteFontCollection**) DECLSPEC_HIDDEN;
 extern BOOL    is_system_collection(IDWriteFontCollection*) DECLSPEC_HIDDEN;
+extern HRESULT get_local_refkey(const WCHAR*,const FILETIME*,void**,UINT32*) DECLSPEC_HIDDEN;
 
 /* Opentype font table functions */
 extern HRESULT opentype_analyze_font(IDWriteFontFileStream*,UINT32*,DWRITE_FONT_FILE_TYPE*,DWRITE_FONT_FACE_TYPE*,BOOL*) DECLSPEC_HIDDEN;
@@ -118,9 +119,16 @@ extern void opentype_get_font_properties(const void*,const void*,DWRITE_FONT_STR
 extern void opentype_get_font_metrics(const void*,const void*,const void*,DWRITE_FONT_METRICS1*) DECLSPEC_HIDDEN;
 extern HRESULT opentype_get_font_strings_from_id(const void*,DWRITE_INFORMATIONAL_STRING_ID,IDWriteLocalizedStrings**) DECLSPEC_HIDDEN;
 
+/* BiDi helpers */
 extern HRESULT bidi_computelevels(const WCHAR*,UINT32,UINT8,UINT8*,UINT8*) DECLSPEC_HIDDEN;
 extern WCHAR bidi_get_mirrored_char(WCHAR) DECLSPEC_HIDDEN;
 
+/* FreeType integration */
+struct ft_fontface;
+extern BOOL init_freetype(void) DECLSPEC_HIDDEN;
+extern HRESULT alloc_ft_fontface(const void*,UINT32,UINT32,struct ft_fontface**) DECLSPEC_HIDDEN;
+extern void release_ft_fontface(struct ft_fontface*) DECLSPEC_HIDDEN;
+
 /* Glyph shaping */
 enum SCRIPT_JUSTIFY
 {
diff --git a/dlls/dwrite/font.c b/dlls/dwrite/font.c
index 8bb39fa..76f3e3e 100644
--- a/dlls/dwrite/font.c
+++ b/dlls/dwrite/font.c
@@ -21,6 +21,7 @@
 
 #define COBJMACROS
 
+#include "wine/list.h"
 #include "dwrite_private.h"
 
 WINE_DEFAULT_DEBUG_CHANNEL(dwrite);
@@ -118,6 +119,7 @@ struct dwrite_fontface {
     DWRITE_FONT_METRICS1 metrics;
 
     struct dwrite_fonttable cmap;
+    struct ft_fontface *ft;
 };
 
 struct dwrite_fontfile {
@@ -178,10 +180,8 @@ static inline void* get_fontface_cmap(struct dwrite_fontface *fontface)
 static void release_font_data(struct dwrite_font_data *data)
 {
     int i;
-    if (!data)
-        return;
-    i = InterlockedDecrement(&data->ref);
-    if (i > 0)
+
+    if (InterlockedDecrement(&data->ref) > 0)
         return;
 
     for (i = DWRITE_INFORMATIONAL_STRING_NONE; i < sizeof(data->info_strings)/sizeof(data->info_strings[0]); i++) {
@@ -195,14 +195,13 @@ static void release_font_data(struct dwrite_font_data *data)
     heap_free(data);
 }
 
-static VOID _free_fontfamily_data(struct dwrite_fontfamily_data *data)
+static void release_fontfamily_data(struct dwrite_fontfamily_data *data)
 {
     int i;
-    if (!data)
-        return;
-    i = InterlockedDecrement(&data->ref);
-    if (i > 0)
+
+    if (InterlockedDecrement(&data->ref) > 0)
         return;
+
     for (i = 0; i < data->font_count; i++)
         release_font_data(data->fonts[i]);
     heap_free(data->fonts);
@@ -256,6 +255,7 @@ static ULONG WINAPI dwritefontface_Release(IDWriteFontFace2 *iface)
             if (This->files[i])
                 IDWriteFontFile_Release(This->files[i]);
         }
+        release_ft_fontface(This->ft);
         heap_free(This);
     }
 
@@ -782,8 +782,16 @@ static DWRITE_FONT_STYLE WINAPI dwritefont_GetStyle(IDWriteFont2 *iface)
 static BOOL WINAPI dwritefont_IsSymbolFont(IDWriteFont2 *iface)
 {
     struct dwrite_font *This = impl_from_IDWriteFont2(iface);
-    FIXME("(%p): stub\n", This);
-    return FALSE;
+    IDWriteFontFace2 *fontface;
+    HRESULT hr;
+
+    TRACE("(%p)\n", This);
+
+    hr = get_fontface_from_font(This, &fontface);
+    if (FAILED(hr))
+        return hr;
+
+    return IDWriteFontFace2_IsSymbolFont(fontface);
 }
 
 static HRESULT WINAPI dwritefont_GetFaceNames(IDWriteFont2 *iface, IDWriteLocalizedStrings **names)
@@ -965,18 +973,34 @@ static HRESULT WINAPI dwritefont1_GetUnicodeRanges(IDWriteFont2 *iface, UINT32 m
     return IDWriteFontFace2_GetUnicodeRanges(fontface, max_count, ranges, count);
 }
 
-static HRESULT WINAPI dwritefont1_IsMonospacedFont(IDWriteFont2 *iface)
+static BOOL WINAPI dwritefont1_IsMonospacedFont(IDWriteFont2 *iface)
 {
     struct dwrite_font *This = impl_from_IDWriteFont2(iface);
-    FIXME("(%p): stub\n", This);
-    return FALSE;
+    IDWriteFontFace2 *fontface;
+    HRESULT hr;
+
+    TRACE("(%p)\n", This);
+
+    hr = get_fontface_from_font(This, &fontface);
+    if (FAILED(hr))
+        return hr;
+
+    return IDWriteFontFace2_IsMonospacedFont(fontface);
 }
 
 static HRESULT WINAPI dwritefont2_IsColorFont(IDWriteFont2 *iface)
 {
     struct dwrite_font *This = impl_from_IDWriteFont2(iface);
-    FIXME("(%p): stub\n", This);
-    return FALSE;
+    IDWriteFontFace2 *fontface;
+    HRESULT hr;
+
+    TRACE("(%p)\n", This);
+
+    hr = get_fontface_from_font(This, &fontface);
+    if (FAILED(hr))
+        return hr;
+
+    return IDWriteFontFace2_IsColorFont(fontface);
 }
 
 static const IDWriteFont2Vtbl dwritefontvtbl = {
@@ -1059,7 +1083,7 @@ static ULONG WINAPI dwritefontfamily_Release(IDWriteFontFamily *iface)
     if (!ref)
     {
         IDWriteFontCollection_Release(This->collection);
-        _free_fontfamily_data(This->data);
+        release_fontfamily_data(This->data);
         heap_free(This);
     }
 
@@ -1237,7 +1261,7 @@ static ULONG WINAPI dwritefontcollection_Release(IDWriteFontCollection *iface)
 
     if (!ref) {
         for (i = 0; i < This->family_count; i++)
-            _free_fontfamily_data(This->family_data[i]);
+            release_fontfamily_data(This->family_data[i]);
         heap_free(This->family_data);
         heap_free(This);
     }
@@ -1930,9 +1954,14 @@ HRESULT create_fontface(DWRITE_FONT_FACE_TYPE facetype, UINT32 files_number, IDW
     DWRITE_FONT_SIMULATIONS simulations, IDWriteFontFace2 **ret)
 {
     struct dwrite_fontface *fontface;
+    const void *data_ptr;
     HRESULT hr = S_OK;
+    void *context;
+    UINT64 size;
     int i;
 
+    *ret = NULL;
+
     fontface = heap_alloc(sizeof(struct dwrite_fontface));
     if (!fontface)
         return E_OUTOFMEMORY;
@@ -1956,6 +1985,7 @@ HRESULT create_fontface(DWRITE_FONT_FACE_TYPE facetype, UINT32 files_number, IDW
     fontface->cmap.size = 0;
     fontface->index = index;
     fontface->simulations = simulations;
+    fontface->ft = NULL;
 
     for (i = 0; i < fontface->file_count; i++) {
         hr = get_stream_from_file(font_files[i], &fontface->streams[i]);
@@ -1970,23 +2000,57 @@ HRESULT create_fontface(DWRITE_FONT_FACE_TYPE facetype, UINT32 files_number, IDW
 
     get_font_properties_from_stream(fontface->streams[0], facetype, index, &fontface->metrics, NULL, NULL, NULL);
 
+    hr = IDWriteFontFileStream_GetFileSize(fontface->streams[0], &size);
+    if (FAILED(hr))
+        goto fail;
+
+    hr = IDWriteFontFileStream_ReadFileFragment(fontface->streams[0], &data_ptr, 0, size, &context);
+    if (FAILED(hr))
+        goto fail;
+
+    hr = alloc_ft_fontface(data_ptr, size, fontface->index, &fontface->ft);
+    IDWriteFontFileStream_ReleaseFileFragment(fontface->streams[0], context);
+    if (FAILED(hr))
+        goto fail;
+
     *ret = &fontface->IDWriteFontFace2_iface;
     return S_OK;
+
+fail:
+    IDWriteFontFace2_Release(&fontface->IDWriteFontFace2_iface);
+    return hr;
 }
 
 /* IDWriteLocalFontFileLoader and its required IDWriteFontFileStream */
+struct local_refkey
+{
+    FILETIME writetime;
+    WCHAR name[1];
+};
+
+struct local_cached_stream
+{
+    struct list entry;
+    IDWriteFontFileStream *stream;
+    struct local_refkey *key;
+    UINT32 key_size;
+};
 
 struct dwrite_localfontfilestream
 {
     IDWriteFontFileStream IDWriteFontFileStream_iface;
     LONG ref;
 
-    HANDLE handle;
+    struct local_cached_stream *entry;
+    const void *file_ptr;
+    UINT64 size;
 };
 
 struct dwrite_localfontfileloader {
     IDWriteLocalFontFileLoader IDWriteLocalFontFileLoader_iface;
     LONG ref;
+
+    struct list streams;
 };
 
 static inline struct dwrite_localfontfileloader *impl_from_IDWriteLocalFontFileLoader(IDWriteLocalFontFileLoader *iface)
@@ -2022,6 +2086,13 @@ static ULONG WINAPI localfontfilestream_AddRef(IDWriteFontFileStream *iface)
     return ref;
 }
 
+static inline void release_cached_stream(struct local_cached_stream *stream)
+{
+    list_remove(&stream->entry);
+    heap_free(stream->key);
+    heap_free(stream);
+}
+
 static ULONG WINAPI localfontfilestream_Release(IDWriteFontFileStream *iface)
 {
     struct dwrite_localfontfilestream *This = impl_from_IDWriteFontFileStream(iface);
@@ -2029,10 +2100,9 @@ static ULONG WINAPI localfontfilestream_Release(IDWriteFontFileStream *iface)
 
     TRACE("(%p)->(%d)\n", This, ref);
 
-    if (!ref)
-    {
-        if (This->handle != INVALID_HANDLE_VALUE)
-            CloseHandle(This->handle);
+    if (!ref) {
+        UnmapViewOfFile(This->file_ptr);
+        release_cached_stream(This->entry);
         heap_free(This);
     }
 
@@ -2042,26 +2112,18 @@ static ULONG WINAPI localfontfilestream_Release(IDWriteFontFileStream *iface)
 static HRESULT WINAPI localfontfilestream_ReadFileFragment(IDWriteFontFileStream *iface, void const **fragment_start, UINT64 offset, UINT64 fragment_size, void **fragment_context)
 {
     struct dwrite_localfontfilestream *This = impl_from_IDWriteFontFileStream(iface);
-    LARGE_INTEGER distance;
-    DWORD bytes = fragment_size;
-    DWORD read;
 
     TRACE("(%p)->(%p, %s, %s, %p)\n",This, fragment_start,
           wine_dbgstr_longlong(offset), wine_dbgstr_longlong(fragment_size), fragment_context);
 
     *fragment_context = NULL;
-    distance.QuadPart = offset;
-    if (!SetFilePointerEx(This->handle, distance, NULL, FILE_BEGIN))
-        return E_FAIL;
-    *fragment_start = *fragment_context = heap_alloc(bytes);
-    if (!*fragment_context)
-        return E_FAIL;
-    if (!ReadFile(This->handle, *fragment_context, bytes, &read, NULL))
-    {
-        heap_free(*fragment_context);
+
+    if ((offset >= This->size - 1) || (fragment_size > This->size - offset)) {
+        *fragment_start = NULL;
         return E_FAIL;
     }
 
+    *fragment_start = (char*)This->file_ptr + offset;
     return S_OK;
 }
 
@@ -2069,25 +2131,28 @@ static void WINAPI localfontfilestream_ReleaseFileFragment(IDWriteFontFileStream
 {
     struct dwrite_localfontfilestream *This = impl_from_IDWriteFontFileStream(iface);
     TRACE("(%p)->(%p)\n", This, fragment_context);
-    heap_free(fragment_context);
 }
 
 static HRESULT WINAPI localfontfilestream_GetFileSize(IDWriteFontFileStream *iface, UINT64 *size)
 {
     struct dwrite_localfontfilestream *This = impl_from_IDWriteFontFileStream(iface);
-    LARGE_INTEGER li;
-    TRACE("(%p)->(%p)\n",This, size);
-    GetFileSizeEx(This->handle, &li);
-    *size = li.QuadPart;
+    TRACE("(%p)->(%p)\n", This, size);
+    *size = This->size;
     return S_OK;
 }
 
 static HRESULT WINAPI localfontfilestream_GetLastWriteTime(IDWriteFontFileStream *iface, UINT64 *last_writetime)
 {
     struct dwrite_localfontfilestream *This = impl_from_IDWriteFontFileStream(iface);
-    FIXME("(%p)->(%p): stub\n",This, last_writetime);
-    *last_writetime = 0;
-    return E_NOTIMPL;
+    ULARGE_INTEGER li;
+
+    TRACE("(%p)->(%p)\n", This, last_writetime);
+
+    li.LowPart = This->entry->key->writetime.dwLowDateTime;
+    li.HighPart = This->entry->key->writetime.dwHighDateTime;
+    *last_writetime = li.QuadPart;
+
+    return S_OK;
 }
 
 static const IDWriteFontFileStreamVtbl localfontfilestreamvtbl =
@@ -2101,15 +2166,18 @@ static const IDWriteFontFileStreamVtbl localfontfilestreamvtbl =
     localfontfilestream_GetLastWriteTime
 };
 
-static HRESULT create_localfontfilestream(HANDLE handle, IDWriteFontFileStream** iface)
+static HRESULT create_localfontfilestream(const void *file_ptr, UINT64 size, struct local_cached_stream *entry, IDWriteFontFileStream** iface)
 {
     struct dwrite_localfontfilestream *This = heap_alloc(sizeof(struct dwrite_localfontfilestream));
     if (!This)
         return E_OUTOFMEMORY;
 
-    This->ref = 1;
-    This->handle = handle;
     This->IDWriteFontFileStream_iface.lpVtbl = &localfontfilestreamvtbl;
+    This->ref = 1;
+
+    This->file_ptr = file_ptr;
+    This->size = size;
+    This->entry = entry;
 
     *iface = &This->IDWriteFontFileStream_iface;
     return S_OK;
@@ -2147,53 +2215,123 @@ static ULONG WINAPI localfontfileloader_Release(IDWriteLocalFontFileLoader *ifac
 
     TRACE("(%p)->(%d)\n", This, ref);
 
-    if (!ref)
+    if (!ref) {
+        struct local_cached_stream *stream, *stream2;
+
+        /* This will detach all entries from cache. Entries are released together with streams,
+           so stream controls its lifetime. */
+        LIST_FOR_EACH_ENTRY_SAFE(stream, stream2, &This->streams, struct local_cached_stream, entry)
+            list_init(&stream->entry);
+
         heap_free(This);
+    }
 
     return ref;
 }
 
-static HRESULT WINAPI localfontfileloader_CreateStreamFromKey(IDWriteLocalFontFileLoader *iface, const void *fontFileReferenceKey, UINT32 fontFileReferenceKeySize, IDWriteFontFileStream **fontFileStream)
+static HRESULT WINAPI localfontfileloader_CreateStreamFromKey(IDWriteLocalFontFileLoader *iface, const void *key, UINT32 key_size, IDWriteFontFileStream **ret)
 {
-    HANDLE handle;
     struct dwrite_localfontfileloader *This = impl_from_IDWriteLocalFontFileLoader(iface);
-    const WCHAR *name = (const WCHAR*)fontFileReferenceKey;
+    const struct local_refkey *refkey = key;
+    struct local_cached_stream *stream;
+    IDWriteFontFileStream *filestream;
+    HANDLE file, mapping;
+    LARGE_INTEGER size;
+    void *file_ptr;
+    HRESULT hr;
+
+    TRACE("(%p)->(%p, %i, %p)\n", This, key, key_size, ret);
+    TRACE("name: %s\n", debugstr_w(refkey->name));
 
-    TRACE("(%p)->(%p, %i, %p)\n",This, fontFileReferenceKey, fontFileReferenceKeySize, fontFileStream);
+    /* search cache first */
+    LIST_FOR_EACH_ENTRY(stream, &This->streams, struct local_cached_stream, entry) {
+        if (key_size == stream->key_size && !memcmp(stream->key, key, key_size)) {
+            *ret = stream->stream;
+            IDWriteFontFileStream_AddRef(*ret);
+            return S_OK;
+        }
+    }
+
+    *ret = NULL;
 
-    TRACE("name: %s\n",debugstr_w(name));
-    handle = CreateFileW(name, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE,
+    file = CreateFileW(refkey->name, GENERIC_READ, FILE_SHARE_READ|FILE_SHARE_WRITE,
                          NULL, OPEN_EXISTING, FILE_ATTRIBUTE_NORMAL, NULL);
+    if (file == INVALID_HANDLE_VALUE)
+        return E_FAIL;
 
-    if (handle == INVALID_HANDLE_VALUE)
+    GetFileSizeEx(file, &size);
+    mapping = CreateFileMappingW(file, NULL, PAGE_READONLY, 0, 0, NULL);
+    CloseHandle(file);
+    if (!mapping)
         return E_FAIL;
 
-    return create_localfontfilestream(handle, fontFileStream);
+    file_ptr = MapViewOfFile(mapping, FILE_MAP_READ, 0, 0, 0);
+    CloseHandle(mapping);
+
+    stream = heap_alloc(sizeof(*stream));
+    if (!stream)
+        return E_OUTOFMEMORY;
+
+    stream->key = heap_alloc(key_size);
+    if (!stream->key) {
+        UnmapViewOfFile(file_ptr);
+        heap_free(stream);
+        return E_OUTOFMEMORY;
+    }
+
+    stream->key_size = key_size;
+    memcpy(stream->key, key, key_size);
+
+    hr = create_localfontfilestream(file_ptr, size.QuadPart, stream, &filestream);
+    if (FAILED(hr)) {
+        UnmapViewOfFile(file_ptr);
+        heap_free(stream->key);
+        heap_free(stream);
+        return hr;
+    }
+
+    stream->stream = filestream;
+    list_add_head(&This->streams, &stream->entry);
+
+    *ret = stream->stream;
+
+    return S_OK;
 }
 
 static HRESULT WINAPI localfontfileloader_GetFilePathLengthFromKey(IDWriteLocalFontFileLoader *iface, void const *key, UINT32 key_size, UINT32 *length)
 {
     struct dwrite_localfontfileloader *This = impl_from_IDWriteLocalFontFileLoader(iface);
-    TRACE("(%p)->(%p, %i, %p)\n",This, key, key_size, length);
-    *length = key_size;
+    const struct local_refkey *refkey = key;
+
+    TRACE("(%p)->(%p, %i, %p)\n", This, key, key_size, length);
+
+    *length = strlenW(refkey->name);
     return S_OK;
 }
 
 static HRESULT WINAPI localfontfileloader_GetFilePathFromKey(IDWriteLocalFontFileLoader *iface, void const *key, UINT32 key_size, WCHAR *path, UINT32 length)
 {
     struct dwrite_localfontfileloader *This = impl_from_IDWriteLocalFontFileLoader(iface);
-    TRACE("(%p)->(%p, %i, %p, %i)\n",This, key, key_size, path, length);
-    if (length < key_size)
+    const struct local_refkey *refkey = key;
+
+    TRACE("(%p)->(%p, %i, %p, %i)\n", This, key, key_size, path, length);
+
+    if (length < strlenW(refkey->name))
         return E_INVALIDARG;
-    lstrcpynW((WCHAR*)key, path, key_size);
+
+    strcpyW(path, refkey->name);
     return S_OK;
 }
 
 static HRESULT WINAPI localfontfileloader_GetLastWriteTimeFromKey(IDWriteLocalFontFileLoader *iface, void const *key, UINT32 key_size, FILETIME *writetime)
 {
     struct dwrite_localfontfileloader *This = impl_from_IDWriteLocalFontFileLoader(iface);
-    FIXME("(%p)->(%p, %i, %p):stub\n",This, key, key_size, writetime);
-    return E_NOTIMPL;
+    const struct local_refkey *refkey = key;
+
+    TRACE("(%p)->(%p, %i, %p)\n", This, key, key_size, writetime);
+
+    *writetime = refkey->writetime;
+    return S_OK;
 }
 
 static const struct IDWriteLocalFontFileLoaderVtbl localfontfileloadervtbl = {
@@ -2212,9 +2350,38 @@ HRESULT create_localfontfileloader(IDWriteLocalFontFileLoader** iface)
     if (!This)
         return E_OUTOFMEMORY;
 
-    This->ref = 1;
     This->IDWriteLocalFontFileLoader_iface.lpVtbl = &localfontfileloadervtbl;
+    This->ref = 1;
+    list_init(&This->streams);
 
     *iface = &This->IDWriteLocalFontFileLoader_iface;
     return S_OK;
 }
+
+HRESULT get_local_refkey(const WCHAR *path, const FILETIME *writetime, void **key, UINT32 *size)
+{
+    struct local_refkey *refkey;
+
+    *size = FIELD_OFFSET(struct local_refkey, name) + (strlenW(path)+1)*sizeof(WCHAR);
+    *key = NULL;
+
+    refkey = heap_alloc(*size);
+    if (!refkey)
+        return E_OUTOFMEMORY;
+
+    if (writetime)
+        refkey->writetime = *writetime;
+    else {
+        WIN32_FILE_ATTRIBUTE_DATA info;
+
+        if (GetFileAttributesExW(path, GetFileExInfoStandard, &info))
+            refkey->writetime = info.ftLastWriteTime;
+        else
+            memset(&refkey->writetime, 0, sizeof(refkey->writetime));
+    }
+    strcpyW(refkey->name, path);
+
+    *key = refkey;
+
+    return S_OK;
+}
diff --git a/dlls/dwrite/freetype.c b/dlls/dwrite/freetype.c
new file mode 100644
index 0000000..86d85b3
--- /dev/null
+++ b/dlls/dwrite/freetype.c
@@ -0,0 +1,138 @@
+/*
+ *    FreeType integration
+ *
+ * Copyright 2014 Nikolay Sivov for CodeWeavers
+ *
+ * This library is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * This library is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with this library; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
+ */
+
+#include "config.h"
+#include "wine/port.h"
+
+#ifdef HAVE_FT2BUILD_H
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#endif /* HAVE_FT2BUILD_H */
+
+#include "windef.h"
+#include "wine/library.h"
+#include "wine/debug.h"
+
+#include "dwrite_private.h"
+
+WINE_DEFAULT_DEBUG_CHANNEL(dwrite);
+
+#ifdef HAVE_FREETYPE
+
+static void *ft_handle = NULL;
+static FT_Library library = 0;
+typedef struct
+{
+    FT_Int major;
+    FT_Int minor;
+    FT_Int patch;
+} FT_Version_t;
+
+#define MAKE_FUNCPTR(f) static typeof(f) * p##f = NULL
+MAKE_FUNCPTR(FT_Done_Face);
+MAKE_FUNCPTR(FT_Init_FreeType);
+MAKE_FUNCPTR(FT_Library_Version);
+MAKE_FUNCPTR(FT_New_Memory_Face);
+#undef MAKE_FUNCPTR
+
+struct ft_fontface
+{
+    FT_Face face;
+};
+
+BOOL init_freetype(void)
+{
+    FT_Version_t FT_Version;
+
+    ft_handle = wine_dlopen(SONAME_LIBFREETYPE, RTLD_NOW, NULL, 0);
+    if (!ft_handle) {
+        WINE_MESSAGE("Wine cannot find the FreeType font library.\n");
+	return FALSE;
+    }
+
+#define LOAD_FUNCPTR(f) if((p##f = wine_dlsym(ft_handle, #f, NULL, 0)) == NULL){WARN("Can't find symbol %s\n", #f); goto sym_not_found;}
+    LOAD_FUNCPTR(FT_Done_Face)
+    LOAD_FUNCPTR(FT_Init_FreeType)
+    LOAD_FUNCPTR(FT_Library_Version)
+    LOAD_FUNCPTR(FT_New_Memory_Face)
+#undef LOAD_FUNCPTR
+
+    if (pFT_Init_FreeType(&library) != 0) {
+        ERR("Can't init FreeType library\n");
+	wine_dlclose(ft_handle, NULL, 0);
+        ft_handle = NULL;
+	return FALSE;
+    }
+    pFT_Library_Version(library, &FT_Version.major, &FT_Version.minor, &FT_Version.patch);
+
+    TRACE("FreeType version is %d.%d.%d\n", FT_Version.major, FT_Version.minor, FT_Version.patch);
+    return TRUE;
+
+sym_not_found:
+    WINE_MESSAGE("Wine cannot find certain functions that it needs from FreeType library.\n");
+    wine_dlclose(ft_handle, NULL, 0);
+    ft_handle = NULL;
+    return FALSE;
+}
+
+HRESULT alloc_ft_fontface(const void *data_ptr, UINT32 data_size, UINT32 index, struct ft_fontface **ftface)
+{
+    FT_Face face;
+    FT_Error err;
+
+    *ftface = heap_alloc_zero(sizeof(struct ft_fontface));
+    if (!*ftface)
+        return E_OUTOFMEMORY;
+
+    err = pFT_New_Memory_Face(library, data_ptr, data_size, index, &face);
+    if (err) {
+        ERR("FT_New_Memory_Face rets %d\n", err);
+	return E_FAIL;
+    }
+    (*ftface)->face = face;
+
+    return S_OK;
+}
+
+void release_ft_fontface(struct ft_fontface *ftface)
+{
+    if (!ftface) return;
+    pFT_Done_Face(ftface->face);
+    heap_free(ftface);
+}
+
+#else /* HAVE_FREETYPE */
+
+BOOL init_freetype(void)
+{
+    return FALSE;
+}
+
+HRESULT alloc_ft_fontface(const void *data_ptr, UINT32 data_size, UINT32 index, struct ft_fontface **face)
+{
+    *face = NULL;
+    return S_FALSE;
+}
+
+void release_ft_fontface(struct ft_fontface *face)
+{
+}
+
+#endif /* HAVE_FREETYPE */
diff --git a/dlls/dwrite/gdiinterop.c b/dlls/dwrite/gdiinterop.c
index 3715bf0..23da98b 100644
--- a/dlls/dwrite/gdiinterop.c
+++ b/dlls/dwrite/gdiinterop.c
@@ -1,7 +1,7 @@
 /*
  *    GDI Interop
  *
- * Copyright 2012 Nikolay Sivov for CodeWeavers
+ * Copyright 2012, 2014 Nikolay Sivov for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -31,15 +31,23 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(dwrite);
 
+static const DWRITE_MATRIX identity =
+{
+    1.0f, 0.0f,
+    0.0f, 1.0f,
+    0.0f, 0.0f
+};
+
 struct gdiinterop {
     IDWriteGdiInterop IDWriteGdiInterop_iface;
     IDWriteFactory *factory;
 };
 
 struct rendertarget {
-    IDWriteBitmapRenderTarget IDWriteBitmapRenderTarget_iface;
+    IDWriteBitmapRenderTarget1 IDWriteBitmapRenderTarget1_iface;
     LONG ref;
 
+    DWRITE_TEXT_ANTIALIAS_MODE antialiasmode;
     FLOAT pixels_per_dip;
     DWRITE_MATRIX m;
     SIZE size;
@@ -68,9 +76,9 @@ static HRESULT create_target_dibsection(HDC hdc, UINT32 width, UINT32 height)
     return S_OK;
 }
 
-static inline struct rendertarget *impl_from_IDWriteBitmapRenderTarget(IDWriteBitmapRenderTarget *iface)
+static inline struct rendertarget *impl_from_IDWriteBitmapRenderTarget1(IDWriteBitmapRenderTarget1 *iface)
 {
-    return CONTAINING_RECORD(iface, struct rendertarget, IDWriteBitmapRenderTarget_iface);
+    return CONTAINING_RECORD(iface, struct rendertarget, IDWriteBitmapRenderTarget1_iface);
 }
 
 static inline struct gdiinterop *impl_from_IDWriteGdiInterop(IDWriteGdiInterop *iface)
@@ -78,16 +86,18 @@ static inline struct gdiinterop *impl_from_IDWriteGdiInterop(IDWriteGdiInterop *
     return CONTAINING_RECORD(iface, struct gdiinterop, IDWriteGdiInterop_iface);
 }
 
-static HRESULT WINAPI rendertarget_QueryInterface(IDWriteBitmapRenderTarget *iface, REFIID riid, void **obj)
+static HRESULT WINAPI rendertarget_QueryInterface(IDWriteBitmapRenderTarget1 *iface, REFIID riid, void **obj)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
 
     TRACE("(%p)->(%s %p)\n", This, debugstr_guid(riid), obj);
 
-    if (IsEqualIID(riid, &IID_IUnknown) || IsEqualIID(riid, &IID_IDWriteBitmapRenderTarget))
+    if (IsEqualIID(riid, &IID_IDWriteBitmapRenderTarget1) ||
+        IsEqualIID(riid, &IID_IDWriteBitmapRenderTarget) ||
+        IsEqualIID(riid, &IID_IUnknown))
     {
         *obj = iface;
-        IDWriteBitmapRenderTarget_AddRef(iface);
+        IDWriteBitmapRenderTarget1_AddRef(iface);
         return S_OK;
     }
 
@@ -96,17 +106,17 @@ static HRESULT WINAPI rendertarget_QueryInterface(IDWriteBitmapRenderTarget *ifa
     return E_NOINTERFACE;
 }
 
-static ULONG WINAPI rendertarget_AddRef(IDWriteBitmapRenderTarget *iface)
+static ULONG WINAPI rendertarget_AddRef(IDWriteBitmapRenderTarget1 *iface)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
     ULONG ref = InterlockedIncrement(&This->ref);
     TRACE("(%p)->(%d)\n", This, ref);
     return ref;
 }
 
-static ULONG WINAPI rendertarget_Release(IDWriteBitmapRenderTarget *iface)
+static ULONG WINAPI rendertarget_Release(IDWriteBitmapRenderTarget1 *iface)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
     ULONG ref = InterlockedDecrement(&This->ref);
 
     TRACE("(%p)->(%d)\n", This, ref);
@@ -120,34 +130,34 @@ static ULONG WINAPI rendertarget_Release(IDWriteBitmapRenderTarget *iface)
     return ref;
 }
 
-static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget *iface,
+static HRESULT WINAPI rendertarget_DrawGlyphRun(IDWriteBitmapRenderTarget1 *iface,
     FLOAT baselineOriginX, FLOAT baselineOriginY, DWRITE_MEASURING_MODE measuring_mode,
     DWRITE_GLYPH_RUN const* glyph_run, IDWriteRenderingParams* params, COLORREF textColor,
     RECT *blackbox_rect)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
     FIXME("(%p)->(%f %f %d %p %p 0x%08x %p): stub\n", This, baselineOriginX, baselineOriginY,
         measuring_mode, glyph_run, params, textColor, blackbox_rect);
     return E_NOTIMPL;
 }
 
-static HDC WINAPI rendertarget_GetMemoryDC(IDWriteBitmapRenderTarget *iface)
+static HDC WINAPI rendertarget_GetMemoryDC(IDWriteBitmapRenderTarget1 *iface)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
     TRACE("(%p)\n", This);
     return This->hdc;
 }
 
-static FLOAT WINAPI rendertarget_GetPixelsPerDip(IDWriteBitmapRenderTarget *iface)
+static FLOAT WINAPI rendertarget_GetPixelsPerDip(IDWriteBitmapRenderTarget1 *iface)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
     TRACE("(%p)\n", This);
     return This->pixels_per_dip;
 }
 
-static HRESULT WINAPI rendertarget_SetPixelsPerDip(IDWriteBitmapRenderTarget *iface, FLOAT pixels_per_dip)
+static HRESULT WINAPI rendertarget_SetPixelsPerDip(IDWriteBitmapRenderTarget1 *iface, FLOAT pixels_per_dip)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
 
     TRACE("(%p)->(%.2f)\n", This, pixels_per_dip);
 
@@ -158,9 +168,9 @@ static HRESULT WINAPI rendertarget_SetPixelsPerDip(IDWriteBitmapRenderTarget *if
     return S_OK;
 }
 
-static HRESULT WINAPI rendertarget_GetCurrentTransform(IDWriteBitmapRenderTarget *iface, DWRITE_MATRIX *transform)
+static HRESULT WINAPI rendertarget_GetCurrentTransform(IDWriteBitmapRenderTarget1 *iface, DWRITE_MATRIX *transform)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
 
     TRACE("(%p)->(%p)\n", This, transform);
 
@@ -168,25 +178,28 @@ static HRESULT WINAPI rendertarget_GetCurrentTransform(IDWriteBitmapRenderTarget
     return S_OK;
 }
 
-static HRESULT WINAPI rendertarget_SetCurrentTransform(IDWriteBitmapRenderTarget *iface, DWRITE_MATRIX const *transform)
+static HRESULT WINAPI rendertarget_SetCurrentTransform(IDWriteBitmapRenderTarget1 *iface, DWRITE_MATRIX const *transform)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
-    FIXME("(%p)->(%p): stub\n", This, transform);
-    return E_NOTIMPL;
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
+
+    TRACE("(%p)->(%p)\n", This, transform);
+
+    This->m = transform ? *transform : identity;
+    return S_OK;
 }
 
-static HRESULT WINAPI rendertarget_GetSize(IDWriteBitmapRenderTarget *iface, SIZE *size)
+static HRESULT WINAPI rendertarget_GetSize(IDWriteBitmapRenderTarget1 *iface, SIZE *size)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
 
     TRACE("(%p)->(%p)\n", This, size);
     *size = This->size;
     return S_OK;
 }
 
-static HRESULT WINAPI rendertarget_Resize(IDWriteBitmapRenderTarget *iface, UINT32 width, UINT32 height)
+static HRESULT WINAPI rendertarget_Resize(IDWriteBitmapRenderTarget1 *iface, UINT32 width, UINT32 height)
 {
-    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget(iface);
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
 
     TRACE("(%p)->(%u %u)\n", This, width, height);
 
@@ -196,7 +209,27 @@ static HRESULT WINAPI rendertarget_Resize(IDWriteBitmapRenderTarget *iface, UINT
     return create_target_dibsection(This->hdc, width, height);
 }
 
-static const IDWriteBitmapRenderTargetVtbl rendertargetvtbl = {
+static DWRITE_TEXT_ANTIALIAS_MODE WINAPI rendertarget_GetTextAntialiasMode(IDWriteBitmapRenderTarget1 *iface)
+{
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
+    TRACE("(%p)\n", This);
+    return This->antialiasmode;
+}
+
+static HRESULT WINAPI rendertarget_SetTextAntialiasMode(IDWriteBitmapRenderTarget1 *iface, DWRITE_TEXT_ANTIALIAS_MODE mode)
+{
+    struct rendertarget *This = impl_from_IDWriteBitmapRenderTarget1(iface);
+
+    TRACE("(%p)->(%d)\n", This, mode);
+
+    if ((DWORD)mode > DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE)
+        return E_INVALIDARG;
+
+    This->antialiasmode = mode;
+    return S_OK;
+}
+
+static const IDWriteBitmapRenderTarget1Vtbl rendertargetvtbl = {
     rendertarget_QueryInterface,
     rendertarget_AddRef,
     rendertarget_Release,
@@ -207,7 +240,9 @@ static const IDWriteBitmapRenderTargetVtbl rendertargetvtbl = {
     rendertarget_GetCurrentTransform,
     rendertarget_SetCurrentTransform,
     rendertarget_GetSize,
-    rendertarget_Resize
+    rendertarget_Resize,
+    rendertarget_GetTextAntialiasMode,
+    rendertarget_SetTextAntialiasMode
 };
 
 static HRESULT create_rendertarget(HDC hdc, UINT32 width, UINT32 height, IDWriteBitmapRenderTarget **ret)
@@ -220,7 +255,7 @@ static HRESULT create_rendertarget(HDC hdc, UINT32 width, UINT32 height, IDWrite
     target = heap_alloc(sizeof(struct rendertarget));
     if (!target) return E_OUTOFMEMORY;
 
-    target->IDWriteBitmapRenderTarget_iface.lpVtbl = &rendertargetvtbl;
+    target->IDWriteBitmapRenderTarget1_iface.lpVtbl = &rendertargetvtbl;
     target->ref = 1;
 
     target->size.cx = width;
@@ -229,16 +264,15 @@ static HRESULT create_rendertarget(HDC hdc, UINT32 width, UINT32 height, IDWrite
     target->hdc = CreateCompatibleDC(hdc);
     hr = create_target_dibsection(target->hdc, width, height);
     if (FAILED(hr)) {
-        IDWriteBitmapRenderTarget_Release(&target->IDWriteBitmapRenderTarget_iface);
+        IDWriteBitmapRenderTarget1_Release(&target->IDWriteBitmapRenderTarget1_iface);
         return hr;
     }
 
-    target->m.m11 = target->m.m22 = 1.0;
-    target->m.m12 = target->m.m21 = 0.0;
-    target->m.dx  = target->m.dy  = 0.0;
+    target->m = identity;
     target->pixels_per_dip = 1.0;
+    target->antialiasmode = DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE;
 
-    *ret = &target->IDWriteBitmapRenderTarget_iface;
+    *ret = (IDWriteBitmapRenderTarget*)&target->IDWriteBitmapRenderTarget1_iface;
 
     return S_OK;
 }
diff --git a/dlls/dwrite/main.c b/dlls/dwrite/main.c
index 2868c3b..79aa7d0 100644
--- a/dlls/dwrite/main.c
+++ b/dlls/dwrite/main.c
@@ -45,6 +45,7 @@ BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD reason, LPVOID reserved)
         return FALSE;  /* prefer native version */
     case DLL_PROCESS_ATTACH:
         DisableThreadLibraryCalls( hinstDLL );
+        init_freetype();
         break;
     case DLL_PROCESS_DETACH:
         if (reserved) break;
@@ -686,8 +687,11 @@ static HRESULT WINAPI dwritefactory_UnregisterFontCollectionLoader(IDWriteFactor
 static HRESULT WINAPI dwritefactory_CreateFontFileReference(IDWriteFactory *iface,
     WCHAR const *path, FILETIME const *writetime, IDWriteFontFile **font_file)
 {
-    HRESULT hr;
     struct dwritefactory *This = impl_from_IDWriteFactory(iface);
+    UINT32 key_size;
+    HRESULT hr;
+    void *key;
+
     TRACE("(%p)->(%s %p %p)\n", This, debugstr_w(path), writetime, font_file);
 
     if (!This->localfontfileloader)
@@ -696,7 +700,16 @@ static HRESULT WINAPI dwritefactory_CreateFontFileReference(IDWriteFactory *ifac
         if (FAILED(hr))
             return hr;
     }
-    return create_font_file((IDWriteFontFileLoader*)This->localfontfileloader, path, sizeof(WCHAR) * (strlenW(path)+1), font_file);
+
+    /* get a reference key used by local loader */
+    hr = get_local_refkey(path, writetime, &key, &key_size);
+    if (FAILED(hr))
+        return hr;
+
+    hr = create_font_file((IDWriteFontFileLoader*)This->localfontfileloader, key, key_size, font_file);
+    heap_free(key);
+
+    return hr;
 }
 
 static HRESULT WINAPI dwritefactory_CreateCustomFontFileReference(IDWriteFactory *iface,
diff --git a/dlls/dwrite/opentype.c b/dlls/dwrite/opentype.c
index c893227..a0f1c31 100644
--- a/dlls/dwrite/opentype.c
+++ b/dlls/dwrite/opentype.c
@@ -867,8 +867,8 @@ void opentype_get_font_metrics(const void *os2, const void *head, const void *po
     memset(metrics, 0, sizeof(*metrics));
 
     if (tt_os2) {
-        metrics->ascent    = GET_BE_WORD(tt_os2->sTypoAscender);
-        metrics->descent   = GET_BE_WORD(tt_os2->sTypoDescender);
+        metrics->ascent    = GET_BE_WORD(tt_os2->usWinAscent);
+        metrics->descent   = GET_BE_WORD(tt_os2->usWinDescent);
         metrics->lineGap   = GET_BE_WORD(tt_os2->sTypoLineGap);
         metrics->capHeight = GET_BE_WORD(tt_os2->sCapHeight);
         metrics->xHeight   = GET_BE_WORD(tt_os2->sxHeight);
@@ -930,6 +930,8 @@ static UINT get_name_record_codepage(enum OPENTYPE_PLATFORM_ID platform, USHORT
     UINT codepage = 0;
 
     switch (platform) {
+    case OPENTYPE_PLATFORM_UNICODE:
+        break;
     case OPENTYPE_PLATFORM_MAC:
         switch (encoding)
         {
diff --git a/dlls/dwrite/shape.c b/dlls/dwrite/shape.c
index c1ae452..a603932 100644
--- a/dlls/dwrite/shape.c
+++ b/dlls/dwrite/shape.c
@@ -23,8 +23,6 @@
 
 #include "dwrite_private.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(dwrite);
-
 struct scriptshaping_cache
 {
     IDWriteFontFace *fontface;
diff --git a/dlls/dwrite/tests/font.c b/dlls/dwrite/tests/font.c
index 60d0d44..221a5d3 100644
--- a/dlls/dwrite/tests/font.c
+++ b/dlls/dwrite/tests/font.c
@@ -527,6 +527,7 @@ todo_wine {
 static void test_CreateBitmapRenderTarget(void)
 {
     IDWriteBitmapRenderTarget *target, *target2;
+    IDWriteBitmapRenderTarget1 *target1;
     IDWriteGdiInterop *interop;
     IDWriteFactory *factory;
     HBITMAP hbm, hbm2;
@@ -666,6 +667,25 @@ if (0) /* crashes on native */
     ok(m.m11 == 1.0 && m.m22 == 1.0 && m.m12 == 0.0 && m.m21 == 0.0, "got %.1f,%.1f,%.1f,%.1f\n", m.m11, m.m22, m.m12, m.m21);
     ok(m.dx == 0.0 && m.dy == 0.0, "got %.1f,%.1f\n", m.dx, m.dy);
 
+    memset(&m, 0, sizeof(m));
+    hr = IDWriteBitmapRenderTarget_SetCurrentTransform(target, &m);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    memset(&m, 0xcc, sizeof(m));
+    hr = IDWriteBitmapRenderTarget_GetCurrentTransform(target, &m);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(m.m11 == 0.0 && m.m22 == 0.0 && m.m12 == 0.0 && m.m21 == 0.0, "got %.1f,%.1f,%.1f,%.1f\n", m.m11, m.m22, m.m12, m.m21);
+    ok(m.dx == 0.0 && m.dy == 0.0, "got %.1f,%.1f\n", m.dx, m.dy);
+
+    hr = IDWriteBitmapRenderTarget_SetCurrentTransform(target, NULL);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    memset(&m, 0xcc, sizeof(m));
+    hr = IDWriteBitmapRenderTarget_GetCurrentTransform(target, &m);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(m.m11 == 1.0 && m.m22 == 1.0 && m.m12 == 0.0 && m.m21 == 0.0, "got %.1f,%.1f,%.1f,%.1f\n", m.m11, m.m22, m.m12, m.m21);
+    ok(m.dx == 0.0 && m.dy == 0.0, "got %.1f,%.1f\n", m.dx, m.dy);
+
     /* pixels per dip */
     pdip = IDWriteBitmapRenderTarget_GetPixelsPerDip(target);
     ok(pdip == 1.0, "got %.2f\n", pdip);
@@ -682,6 +702,30 @@ if (0) /* crashes on native */
     pdip = IDWriteBitmapRenderTarget_GetPixelsPerDip(target);
     ok(pdip == 2.0, "got %.2f\n", pdip);
 
+    hr = IDWriteBitmapRenderTarget_QueryInterface(target, &IID_IDWriteBitmapRenderTarget1, (void**)&target1);
+    if (hr == S_OK) {
+        DWRITE_TEXT_ANTIALIAS_MODE mode;
+
+        mode = IDWriteBitmapRenderTarget1_GetTextAntialiasMode(target1);
+        ok(mode == DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE, "got %d\n", mode);
+
+        hr = IDWriteBitmapRenderTarget1_SetTextAntialiasMode(target1, DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE+1);
+        ok(hr == E_INVALIDARG, "got 0x%08x\n", hr);
+
+        mode = IDWriteBitmapRenderTarget1_GetTextAntialiasMode(target1);
+        ok(mode == DWRITE_TEXT_ANTIALIAS_MODE_CLEARTYPE, "got %d\n", mode);
+
+        hr = IDWriteBitmapRenderTarget1_SetTextAntialiasMode(target1, DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE);
+        ok(hr == S_OK, "got 0x%08x\n", hr);
+
+        mode = IDWriteBitmapRenderTarget1_GetTextAntialiasMode(target1);
+        ok(mode == DWRITE_TEXT_ANTIALIAS_MODE_GRAYSCALE, "got %d\n", mode);
+
+        IDWriteBitmapRenderTarget1_Release(target1);
+    }
+    else
+        win_skip("IDWriteBitmapRenderTarget1 is not supported.\n");
+
     IDWriteBitmapRenderTarget_Release(target);
     IDWriteGdiInterop_Release(interop);
     IDWriteFactory_Release(factory);
@@ -2218,15 +2262,26 @@ static void test_GetFaceNames(void)
     IDWriteFactory_Release(factory);
 }
 
+struct local_refkey
+{
+    FILETIME writetime;
+    WCHAR name[1];
+};
+
 static void test_TryGetFontTable(void)
 {
+    IDWriteLocalFontFileLoader *localloader;
+    WIN32_FILE_ATTRIBUTE_DATA info;
+    const struct local_refkey *key;
+    IDWriteFontFileLoader *loader;
     const void *table, *table2;
     IDWriteFontFace *fontface;
     void *context, *context2;
     IDWriteFactory *factory;
     IDWriteFontFile *file;
-    BOOL exists;
-    UINT32 size;
+    WCHAR buffW[MAX_PATH];
+    BOOL exists, ret;
+    UINT32 size, len;
     HRESULT hr;
 
     create_testfontfile(test_fontfile);
@@ -2236,6 +2291,30 @@ static void test_TryGetFontTable(void)
     hr = IDWriteFactory_CreateFontFileReference(factory, test_fontfile, NULL, &file);
     ok(hr == S_OK, "got 0x%08x\n",hr);
 
+    key = NULL;
+    size = 0;
+    hr = IDWriteFontFile_GetReferenceKey(file, (const void**)&key, &size);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(size != 0, "got %u\n", size);
+
+    ret = GetFileAttributesExW(test_fontfile, GetFileExInfoStandard, &info);
+    ok(ret, "got %d\n", ret);
+    ok(!memcmp(&info.ftLastWriteTime, &key->writetime, sizeof(key->writetime)), "got wrong write time\n");
+
+    hr = IDWriteFontFile_GetLoader(file, &loader);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    IDWriteFontFileLoader_QueryInterface(loader, &IID_IDWriteLocalFontFileLoader, (void**)&localloader);
+    IDWriteFontFileLoader_Release(loader);
+
+    hr = IDWriteLocalFontFileLoader_GetFilePathLengthFromKey(localloader, key, size, &len);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(lstrlenW(key->name) == len, "path length %d\n", len);
+
+    hr = IDWriteLocalFontFileLoader_GetFilePathFromKey(localloader, key, size, buffW, sizeof(buffW)/sizeof(WCHAR));
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(!lstrcmpW(buffW, key->name), "got %s, expected %s\n", wine_dbgstr_w(buffW), wine_dbgstr_w(key->name));
+    IDWriteLocalFontFileLoader_Release(localloader);
+
     hr = IDWriteFactory_CreateFontFace(factory, DWRITE_FONT_FACE_TYPE_TRUETYPE, 1, &file, 0, 0, &fontface);
     ok(hr == S_OK, "got 0x%08x\n",hr);
 
@@ -2320,6 +2399,140 @@ if (0) { /* crashes on native */
     IDWriteFactory_Release(factory);
 }
 
+static void test_CreateStreamFromKey(void)
+{
+    IDWriteLocalFontFileLoader *localloader;
+    IDWriteFontFileStream *stream, *stream2;
+    IDWriteFontFileLoader *loader;
+    IDWriteFactory *factory;
+    IDWriteFontFile *file;
+    UINT64 writetime;
+    void *key;
+    UINT32 size;
+    HRESULT hr;
+
+    factory = create_factory();
+
+    create_testfontfile(test_fontfile);
+
+    hr = IDWriteFactory_CreateFontFileReference(factory, test_fontfile, NULL, &file);
+    ok(hr == S_OK, "got 0x%08x\n",hr);
+
+    key = NULL;
+    size = 0;
+    hr = IDWriteFontFile_GetReferenceKey(file, (const void**)&key, &size);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(size != 0, "got %u\n", size);
+
+    hr = IDWriteFontFile_GetLoader(file, &loader);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    IDWriteFontFileLoader_QueryInterface(loader, &IID_IDWriteLocalFontFileLoader, (void**)&localloader);
+    IDWriteFontFileLoader_Release(loader);
+
+    hr = IDWriteLocalFontFileLoader_CreateStreamFromKey(localloader, key, size, &stream);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    EXPECT_REF(stream, 1);
+
+    hr = IDWriteLocalFontFileLoader_CreateStreamFromKey(localloader, key, size, &stream2);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(stream == stream2, "got %p, %p\n", stream, stream2);
+    EXPECT_REF(stream, 2);
+    IDWriteFontFileStream_Release(stream);
+    IDWriteFontFileStream_Release(stream2);
+
+    hr = IDWriteLocalFontFileLoader_CreateStreamFromKey(localloader, key, size, &stream);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    EXPECT_REF(stream, 1);
+
+    writetime = 0;
+    hr = IDWriteFontFileStream_GetLastWriteTime(stream, &writetime);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(writetime != 0, "got %08x%08x\n", (UINT)(writetime >> 32), (UINT)writetime);
+
+    IDWriteFontFileStream_Release(stream);
+
+    IDWriteLocalFontFileLoader_Release(localloader);
+    IDWriteFactory_Release(factory);
+    DeleteFileW(test_fontfile);
+}
+
+static void test_ReadFileFragment(void)
+{
+    IDWriteLocalFontFileLoader *localloader;
+    IDWriteFontFileStream *stream;
+    IDWriteFontFileLoader *loader;
+    IDWriteFactory *factory;
+    IDWriteFontFile *file;
+    const void *fragment, *fragment2;
+    void *key, *context, *context2;
+    UINT64 filesize;
+    UINT32 size;
+    HRESULT hr;
+
+    factory = create_factory();
+
+    create_testfontfile(test_fontfile);
+
+    hr = IDWriteFactory_CreateFontFileReference(factory, test_fontfile, NULL, &file);
+    ok(hr == S_OK, "got 0x%08x\n",hr);
+
+    key = NULL;
+    size = 0;
+    hr = IDWriteFontFile_GetReferenceKey(file, (const void**)&key, &size);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(size != 0, "got %u\n", size);
+
+    hr = IDWriteFontFile_GetLoader(file, &loader);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    IDWriteFontFileLoader_QueryInterface(loader, &IID_IDWriteLocalFontFileLoader, (void**)&localloader);
+    IDWriteFontFileLoader_Release(loader);
+
+    hr = IDWriteLocalFontFileLoader_CreateStreamFromKey(localloader, key, size, &stream);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    hr = IDWriteFontFileStream_GetFileSize(stream, &filesize);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+
+    /* reading past the end of the stream */
+    fragment = (void*)0xdeadbeef;
+    context = (void*)0xdeadbeef;
+    hr = IDWriteFontFileStream_ReadFileFragment(stream, &fragment, 0, filesize+1, &context);
+    ok(hr == E_FAIL, "got 0x%08x\n", hr);
+    ok(context == NULL, "got %p\n", context);
+    ok(fragment == NULL, "got %p\n", fragment);
+
+    fragment = (void*)0xdeadbeef;
+    context = (void*)0xdeadbeef;
+    hr = IDWriteFontFileStream_ReadFileFragment(stream, &fragment, 0, filesize, &context);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(context == NULL, "got %p\n", context);
+    ok(fragment != NULL, "got %p\n", fragment);
+
+    fragment2 = (void*)0xdeadbeef;
+    context2 = (void*)0xdeadbeef;
+    hr = IDWriteFontFileStream_ReadFileFragment(stream, &fragment2, 0, filesize, &context2);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(context2 == NULL, "got %p\n", context2);
+    ok(fragment == fragment2, "got %p, %p\n", fragment, fragment2);
+
+    IDWriteFontFileStream_ReleaseFileFragment(stream, context);
+    IDWriteFontFileStream_ReleaseFileFragment(stream, context2);
+
+    /* fragment is released, try again */
+    fragment = (void*)0xdeadbeef;
+    context = (void*)0xdeadbeef;
+    hr = IDWriteFontFileStream_ReadFileFragment(stream, &fragment, 0, filesize, &context);
+    ok(hr == S_OK, "got 0x%08x\n", hr);
+    ok(context == NULL, "got %p\n", context);
+    ok(fragment == fragment2, "got %p, %p\n", fragment, fragment2);
+    IDWriteFontFileStream_ReleaseFileFragment(stream, context);
+
+    IDWriteFontFileStream_Release(stream);
+    IDWriteLocalFontFileLoader_Release(localloader);
+    IDWriteFactory_Release(factory);
+    DeleteFileW(test_fontfile);
+}
+
 START_TEST(font)
 {
     IDWriteFactory *factory;
@@ -2351,6 +2564,8 @@ START_TEST(font)
     test_GetFaceNames();
     test_TryGetFontTable();
     test_ConvertFontToLOGFONT();
+    test_CreateStreamFromKey();
+    test_ReadFileFragment();
 
     IDWriteFactory_Release(factory);
 }
diff --git a/dlls/gdi32/font.c b/dlls/gdi32/font.c
index af3ea5b..8f52053 100644
--- a/dlls/gdi32/font.c
+++ b/dlls/gdi32/font.c
@@ -81,16 +81,6 @@ static inline INT height_to_LP( DC *dc, INT height )
     return GDI_ROUND( (double)height * fabs( dc->xformVport2World.eM22 ));
 }
 
-static inline INT INTERNAL_XWSTODS(DC *dc, INT width)
-{
-    POINT pt[2];
-    pt[0].x = pt[0].y = 0;
-    pt[1].x = width;
-    pt[1].y = 0;
-    LPtoDP(dc->hSelf, pt, 2);
-    return pt[1].x - pt[0].x;
-}
-
 static inline INT INTERNAL_YWSTODS(DC *dc, INT height)
 {
     POINT pt[2];
@@ -1660,8 +1650,7 @@ UINT WINAPI GetOutlineTextMetricsW(
         output->otmsStrikeoutPosition    = height_to_LP( dc, output->otmsStrikeoutPosition);
         output->otmsUnderscoreSize       = height_to_LP( dc, output->otmsUnderscoreSize);
         output->otmsUnderscorePosition   = height_to_LP( dc, output->otmsUnderscorePosition);
-#undef WDPTOLP
-#undef HDPTOLP
+
         if(output != lpOTM)
         {
             memcpy(lpOTM, output, cbData);
diff --git a/dlls/gdi32/freetype.c b/dlls/gdi32/freetype.c
index 924f5f3..f1af5d6 100644
--- a/dlls/gdi32/freetype.c
+++ b/dlls/gdi32/freetype.c
@@ -529,10 +529,6 @@ static const WCHAR system_link[] = {'S','o','f','t','w','a','r','e','\\','M','i'
                                     'C','u','r','r','e','n','t','V','e','r','s','i','o','n','\\','F','o','n','t','L','i','n','k','\\',
                                     'S','y','s','t','e','m','L','i','n','k',0};
 
-static const WCHAR internal_system_link[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
-                                    'F','o','n','t','L','i','n','k','\\',
-                                    'S','y','s','t','e','m','L','i','n','k',0};
-
 /****************************************
  *   Notes on .fon files
  *
@@ -4460,7 +4456,7 @@ typedef struct {
 
 static LONG load_VDMX(GdiFont *font, LONG height)
 {
-    WORD hdr[3], tmp;
+    WORD hdr[3];
     VDMX_group group;
     BYTE devXRatio, devYRatio;
     USHORT numRecs, numRatios;
@@ -4468,7 +4464,7 @@ static LONG load_VDMX(GdiFont *font, LONG height)
     LONG ppem = 0;
     int i;
 
-    result = get_font_data(font, MS_VDMX_TAG, 0, hdr, 6);
+    result = get_font_data(font, MS_VDMX_TAG, 0, hdr, sizeof(hdr));
 
     if(result == GDI_ERROR) /* no vdmx table present, use linear scaling */
 	return ppem;
@@ -4499,8 +4495,10 @@ static LONG load_VDMX(GdiFont *font, LONG height)
 	    devYRatio >= ratio.yStartRatio &&
 	    devYRatio <= ratio.yEndRatio))
 	    {
+		WORD tmp;
+
 		offset = (3 * 2) + (numRatios * 4) + (i * 2);
-		get_font_data(font, MS_VDMX_TAG, offset, &tmp, 2);
+		get_font_data(font, MS_VDMX_TAG, offset, &tmp, sizeof(tmp));
 		offset = GET_BE_WORD(tmp);
 		break;
 	    }
@@ -4508,7 +4506,7 @@ static LONG load_VDMX(GdiFont *font, LONG height)
 
     if(offset == -1) return 0;
 
-    if(get_font_data(font, MS_VDMX_TAG, offset, &group, 4) != GDI_ERROR) {
+    if(get_font_data(font, MS_VDMX_TAG, offset, &group, sizeof(group)) != GDI_ERROR) {
 	USHORT recs;
 	BYTE startsz, endsz;
 	WORD *vTable;
diff --git a/dlls/ieframe/ieframe.h b/dlls/ieframe/ieframe.h
index 93be1fe..cdfdf21 100644
--- a/dlls/ieframe/ieframe.h
+++ b/dlls/ieframe/ieframe.h
@@ -273,6 +273,7 @@ HRESULT dochost_object_available(DocHost*,IUnknown*) DECLSPEC_HIDDEN;
 void set_doc_state(DocHost*,READYSTATE) DECLSPEC_HIDDEN;
 void deactivate_document(DocHost*) DECLSPEC_HIDDEN;
 void create_doc_view_hwnd(DocHost*) DECLSPEC_HIDDEN;
+void on_commandstate_change(DocHost*,LONG,VARIANT_BOOL) DECLSPEC_HIDDEN;
 
 #define WM_DOCHOSTTASK (WM_USER+0x300)
 void push_dochost_task(DocHost*,task_header_t*,task_proc_t,task_destr_t,BOOL) DECLSPEC_HIDDEN;
diff --git a/dlls/ieframe/navigate.c b/dlls/ieframe/navigate.c
index f3e0d0d..d1a9a50 100644
--- a/dlls/ieframe/navigate.c
+++ b/dlls/ieframe/navigate.c
@@ -773,6 +773,27 @@ static void doc_navigate_task_destr(task_header_t *t)
     heap_free(task);
 }
 
+void on_commandstate_change(DocHost *doc_host, LONG command, VARIANT_BOOL enable)
+{
+    DISPPARAMS dispparams;
+    VARIANTARG params[2];
+
+    TRACE("command=%d enable=%d\n", command, enable);
+
+    dispparams.cArgs = 2;
+    dispparams.cNamedArgs = 0;
+    dispparams.rgdispidNamedArgs = NULL;
+    dispparams.rgvarg = params;
+
+    V_VT(params) = VT_BOOL;
+    V_BOOL(params) = enable;
+
+    V_VT(params+1) = VT_I4;
+    V_I4(params+1) = command;
+
+    call_sink(doc_host->cps.wbe2, DISPID_COMMANDSTATECHANGE, &dispparams);
+}
+
 static void doc_navigate_proc(DocHost *This, task_header_t *t)
 {
     task_doc_navigate_t *task = (task_doc_navigate_t*)t;
@@ -876,6 +897,9 @@ static HRESULT navigate_bsc(DocHost *This, BindStatusCallback *bsc, IMoniker *mo
         return S_OK;
     }
 
+    on_commandstate_change(This, CSC_NAVIGATEBACK, VARIANT_FALSE);
+    on_commandstate_change(This, CSC_NAVIGATEFORWARD, VARIANT_FALSE);
+
     if(This->document)
         deactivate_document(This);
 
@@ -1069,6 +1093,17 @@ static HRESULT navigate_history(DocHost *This, unsigned travellog_pos)
         return E_NOTIMPL;
     }
 
+    if (travellog_pos < This->travellog.position)
+    {
+        on_commandstate_change(This, CSC_NAVIGATEBACK, VARIANT_FALSE);
+        on_commandstate_change(This, CSC_NAVIGATEFORWARD, VARIANT_TRUE);
+    }
+    else if (travellog_pos > This->travellog.position)
+    {
+        on_commandstate_change(This, CSC_NAVIGATEBACK, VARIANT_TRUE);
+        on_commandstate_change(This, CSC_NAVIGATEFORWARD, VARIANT_FALSE);
+    }
+
     This->travellog.loading_pos = travellog_pos;
     entry = This->travellog.log + This->travellog.loading_pos;
 
diff --git a/dlls/ieframe/oleobject.c b/dlls/ieframe/oleobject.c
index d611231..e1dd37d 100644
--- a/dlls/ieframe/oleobject.c
+++ b/dlls/ieframe/oleobject.c
@@ -442,6 +442,9 @@ static HRESULT WINAPI OleObject_SetClientSite(IOleObject *iface, LPOLECLIENTSITE
     release_client_site(This);
 
     if(!pClientSite) {
+        on_commandstate_change(&This->doc_host, CSC_NAVIGATEBACK, VARIANT_FALSE);
+        on_commandstate_change(&This->doc_host, CSC_NAVIGATEFORWARD, VARIANT_FALSE);
+
         if(This->doc_host.document)
             deactivate_document(&This->doc_host);
         return S_OK;
diff --git a/dlls/ieframe/tests/webbrowser.c b/dlls/ieframe/tests/webbrowser.c
index fa37169..7f45182 100644
--- a/dlls/ieframe/tests/webbrowser.c
+++ b/dlls/ieframe/tests/webbrowser.c
@@ -96,7 +96,9 @@ DEFINE_EXPECT(Invoke_DOWNLOADBEGIN);
 DEFINE_EXPECT(Invoke_BEFORENAVIGATE2);
 DEFINE_EXPECT(Invoke_SETSECURELOCKICON);
 DEFINE_EXPECT(Invoke_FILEDOWNLOAD);
-DEFINE_EXPECT(Invoke_COMMANDSTATECHANGE);
+DEFINE_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+DEFINE_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+DEFINE_EXPECT(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
 DEFINE_EXPECT(Invoke_DOWNLOADCOMPLETE);
 DEFINE_EXPECT(Invoke_ONMENUBAR);
 DEFINE_EXPECT(Invoke_ONADDRESSBAR);
@@ -145,7 +147,6 @@ DEFINE_EXPECT(OnFocus);
 DEFINE_EXPECT(GetExternal);
 
 static const WCHAR wszItem[] = {'i','t','e','m',0};
-static const WCHAR emptyW[] = {0};
 
 static VARIANT_BOOL exvb;
 
@@ -156,7 +157,8 @@ static BOOL is_downloading, is_first_load, use_container_olecmd, test_close, is_
 static HRESULT hr_dochost_TranslateAccelerator = E_NOTIMPL;
 static HRESULT hr_site_TranslateAccelerator = E_NOTIMPL;
 static const char *current_url;
-static int wb_version;
+static int wb_version, expect_navigate_back_enable, set_navigate_back_enable, expect_navigate_forward_enable,
+           set_navigate_forward_enable, expect_update_commands_enable, set_update_commands_enable;
 
 #define DWL_EXPECT_BEFORE_NAVIGATE  0x01
 #define DWL_FROM_PUT_HREF           0x02
@@ -878,15 +880,31 @@ static HRESULT WINAPI WebBrowserEvents2_Invoke(IDispatch *iface, DISPID dispIdMe
         break;
 
     case DISPID_COMMANDSTATECHANGE:
-        CHECK_EXPECT2(Invoke_COMMANDSTATECHANGE);
-
         ok(pDispParams->rgvarg != NULL, "rgvarg == NULL\n");
         ok(pDispParams->cArgs == 2, "cArgs=%d, expected 2\n", pDispParams->cArgs);
 
         ok(V_VT(pDispParams->rgvarg) == VT_BOOL, "V_VT(pDispParams->rgvarg) = %d\n", V_VT(pDispParams->rgvarg));
         ok(V_VT(pDispParams->rgvarg+1) == VT_I4, "V_VT(pDispParams->rgvarg+1) = %d\n", V_VT(pDispParams->rgvarg+1));
+        ok(V_I4(pDispParams->rgvarg+1) == CSC_NAVIGATEFORWARD ||
+           V_I4(pDispParams->rgvarg+1) == CSC_NAVIGATEBACK ||
+           V_I4(pDispParams->rgvarg+1) == CSC_UPDATECOMMANDS,
+           "V_I4(pDispParams->rgvarg+1) = %x\n", V_I4(pDispParams->rgvarg+1));
 
-        /* TODO: Check args */
+        if (V_I4(pDispParams->rgvarg+1) == CSC_NAVIGATEFORWARD)
+        {
+            CHECK_EXPECT2(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+            set_navigate_forward_enable = V_BOOL(pDispParams->rgvarg);
+        }
+        else if (V_I4(pDispParams->rgvarg+1) == CSC_NAVIGATEBACK)
+        {
+            CHECK_EXPECT2(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+            set_navigate_back_enable = V_BOOL(pDispParams->rgvarg);
+        }
+        else if (V_I4(pDispParams->rgvarg+1) == CSC_UPDATECOMMANDS)
+        {
+            todo_wine CHECK_EXPECT2(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
+            set_update_commands_enable = V_BOOL(pDispParams->rgvarg);
+        }
         break;
 
     case DISPID_DOWNLOADCOMPLETE:
@@ -1914,7 +1932,18 @@ static void test_ClientSite(IWebBrowser2 *unk, IOleClientSite *client, BOOL stop
     }else if(stop_download) {
         SET_EXPECT(Invoke_DOWNLOADCOMPLETE);
         if (use_container_olecmd) SET_EXPECT(Exec_SETDOWNLOADSTATE_0);
-        SET_EXPECT(Invoke_COMMANDSTATECHANGE);
+
+        expect_navigate_back_enable = 0;
+        set_navigate_back_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+
+        expect_navigate_forward_enable = 0;
+        set_navigate_forward_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+
+        expect_update_commands_enable = 0;
+        set_update_commands_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
     }else {
         SET_EXPECT(Invoke_STATUSTEXTCHANGE);
         SET_EXPECT(Invoke_PROGRESSCHANGE);
@@ -1931,7 +1960,18 @@ static void test_ClientSite(IWebBrowser2 *unk, IOleClientSite *client, BOOL stop
     }else if(stop_download) {
         todo_wine CHECK_CALLED(Invoke_DOWNLOADCOMPLETE);
         if (use_container_olecmd) todo_wine CHECK_CALLED(Exec_SETDOWNLOADSTATE_0);
-        todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE);
+
+        CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+        ok(expect_navigate_back_enable == set_navigate_back_enable,
+           "got %d\n", set_navigate_back_enable);
+
+        CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+        ok(expect_navigate_forward_enable == set_navigate_forward_enable,
+           "got %d\n", set_navigate_forward_enable);
+
+        todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
+        todo_wine ok(expect_update_commands_enable == set_update_commands_enable,
+           "got %d\n", set_update_commands_enable);
     }else {
         CLEAR_CALLED(Invoke_STATUSTEXTCHANGE); /* Called by IE9 */
         CLEAR_CALLED(Invoke_PROGRESSCHANGE);
@@ -2650,7 +2690,15 @@ static void test_Navigate2(IWebBrowser2 *webbrowser, const char *nav_url)
         SET_EXPECT(Invoke_SETSECURELOCKICON);
         SET_EXPECT(Invoke_FILEDOWNLOAD);
         if (use_container_olecmd) SET_EXPECT(Exec_SETDOWNLOADSTATE_0);
-        SET_EXPECT(Invoke_COMMANDSTATECHANGE);
+
+        expect_navigate_back_enable = 0;
+        set_navigate_back_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+
+        expect_navigate_forward_enable = 0;
+        set_navigate_forward_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+
         SET_EXPECT(EnableModeless_TRUE);
         if (!use_container_olecmd) SET_EXPECT(Invoke_DOWNLOADCOMPLETE);
         if (is_file) SET_EXPECT(Invoke_PROGRESSCHANGE);
@@ -2682,7 +2730,15 @@ static void test_Navigate2(IWebBrowser2 *webbrowser, const char *nav_url)
         if (use_container_olecmd) todo_wine CHECK_CALLED(Exec_SETPROGRESSPOS);
         todo_wine CHECK_CALLED(Invoke_SETSECURELOCKICON);
         todo_wine CHECK_CALLED(Invoke_FILEDOWNLOAD);
-        todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE);
+
+        CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+        ok(expect_navigate_back_enable == set_navigate_back_enable,
+           "got %d\n", set_navigate_back_enable);
+
+        CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+        ok(expect_navigate_forward_enable == set_navigate_forward_enable,
+           "got %d\n", set_navigate_forward_enable);
+
         if (use_container_olecmd) todo_wine CHECK_CALLED(Exec_SETDOWNLOADSTATE_0);
         CHECK_CALLED(EnableModeless_TRUE);
         if (is_file) todo_wine CHECK_CALLED(Invoke_PROGRESSCHANGE);
@@ -2804,7 +2860,19 @@ static void test_download(DWORD flags)
     SET_EXPECT(Invoke_SETSECURELOCKICON);
     SET_EXPECT(Invoke_282);
     SET_EXPECT(EnableModeless_FALSE);
-    SET_EXPECT(Invoke_COMMANDSTATECHANGE);
+
+    expect_navigate_back_enable = 0;
+    set_navigate_back_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+
+    expect_navigate_forward_enable = 0;
+    set_navigate_forward_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+
+    expect_update_commands_enable = 0;
+    set_update_commands_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
+
     SET_EXPECT(Invoke_STATUSTEXTCHANGE);
     SET_EXPECT(SetStatusText);
     SET_EXPECT(EnableModeless_TRUE);
@@ -2851,7 +2919,7 @@ static void test_download(DWORD flags)
         todo_wine CHECK_CALLED(EnableModeless_FALSE);
     else
         CLEAR_CALLED(EnableModeless_FALSE); /* IE 8 */
-    CLEAR_CALLED(Invoke_COMMANDSTATECHANGE);
+    CLEAR_CALLED(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
     todo_wine CHECK_CALLED(Invoke_STATUSTEXTCHANGE);
     todo_wine CHECK_CALLED(SetStatusText);
     if(is_first_load)
@@ -3010,23 +3078,40 @@ static void test_put_href(IWebBrowser2 *unk, const char *url)
     test_ready_state(READYSTATE_COMPLETE);
 }
 
-static void test_go_back(IWebBrowser2 *wb, const char *back_url)
+static void test_go_back(IWebBrowser2 *wb, const char *back_url, int back_enable, int forward_enable, int forward_todo)
 {
     HRESULT hres;
 
     current_url = back_url;
 
     SET_EXPECT(Invoke_BEFORENAVIGATE2);
-    SET_EXPECT(Invoke_COMMANDSTATECHANGE);
+
+    expect_navigate_back_enable = back_enable;
+    set_navigate_back_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+
+    expect_navigate_forward_enable = forward_enable;
+    set_navigate_forward_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+
     SET_EXPECT(Invoke_PROPERTYCHANGE);
     hres = IWebBrowser2_GoBack(wb);
     ok(hres == S_OK, "GoBack failed: %08x\n", hres);
     CHECK_CALLED(Invoke_BEFORENAVIGATE2);
-    todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE);
+
+    CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+    ok(expect_navigate_back_enable == set_navigate_back_enable, "got %d\n", set_navigate_back_enable);
+
+    CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+    if (forward_todo)
+        todo_wine ok(expect_navigate_forward_enable == set_navigate_forward_enable, "got %d\n", set_navigate_forward_enable);
+    else
+        ok(expect_navigate_forward_enable == set_navigate_forward_enable, "got %d\n", set_navigate_forward_enable);
+
     CLEAR_CALLED(Invoke_PROPERTYCHANGE); /* called by IE11 */
 }
 
-static void test_go_forward(IWebBrowser2 *wb, const char *forward_url)
+static void test_go_forward(IWebBrowser2 *wb, const char *forward_url, int back_enable, int forward_enable)
 {
     HRESULT hres;
 
@@ -3034,11 +3119,26 @@ static void test_go_forward(IWebBrowser2 *wb, const char *forward_url)
     dwl_flags |= DWL_FROM_GOFORWARD;
 
     SET_EXPECT(Invoke_BEFORENAVIGATE2);
-    SET_EXPECT(Invoke_COMMANDSTATECHANGE);
+
+    expect_navigate_back_enable = back_enable;
+    set_navigate_back_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+
+    expect_navigate_forward_enable = forward_enable;
+    set_navigate_forward_enable = 0xdead;
+    SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+
     hres = IWebBrowser2_GoForward(wb);
     ok(hres == S_OK, "GoForward failed: %08x\n", hres);
     CHECK_CALLED(Invoke_BEFORENAVIGATE2);
-    todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE);
+
+    CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+    ok(expect_navigate_back_enable == set_navigate_back_enable,
+       "got %d\n", set_navigate_back_enable);
+
+    CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+    ok(expect_navigate_forward_enable == set_navigate_forward_enable,
+       "got %d\n", set_navigate_forward_enable);
 }
 
 static void test_QueryInterface(IWebBrowser2 *wb)
@@ -3389,7 +3489,18 @@ static void test_Close(IWebBrowser2 *wb, BOOL do_download)
     SET_EXPECT(OnInPlaceDeactivate);
     SET_EXPECT(Invoke_STATUSTEXTCHANGE);
     if(!do_download) {
-        SET_EXPECT(Invoke_COMMANDSTATECHANGE);
+        expect_navigate_back_enable = 0;
+        set_navigate_back_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+
+        expect_navigate_forward_enable = 0;
+        set_navigate_forward_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+
+        expect_update_commands_enable = 0;
+        set_update_commands_enable = 0xdead;
+        SET_EXPECT(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
+
         SET_EXPECT(Invoke_DOWNLOADCOMPLETE);
     }
     hres = IOleObject_Close(oo, OLECLOSE_NOSAVE);
@@ -3401,7 +3512,18 @@ static void test_Close(IWebBrowser2 *wb, BOOL do_download)
     CHECK_CALLED(OnInPlaceDeactivate);
     CLEAR_CALLED(Invoke_STATUSTEXTCHANGE); /* Called by IE9 */
     if(!do_download) {
-        todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE);
+        CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEBACK);
+        ok(expect_navigate_back_enable == set_navigate_back_enable,
+           "got %d\n", set_navigate_back_enable);
+
+        CHECK_CALLED(Invoke_COMMANDSTATECHANGE_NAVIGATEFORWARD);
+        ok(expect_navigate_forward_enable == set_navigate_forward_enable,
+           "got %d\n", set_navigate_forward_enable);
+
+        todo_wine CHECK_CALLED(Invoke_COMMANDSTATECHANGE_UPDATECOMMANDS);
+        todo_wine ok(expect_update_commands_enable == set_update_commands_enable,
+           "got %d\n", set_update_commands_enable);
+
         todo_wine CHECK_CALLED(Invoke_DOWNLOADCOMPLETE);
     }
 
@@ -3494,11 +3616,19 @@ static void test_WebBrowser(BOOL do_download, BOOL do_close)
             test_download(DWL_FROM_PUT_HREF|DWL_HTTP);
 
             trace("GoBack...\n");
-            test_go_back(webbrowser, "http://test.winehq.org/tests/hello.html");
+            test_go_back(webbrowser, "http://test.winehq.org/tests/hello.html", 0, 0, 1);
+            test_download(DWL_FROM_GOBACK|DWL_HTTP);
+
+            trace("GoForward...\n");
+            test_go_forward(webbrowser, "http://test.winehq.org/tests/winehq_snapshot/", -1, 0);
+            test_download(DWL_FROM_GOFORWARD|DWL_HTTP);
+
+            trace("GoBack...\n");
+            test_go_back(webbrowser, "http://test.winehq.org/tests/hello.html", 0, -1, 0);
             test_download(DWL_FROM_GOBACK|DWL_HTTP);
 
             trace("GoForward...\n");
-            test_go_forward(webbrowser, "http://test.winehq.org/tests/winehq_snapshot/");
+            test_go_forward(webbrowser, "http://test.winehq.org/tests/winehq_snapshot/", -1, 0);
             test_download(DWL_FROM_GOFORWARD|DWL_HTTP);
         }else {
             trace("Navigate2 repeated with the same URL...\n");
diff --git a/dlls/jscript/engine.c b/dlls/jscript/engine.c
index 9c6acb3..de60755 100644
--- a/dlls/jscript/engine.c
+++ b/dlls/jscript/engine.c
@@ -398,11 +398,6 @@ static HRESULT disp_get_id(script_ctx_t *ctx, IDispatch *disp, const WCHAR *name
     return hres;
 }
 
-static inline BOOL var_is_null(const VARIANT *v)
-{
-    return V_VT(v) == VT_NULL || (V_VT(v) == VT_DISPATCH && !V_DISPATCH(v));
-}
-
 static HRESULT disp_cmp(IDispatch *disp1, IDispatch *disp2, BOOL *ret)
 {
     IObjectIdentity *identity;
diff --git a/dlls/jscript/jsregexp.c b/dlls/jscript/jsregexp.c
index d6602f4..c39e3a1 100644
--- a/dlls/jscript/jsregexp.c
+++ b/dlls/jscript/jsregexp.c
@@ -58,8 +58,6 @@ static const WCHAR idx7W[] = {'$','7',0};
 static const WCHAR idx8W[] = {'$','8',0};
 static const WCHAR idx9W[] = {'$','9',0};
 
-static const WCHAR emptyW[] = {0};
-
 static inline RegExpInstance *regexp_from_vdisp(vdisp_t *vdisp)
 {
     return (RegExpInstance*)vdisp->u.jsdisp;
diff --git a/dlls/mciseq/mcimidi.c b/dlls/mciseq/mcimidi.c
index 4fcfb48..62b3192 100644
--- a/dlls/mciseq/mcimidi.c
+++ b/dlls/mciseq/mcimidi.c
@@ -683,7 +683,7 @@ static DWORD MIDI_mciOpen(WINE_MCIMIDI* wmm, DWORD dwFlags, LPMCI_OPEN_PARMSW lp
 
     if (dwFlags & MCI_OPEN_ELEMENT) {
 	TRACE("MCI_OPEN_ELEMENT %s!\n", debugstr_w(lpParms->lpstrElementName));
-	if (lpParms->lpstrElementName && strlenW(lpParms->lpstrElementName) > 0) {
+        if (lpParms->lpstrElementName && lpParms->lpstrElementName[0]) {
 	    wmm->hFile = mmioOpenW((LPWSTR)lpParms->lpstrElementName, NULL,
 				   MMIO_ALLOCBUF | MMIO_READ | MMIO_DENYWRITE);
 	    if (wmm->hFile == 0) {
diff --git a/dlls/mscms/tests/profile.c b/dlls/mscms/tests/profile.c
index fd35193..012a7dc 100644
--- a/dlls/mscms/tests/profile.c
+++ b/dlls/mscms/tests/profile.c
@@ -1364,10 +1364,10 @@ START_TEST(profile)
     /* See if we can find the standard color profile */
     ret = GetSystemDirectoryA( profilefile1, sizeof(profilefile1) );
     ok( ret > 0, "GetSystemDirectoryA() returns %d, LastError = %d\n", ret, GetLastError());
-    ok( lstrlenA(profilefile1) > 0 && lstrlenA(profilefile1) < MAX_PATH, 
+    ok(profilefile1[0] && lstrlenA(profilefile1) < MAX_PATH,
         "Expected length between 0 and MAX_PATH, got %d\n", lstrlenA(profilefile1));
     MultiByteToWideChar(CP_ACP, 0, profilefile1, -1, profilefile1W, MAX_PATH);
-    ok( lstrlenW(profilefile1W) > 0 && lstrlenW(profilefile1W) < MAX_PATH, 
+    ok(profilefile1W[0] && lstrlenW(profilefile1W) < MAX_PATH,
         "Expected length between 0 and MAX_PATH, got %d\n", lstrlenW(profilefile1W));
     lstrcpyA(profilefile2, profilefile1);
     lstrcpyW(profilefile2W, profilefile1W);
diff --git a/dlls/mscoree/mscoree_main.c b/dlls/mscoree/mscoree_main.c
index 7534108..c84b25f 100644
--- a/dlls/mscoree/mscoree_main.c
+++ b/dlls/mscoree/mscoree_main.c
@@ -675,7 +675,7 @@ static BOOL install_wine_mono(void)
     LONG len;
     BOOL ret;
 
-    static const char* mono_version = "4.5.2";
+    static const char* mono_version = "4.5.4";
     static const char* mono_product_code = "{E45D8920-A758-4088-B6C6-31DBB276992E}";
 
     static const WCHAR controlW[] = {'\\','c','o','n','t','r','o','l','.','e','x','e',0};
diff --git a/dlls/mshtml/Makefile.in b/dlls/mshtml/Makefile.in
index 6c5ced1..b442bd8 100644
--- a/dlls/mshtml/Makefile.in
+++ b/dlls/mshtml/Makefile.in
@@ -15,7 +15,6 @@ C_SRCS = \
 	htmlcurstyle.c \
 	htmldoc.c \
 	htmlelem.c \
-	htmlelem3.c \
 	htmlelemcol.c \
 	htmlembed.c \
 	htmlevent.c \
diff --git a/dlls/mshtml/htmldoc.c b/dlls/mshtml/htmldoc.c
index 60ee739..edc91e6 100644
--- a/dlls/mshtml/htmldoc.c
+++ b/dlls/mshtml/htmldoc.c
@@ -31,6 +31,7 @@
 #include "ole2.h"
 #include "perhist.h"
 #include "mshtmdid.h"
+#include "mshtmcid.h"
 
 #include "wine/debug.h"
 
@@ -1095,6 +1096,43 @@ static HRESULT WINAPI HTMLDocument_clear(IHTMLDocument2 *iface)
     return S_OK;
 }
 
+static const WCHAR fontnameW[] =
+    {'f','o','n','t','n','a','m','e',0};
+static const WCHAR insertorderedlistW[] =
+    {'i','n','s','e','r','t','o','r','d','e','r','e','d','l','i','s','t',0};
+static const WCHAR insertunorderedlistW[] =
+    {'i','n','s','e','r','t','u','n','o','r','d','e','r','e','d','l','i','s','t',0};
+static const WCHAR outdentW[] =
+    {'o','u','t','d','e','n','t',0};
+static const WCHAR respectvisibilityindesignW[] =
+    {'r','e','s','p','e','c','t','v','i','s','i','b','i','l','i','t','y','i','n','d','e','s','i','g','n',0};
+
+static const struct {
+    const WCHAR *name;
+    OLECMDID id;
+}command_names[] = {
+    {fontnameW, IDM_FONTNAME},
+    {insertorderedlistW, IDM_ORDERLIST},
+    {insertunorderedlistW, IDM_UNORDERLIST},
+    {outdentW, IDM_OUTDENT},
+    {respectvisibilityindesignW, IDM_RESPECTVISIBILITY_INDESIGN}
+};
+
+static BOOL cmdid_from_string(const WCHAR *str, OLECMDID *cmdid)
+{
+    int i;
+
+    for(i = 0; i < sizeof(command_names)/sizeof(*command_names); i++) {
+        if(!strcmpiW(command_names[i].name, str)) {
+            *cmdid = command_names[i].id;
+            return TRUE;
+        }
+    }
+
+    FIXME("Unknown command %s\n", debugstr_w(str));
+    return FALSE;
+}
+
 static HRESULT WINAPI HTMLDocument_queryCommandSupported(IHTMLDocument2 *iface, BSTR cmdID,
                                                         VARIANT_BOOL *pfRet)
 {
@@ -1147,8 +1185,28 @@ static HRESULT WINAPI HTMLDocument_execCommand(IHTMLDocument2 *iface, BSTR cmdID
                                 VARIANT_BOOL showUI, VARIANT value, VARIANT_BOOL *pfRet)
 {
     HTMLDocument *This = impl_from_IHTMLDocument2(iface);
-    FIXME("(%p)->(%s %x %s %p)\n", This, debugstr_w(cmdID), showUI, debugstr_variant(&value), pfRet);
-    return E_NOTIMPL;
+    OLECMDID cmdid;
+    VARIANT ret;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s %x %s %p)\n", This, debugstr_w(cmdID), showUI, debugstr_variant(&value), pfRet);
+
+    if(!cmdid_from_string(cmdID, &cmdid))
+        return OLECMDERR_E_NOTSUPPORTED;
+
+    V_VT(&ret) = VT_EMPTY;
+    hres = IOleCommandTarget_Exec(&This->IOleCommandTarget_iface, &CGID_MSHTML, cmdid,
+            showUI ? 0 : OLECMDEXECOPT_DONTPROMPTUSER, &value, &ret);
+    if(FAILED(hres))
+        return hres;
+
+    if(V_VT(&ret) != VT_EMPTY) {
+        FIXME("Handle ret %s\n", debugstr_variant(&ret));
+        VariantClear(&ret);
+    }
+
+    *pfRet = VARIANT_TRUE;
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLDocument_execCommandShowHelp(IHTMLDocument2 *iface, BSTR cmdID,
diff --git a/dlls/mshtml/htmlelem.c b/dlls/mshtml/htmlelem.c
index 2c82c4a..1140776 100644
--- a/dlls/mshtml/htmlelem.c
+++ b/dlls/mshtml/htmlelem.c
@@ -3034,6 +3034,650 @@ static const IHTMLElement2Vtbl HTMLElement2Vtbl = {
     HTMLElement2_getElementsByTagName,
 };
 
+static inline HTMLElement *impl_from_IHTMLElement3(IHTMLElement3 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLElement, IHTMLElement3_iface);
+}
+
+static HRESULT WINAPI HTMLElement3_QueryInterface(IHTMLElement3 *iface,
+                                                  REFIID riid, void **ppv)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IHTMLElement_QueryInterface(&This->IHTMLElement_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLElement3_AddRef(IHTMLElement3 *iface)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IHTMLElement_AddRef(&This->IHTMLElement_iface);
+}
+
+static ULONG WINAPI HTMLElement3_Release(IHTMLElement3 *iface)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IHTMLElement_Release(&This->IHTMLElement_iface);
+}
+
+static HRESULT WINAPI HTMLElement3_GetTypeInfoCount(IHTMLElement3 *iface, UINT *pctinfo)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->node.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLElement3_GetTypeInfo(IHTMLElement3 *iface, UINT iTInfo,
+                                               LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IDispatchEx_GetTypeInfo(&This->node.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLElement3_GetIDsOfNames(IHTMLElement3 *iface, REFIID riid,
+                                                LPOLESTR *rgszNames, UINT cNames,
+                                                LCID lcid, DISPID *rgDispId)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IDispatchEx_GetIDsOfNames(&This->node.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLElement3_Invoke(IHTMLElement3 *iface, DISPID dispIdMember,
+                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
+                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    return IDispatchEx_Invoke(&This->node.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLElement3_mergeAttributes(IHTMLElement3 *iface, IHTMLElement *mergeThis, VARIANT *pvarFlags)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p %p)\n", This, mergeThis, pvarFlags);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_isMultiLine(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_canHaveHTML(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onlayoutcomplete(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onlayoutcomplete(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onpage(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onpage(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_inflateBlock(IHTMLElement3 *iface, VARIANT_BOOL v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_inflateBlock(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onbeforedeactivate(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onbeforedeactivate(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_setActive(IHTMLElement3 *iface)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_contentEditable(IHTMLElement3 *iface, BSTR v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    nsresult nsres;
+    nsAString str;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+
+    nsAString_InitDepend(&str, v);
+    nsres = nsIDOMHTMLElement_SetContentEditable(This->nselem, &str);
+    nsAString_Finish(&str);
+
+    if (NS_FAILED(nsres)){
+        ERR("SetContentEditable(%s) failed!\n", debugstr_w(v));
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI HTMLElement3_get_contentEditable(IHTMLElement3 *iface, BSTR *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    nsresult nsres;
+    nsAString str;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    nsAString_Init(&str, NULL);
+    nsres = nsIDOMHTMLElement_GetContentEditable(This->nselem, &str);
+    return return_nsstr(nsres, &str, p);
+}
+
+static HRESULT WINAPI HTMLElement3_get_isContentEditable(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_hideFocus(IHTMLElement3 *iface, VARIANT_BOOL v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%x)\n", This, v);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_hideFocus(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static const WCHAR disabledW[] = {'d','i','s','a','b','l','e','d',0};
+
+static HRESULT WINAPI HTMLElement3_put_disabled(IHTMLElement3 *iface, VARIANT_BOOL v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    VARIANT *var;
+    HRESULT hres;
+
+    TRACE("(%p)->(%x)\n", This, v);
+
+    if(This->node.vtbl->put_disabled)
+        return This->node.vtbl->put_disabled(&This->node, v);
+
+    hres = dispex_get_dprop_ref(&This->node.dispex, disabledW, TRUE, &var);
+    if(FAILED(hres))
+        return hres;
+
+    VariantClear(var);
+    V_VT(var) = VT_BOOL;
+    V_BOOL(var) = v;
+    return S_OK;
+}
+
+static HRESULT WINAPI HTMLElement3_get_disabled(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    VARIANT *var;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(This->node.vtbl->get_disabled)
+        return This->node.vtbl->get_disabled(&This->node, p);
+
+    hres = dispex_get_dprop_ref(&This->node.dispex, disabledW, FALSE, &var);
+    if(hres == DISP_E_UNKNOWNNAME) {
+        *p = VARIANT_FALSE;
+        return S_OK;
+    }
+    if(FAILED(hres))
+        return hres;
+
+    if(V_VT(var) != VT_BOOL) {
+        FIXME("value is %s\n", debugstr_variant(var));
+        return E_NOTIMPL;
+    }
+
+    *p = V_BOOL(var);
+    return S_OK;
+}
+
+static HRESULT WINAPI HTMLElement3_get_isDisabled(IHTMLElement3 *iface, VARIANT_BOOL *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onmove(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onmove(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_oncontrolselect(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_oncontrolselect(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_fireEvent(IHTMLElement3 *iface, BSTR bstrEventName,
+        VARIANT *pvarEventObject, VARIANT_BOOL *pfCancelled)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+
+    TRACE("(%p)->(%s %s %p)\n", This, debugstr_w(bstrEventName), debugstr_variant(pvarEventObject),
+          pfCancelled);
+
+    return dispatch_event(&This->node, bstrEventName, pvarEventObject, pfCancelled);
+}
+
+static HRESULT WINAPI HTMLElement3_put_onresizestart(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onresizestart(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onresizeend(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onresizeend(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onmovestart(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onmovestart(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onmoveend(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onmoveend(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onmousecenter(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onmousecenter(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onmouseleave(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onmouseleave(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_onactivate(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_onactivate(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_put_ondeactivate(IHTMLElement3 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_ondeactivate(IHTMLElement3 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_dragDrop(IHTMLElement3 *iface, VARIANT_BOOL *pfRet)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, pfRet);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement3_get_glyphMode(IHTMLElement3 *iface, LONG *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement3(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static const IHTMLElement3Vtbl HTMLElement3Vtbl = {
+    HTMLElement3_QueryInterface,
+    HTMLElement3_AddRef,
+    HTMLElement3_Release,
+    HTMLElement3_GetTypeInfoCount,
+    HTMLElement3_GetTypeInfo,
+    HTMLElement3_GetIDsOfNames,
+    HTMLElement3_Invoke,
+    HTMLElement3_mergeAttributes,
+    HTMLElement3_get_isMultiLine,
+    HTMLElement3_get_canHaveHTML,
+    HTMLElement3_put_onlayoutcomplete,
+    HTMLElement3_get_onlayoutcomplete,
+    HTMLElement3_put_onpage,
+    HTMLElement3_get_onpage,
+    HTMLElement3_put_inflateBlock,
+    HTMLElement3_get_inflateBlock,
+    HTMLElement3_put_onbeforedeactivate,
+    HTMLElement3_get_onbeforedeactivate,
+    HTMLElement3_setActive,
+    HTMLElement3_put_contentEditable,
+    HTMLElement3_get_contentEditable,
+    HTMLElement3_get_isContentEditable,
+    HTMLElement3_put_hideFocus,
+    HTMLElement3_get_hideFocus,
+    HTMLElement3_put_disabled,
+    HTMLElement3_get_disabled,
+    HTMLElement3_get_isDisabled,
+    HTMLElement3_put_onmove,
+    HTMLElement3_get_onmove,
+    HTMLElement3_put_oncontrolselect,
+    HTMLElement3_get_oncontrolselect,
+    HTMLElement3_fireEvent,
+    HTMLElement3_put_onresizestart,
+    HTMLElement3_get_onresizestart,
+    HTMLElement3_put_onresizeend,
+    HTMLElement3_get_onresizeend,
+    HTMLElement3_put_onmovestart,
+    HTMLElement3_get_onmovestart,
+    HTMLElement3_put_onmoveend,
+    HTMLElement3_get_onmoveend,
+    HTMLElement3_put_onmousecenter,
+    HTMLElement3_get_onmousecenter,
+    HTMLElement3_put_onmouseleave,
+    HTMLElement3_get_onmouseleave,
+    HTMLElement3_put_onactivate,
+    HTMLElement3_get_onactivate,
+    HTMLElement3_put_ondeactivate,
+    HTMLElement3_get_ondeactivate,
+    HTMLElement3_dragDrop,
+    HTMLElement3_get_glyphMode
+};
+
+static inline HTMLElement *impl_from_IHTMLElement4(IHTMLElement4 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLElement, IHTMLElement4_iface);
+}
+
+static HRESULT WINAPI HTMLElement4_QueryInterface(IHTMLElement4 *iface,
+        REFIID riid, void **ppv)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IHTMLElement_QueryInterface(&This->IHTMLElement_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLElement4_AddRef(IHTMLElement4 *iface)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IHTMLElement_AddRef(&This->IHTMLElement_iface);
+}
+
+static ULONG WINAPI HTMLElement4_Release(IHTMLElement4 *iface)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IHTMLElement_Release(&This->IHTMLElement_iface);
+}
+
+static HRESULT WINAPI HTMLElement4_GetTypeInfoCount(IHTMLElement4 *iface, UINT *pctinfo)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->node.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLElement4_GetTypeInfo(IHTMLElement4 *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IDispatchEx_GetTypeInfo(&This->node.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLElement4_GetIDsOfNames(IHTMLElement4 *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IDispatchEx_GetIDsOfNames(&This->node.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLElement4_Invoke(IHTMLElement4 *iface, DISPID dispIdMember, REFIID riid,
+        LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    return IDispatchEx_Invoke(&This->node.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLElement4_put_onmousewheel(IHTMLElement4 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+
+    FIXME("(%p)->(%s) semi-stub\n", This, debugstr_variant(&v));
+
+    return set_node_event(&This->node, EVENTID_MOUSEWHEEL, &v);
+}
+
+static HRESULT WINAPI HTMLElement4_get_onmousewheel(IHTMLElement4 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    return get_node_event(&This->node, EVENTID_MOUSEWHEEL, p);
+}
+
+static HRESULT WINAPI HTMLElement4_normalize(IHTMLElement4 *iface)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)\n", This);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_getAttributeNode(IHTMLElement4 *iface, BSTR bstrname, IHTMLDOMAttribute **ppAttribute)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    HTMLAttributeCollection *attrs;
+    HRESULT hres;
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_w(bstrname), ppAttribute);
+
+    hres = HTMLElement_get_attr_col(&This->node, &attrs);
+    if(FAILED(hres))
+        return hres;
+
+    hres = IHTMLAttributeCollection2_getNamedItem(&attrs->IHTMLAttributeCollection2_iface, bstrname, ppAttribute);
+    IHTMLAttributeCollection_Release(&attrs->IHTMLAttributeCollection_iface);
+    return hres;
+}
+
+static HRESULT WINAPI HTMLElement4_setAttributeNode(IHTMLElement4 *iface, IHTMLDOMAttribute *pattr,
+        IHTMLDOMAttribute **ppretAttribute)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%p %p)\n", This, pattr, ppretAttribute);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_removeAttributeNode(IHTMLElement4 *iface, IHTMLDOMAttribute *pattr,
+        IHTMLDOMAttribute **ppretAttribute)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%p %p)\n", This, pattr, ppretAttribute);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_put_onbeforeactivate(IHTMLElement4 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_get_onbeforeactivate(IHTMLElement4 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_put_onfocusin(IHTMLElement4 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_get_onfocusin(IHTMLElement4 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_put_onfocusout(IHTMLElement4 *iface, VARIANT v)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLElement4_get_onfocusout(IHTMLElement4 *iface, VARIANT *p)
+{
+    HTMLElement *This = impl_from_IHTMLElement4(iface);
+    FIXME("(%p)->(%p)\n", This, p);
+    return E_NOTIMPL;
+}
+
+static const IHTMLElement4Vtbl HTMLElement4Vtbl = {
+    HTMLElement4_QueryInterface,
+    HTMLElement4_AddRef,
+    HTMLElement4_Release,
+    HTMLElement4_GetTypeInfoCount,
+    HTMLElement4_GetTypeInfo,
+    HTMLElement4_GetIDsOfNames,
+    HTMLElement4_Invoke,
+    HTMLElement4_put_onmousewheel,
+    HTMLElement4_get_onmousewheel,
+    HTMLElement4_normalize,
+    HTMLElement4_getAttributeNode,
+    HTMLElement4_setAttributeNode,
+    HTMLElement4_removeAttributeNode,
+    HTMLElement4_put_onbeforeactivate,
+    HTMLElement4_get_onbeforeactivate,
+    HTMLElement4_put_onfocusin,
+    HTMLElement4_get_onfocusin,
+    HTMLElement4_put_onfocusout,
+    HTMLElement4_get_onfocusout
+};
+
 static inline HTMLElement *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLElement, node);
@@ -3297,8 +3941,8 @@ void HTMLElement_Init(HTMLElement *This, HTMLDocumentNode *doc, nsIDOMHTMLElemen
 {
     This->IHTMLElement_iface.lpVtbl = &HTMLElementVtbl;
     This->IHTMLElement2_iface.lpVtbl = &HTMLElement2Vtbl;
-
-    HTMLElement3_Init(This);
+    This->IHTMLElement3_iface.lpVtbl = &HTMLElement3Vtbl;
+    This->IHTMLElement4_iface.lpVtbl = &HTMLElement4Vtbl;
 
     if(dispex_data && !dispex_data->vtbl)
         dispex_data->vtbl = &HTMLElement_dispex_vtbl;
diff --git a/dlls/mshtml/htmlelem3.c b/dlls/mshtml/htmlelem3.c
deleted file mode 100644
index bcd6eb2..0000000
--- a/dlls/mshtml/htmlelem3.c
+++ /dev/null
@@ -1,683 +0,0 @@
-/*
- * Copyright 2008 Jacek Caban for CodeWeavers
- *
- * This library is free software; you can redistribute it and/or
- * modify it under the terms of the GNU Lesser General Public
- * License as published by the Free Software Foundation; either
- * version 2.1 of the License, or (at your option) any later version.
- *
- * This library is distributed in the hope that it will be useful,
- * but WITHOUT ANY WARRANTY; without even the implied warranty of
- * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
- * Lesser General Public License for more details.
- *
- * You should have received a copy of the GNU Lesser General Public
- * License along with this library; if not, write to the Free Software
- * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301, USA
- */
-
-#include <stdarg.h>
-
-#define COBJMACROS
-
-#include "windef.h"
-#include "winbase.h"
-#include "winuser.h"
-#include "ole2.h"
-
-#include "wine/debug.h"
-
-#include "mshtml_private.h"
-#include "htmlevent.h"
-
-WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
-
-static inline HTMLElement *impl_from_IHTMLElement3(IHTMLElement3 *iface)
-{
-    return CONTAINING_RECORD(iface, HTMLElement, IHTMLElement3_iface);
-}
-
-static HRESULT WINAPI HTMLElement3_QueryInterface(IHTMLElement3 *iface,
-                                                  REFIID riid, void **ppv)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IHTMLElement_QueryInterface(&This->IHTMLElement_iface, riid, ppv);
-}
-
-static ULONG WINAPI HTMLElement3_AddRef(IHTMLElement3 *iface)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IHTMLElement_AddRef(&This->IHTMLElement_iface);
-}
-
-static ULONG WINAPI HTMLElement3_Release(IHTMLElement3 *iface)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IHTMLElement_Release(&This->IHTMLElement_iface);
-}
-
-static HRESULT WINAPI HTMLElement3_GetTypeInfoCount(IHTMLElement3 *iface, UINT *pctinfo)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IDispatchEx_GetTypeInfoCount(&This->node.dispex.IDispatchEx_iface, pctinfo);
-}
-
-static HRESULT WINAPI HTMLElement3_GetTypeInfo(IHTMLElement3 *iface, UINT iTInfo,
-                                               LCID lcid, ITypeInfo **ppTInfo)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IDispatchEx_GetTypeInfo(&This->node.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
-}
-
-static HRESULT WINAPI HTMLElement3_GetIDsOfNames(IHTMLElement3 *iface, REFIID riid,
-                                                LPOLESTR *rgszNames, UINT cNames,
-                                                LCID lcid, DISPID *rgDispId)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IDispatchEx_GetIDsOfNames(&This->node.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
-            lcid, rgDispId);
-}
-
-static HRESULT WINAPI HTMLElement3_Invoke(IHTMLElement3 *iface, DISPID dispIdMember,
-                            REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams,
-                            VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    return IDispatchEx_Invoke(&This->node.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
-            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
-}
-
-static HRESULT WINAPI HTMLElement3_mergeAttributes(IHTMLElement3 *iface, IHTMLElement *mergeThis, VARIANT *pvarFlags)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p %p)\n", This, mergeThis, pvarFlags);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_isMultiLine(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_canHaveHTML(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onlayoutcomplete(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onlayoutcomplete(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onpage(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onpage(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_inflateBlock(IHTMLElement3 *iface, VARIANT_BOOL v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%x)\n", This, v);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_inflateBlock(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onbeforedeactivate(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onbeforedeactivate(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_setActive(IHTMLElement3 *iface)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)\n", This);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_contentEditable(IHTMLElement3 *iface, BSTR v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    nsresult nsres;
-    nsAString str;
-
-    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
-
-    nsAString_InitDepend(&str, v);
-    nsres = nsIDOMHTMLElement_SetContentEditable(This->nselem, &str);
-    nsAString_Finish(&str);
-
-    if (NS_FAILED(nsres)){
-        ERR("SetContentEditable(%s) failed!\n", debugstr_w(v));
-        return E_FAIL;
-    }
-
-    return S_OK;
-}
-
-static HRESULT WINAPI HTMLElement3_get_contentEditable(IHTMLElement3 *iface, BSTR *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    nsresult nsres;
-    nsAString str;
-
-    TRACE("(%p)->(%p)\n", This, p);
-
-    nsAString_Init(&str, NULL);
-    nsres = nsIDOMHTMLElement_GetContentEditable(This->nselem, &str);
-    return return_nsstr(nsres, &str, p);
-}
-
-static HRESULT WINAPI HTMLElement3_get_isContentEditable(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_hideFocus(IHTMLElement3 *iface, VARIANT_BOOL v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%x)\n", This, v);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_hideFocus(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static const WCHAR disabledW[] = {'d','i','s','a','b','l','e','d',0};
-
-static HRESULT WINAPI HTMLElement3_put_disabled(IHTMLElement3 *iface, VARIANT_BOOL v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    VARIANT *var;
-    HRESULT hres;
-
-    TRACE("(%p)->(%x)\n", This, v);
-
-    if(This->node.vtbl->put_disabled)
-        return This->node.vtbl->put_disabled(&This->node, v);
-
-    hres = dispex_get_dprop_ref(&This->node.dispex, disabledW, TRUE, &var);
-    if(FAILED(hres))
-        return hres;
-
-    VariantClear(var);
-    V_VT(var) = VT_BOOL;
-    V_BOOL(var) = v;
-    return S_OK;
-}
-
-static HRESULT WINAPI HTMLElement3_get_disabled(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    VARIANT *var;
-    HRESULT hres;
-
-    TRACE("(%p)->(%p)\n", This, p);
-
-    if(This->node.vtbl->get_disabled)
-        return This->node.vtbl->get_disabled(&This->node, p);
-
-    hres = dispex_get_dprop_ref(&This->node.dispex, disabledW, FALSE, &var);
-    if(hres == DISP_E_UNKNOWNNAME) {
-        *p = VARIANT_FALSE;
-        return S_OK;
-    }
-    if(FAILED(hres))
-        return hres;
-
-    if(V_VT(var) != VT_BOOL) {
-        FIXME("value is %s\n", debugstr_variant(var));
-        return E_NOTIMPL;
-    }
-
-    *p = V_BOOL(var);
-    return S_OK;
-}
-
-static HRESULT WINAPI HTMLElement3_get_isDisabled(IHTMLElement3 *iface, VARIANT_BOOL *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onmove(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onmove(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_oncontrolselect(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_oncontrolselect(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_fireEvent(IHTMLElement3 *iface, BSTR bstrEventName,
-        VARIANT *pvarEventObject, VARIANT_BOOL *pfCancelled)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-
-    TRACE("(%p)->(%s %s %p)\n", This, debugstr_w(bstrEventName), debugstr_variant(pvarEventObject),
-          pfCancelled);
-
-    return dispatch_event(&This->node, bstrEventName, pvarEventObject, pfCancelled);
-}
-
-static HRESULT WINAPI HTMLElement3_put_onresizestart(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onresizestart(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onresizeend(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onresizeend(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onmovestart(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onmovestart(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onmoveend(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onmoveend(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onmousecenter(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onmousecenter(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onmouseleave(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onmouseleave(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_onactivate(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_onactivate(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_put_ondeactivate(IHTMLElement3 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_ondeactivate(IHTMLElement3 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_dragDrop(IHTMLElement3 *iface, VARIANT_BOOL *pfRet)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, pfRet);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement3_get_glyphMode(IHTMLElement3 *iface, LONG *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement3(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static const IHTMLElement3Vtbl HTMLElement3Vtbl = {
-    HTMLElement3_QueryInterface,
-    HTMLElement3_AddRef,
-    HTMLElement3_Release,
-    HTMLElement3_GetTypeInfoCount,
-    HTMLElement3_GetTypeInfo,
-    HTMLElement3_GetIDsOfNames,
-    HTMLElement3_Invoke,
-    HTMLElement3_mergeAttributes,
-    HTMLElement3_get_isMultiLine,
-    HTMLElement3_get_canHaveHTML,
-    HTMLElement3_put_onlayoutcomplete,
-    HTMLElement3_get_onlayoutcomplete,
-    HTMLElement3_put_onpage,
-    HTMLElement3_get_onpage,
-    HTMLElement3_put_inflateBlock,
-    HTMLElement3_get_inflateBlock,
-    HTMLElement3_put_onbeforedeactivate,
-    HTMLElement3_get_onbeforedeactivate,
-    HTMLElement3_setActive,
-    HTMLElement3_put_contentEditable,
-    HTMLElement3_get_contentEditable,
-    HTMLElement3_get_isContentEditable,
-    HTMLElement3_put_hideFocus,
-    HTMLElement3_get_hideFocus,
-    HTMLElement3_put_disabled,
-    HTMLElement3_get_disabled,
-    HTMLElement3_get_isDisabled,
-    HTMLElement3_put_onmove,
-    HTMLElement3_get_onmove,
-    HTMLElement3_put_oncontrolselect,
-    HTMLElement3_get_oncontrolselect,
-    HTMLElement3_fireEvent,
-    HTMLElement3_put_onresizestart,
-    HTMLElement3_get_onresizestart,
-    HTMLElement3_put_onresizeend,
-    HTMLElement3_get_onresizeend,
-    HTMLElement3_put_onmovestart,
-    HTMLElement3_get_onmovestart,
-    HTMLElement3_put_onmoveend,
-    HTMLElement3_get_onmoveend,
-    HTMLElement3_put_onmousecenter,
-    HTMLElement3_get_onmousecenter,
-    HTMLElement3_put_onmouseleave,
-    HTMLElement3_get_onmouseleave,
-    HTMLElement3_put_onactivate,
-    HTMLElement3_get_onactivate,
-    HTMLElement3_put_ondeactivate,
-    HTMLElement3_get_ondeactivate,
-    HTMLElement3_dragDrop,
-    HTMLElement3_get_glyphMode
-};
-
-static inline HTMLElement *impl_from_IHTMLElement4(IHTMLElement4 *iface)
-{
-    return CONTAINING_RECORD(iface, HTMLElement, IHTMLElement4_iface);
-}
-
-static HRESULT WINAPI HTMLElement4_QueryInterface(IHTMLElement4 *iface,
-        REFIID riid, void **ppv)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IHTMLElement_QueryInterface(&This->IHTMLElement_iface, riid, ppv);
-}
-
-static ULONG WINAPI HTMLElement4_AddRef(IHTMLElement4 *iface)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IHTMLElement_AddRef(&This->IHTMLElement_iface);
-}
-
-static ULONG WINAPI HTMLElement4_Release(IHTMLElement4 *iface)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IHTMLElement_Release(&This->IHTMLElement_iface);
-}
-
-static HRESULT WINAPI HTMLElement4_GetTypeInfoCount(IHTMLElement4 *iface, UINT *pctinfo)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IDispatchEx_GetTypeInfoCount(&This->node.dispex.IDispatchEx_iface, pctinfo);
-}
-
-static HRESULT WINAPI HTMLElement4_GetTypeInfo(IHTMLElement4 *iface, UINT iTInfo,
-        LCID lcid, ITypeInfo **ppTInfo)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IDispatchEx_GetTypeInfo(&This->node.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
-}
-
-static HRESULT WINAPI HTMLElement4_GetIDsOfNames(IHTMLElement4 *iface, REFIID riid,
-        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IDispatchEx_GetIDsOfNames(&This->node.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
-            lcid, rgDispId);
-}
-
-static HRESULT WINAPI HTMLElement4_Invoke(IHTMLElement4 *iface, DISPID dispIdMember, REFIID riid,
-        LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult, EXCEPINFO *pExcepInfo, UINT *puArgErr)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    return IDispatchEx_Invoke(&This->node.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
-            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
-}
-
-static HRESULT WINAPI HTMLElement4_put_onmousewheel(IHTMLElement4 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-
-    FIXME("(%p)->(%s) semi-stub\n", This, debugstr_variant(&v));
-
-    return set_node_event(&This->node, EVENTID_MOUSEWHEEL, &v);
-}
-
-static HRESULT WINAPI HTMLElement4_get_onmousewheel(IHTMLElement4 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-
-    TRACE("(%p)->(%p)\n", This, p);
-
-    return get_node_event(&This->node, EVENTID_MOUSEWHEEL, p);
-}
-
-static HRESULT WINAPI HTMLElement4_normalize(IHTMLElement4 *iface)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)\n", This);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_getAttributeNode(IHTMLElement4 *iface, BSTR bstrname, IHTMLDOMAttribute **ppAttribute)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    HTMLAttributeCollection *attrs;
-    HRESULT hres;
-
-    TRACE("(%p)->(%s %p)\n", This, debugstr_w(bstrname), ppAttribute);
-
-    hres = HTMLElement_get_attr_col(&This->node, &attrs);
-    if(FAILED(hres))
-        return hres;
-
-    hres = IHTMLAttributeCollection2_getNamedItem(&attrs->IHTMLAttributeCollection2_iface, bstrname, ppAttribute);
-    IHTMLAttributeCollection_Release(&attrs->IHTMLAttributeCollection_iface);
-    return hres;
-}
-
-static HRESULT WINAPI HTMLElement4_setAttributeNode(IHTMLElement4 *iface, IHTMLDOMAttribute *pattr,
-        IHTMLDOMAttribute **ppretAttribute)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%p %p)\n", This, pattr, ppretAttribute);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_removeAttributeNode(IHTMLElement4 *iface, IHTMLDOMAttribute *pattr,
-        IHTMLDOMAttribute **ppretAttribute)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%p %p)\n", This, pattr, ppretAttribute);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_put_onbeforeactivate(IHTMLElement4 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_get_onbeforeactivate(IHTMLElement4 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_put_onfocusin(IHTMLElement4 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_get_onfocusin(IHTMLElement4 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_put_onfocusout(IHTMLElement4 *iface, VARIANT v)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_variant(&v));
-    return E_NOTIMPL;
-}
-
-static HRESULT WINAPI HTMLElement4_get_onfocusout(IHTMLElement4 *iface, VARIANT *p)
-{
-    HTMLElement *This = impl_from_IHTMLElement4(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
-}
-
-static const IHTMLElement4Vtbl HTMLElement4Vtbl = {
-    HTMLElement4_QueryInterface,
-    HTMLElement4_AddRef,
-    HTMLElement4_Release,
-    HTMLElement4_GetTypeInfoCount,
-    HTMLElement4_GetTypeInfo,
-    HTMLElement4_GetIDsOfNames,
-    HTMLElement4_Invoke,
-    HTMLElement4_put_onmousewheel,
-    HTMLElement4_get_onmousewheel,
-    HTMLElement4_normalize,
-    HTMLElement4_getAttributeNode,
-    HTMLElement4_setAttributeNode,
-    HTMLElement4_removeAttributeNode,
-    HTMLElement4_put_onbeforeactivate,
-    HTMLElement4_get_onbeforeactivate,
-    HTMLElement4_put_onfocusin,
-    HTMLElement4_get_onfocusin,
-    HTMLElement4_put_onfocusout,
-    HTMLElement4_get_onfocusout
-};
-
-void HTMLElement3_Init(HTMLElement *This)
-{
-    This->IHTMLElement3_iface.lpVtbl = &HTMLElement3Vtbl;
-    This->IHTMLElement4_iface.lpVtbl = &HTMLElement4Vtbl;
-}
diff --git a/dlls/mshtml/htmlframebase.c b/dlls/mshtml/htmlframebase.c
index 9808379..d6e5ed2 100644
--- a/dlls/mshtml/htmlframebase.c
+++ b/dlls/mshtml/htmlframebase.c
@@ -134,8 +134,21 @@ static HRESULT WINAPI HTMLFrameBase_put_src(IHTMLFrameBase *iface, BSTR v)
     TRACE("(%p)->(%s)\n", This, debugstr_w(v));
 
     if(!This->content_window || !This->element.node.doc || !This->element.node.doc->basedoc.window) {
-        FIXME("detached element\n");
-        return E_FAIL;
+        nsAString nsstr;
+        nsresult nsres;
+
+        nsAString_InitDepend(&nsstr, v);
+        if(This->nsframe)
+            nsres = nsIDOMHTMLFrameElement_SetSrc(This->nsframe, &nsstr);
+        else
+            nsres = nsIDOMHTMLIFrameElement_SetSrc(This->nsiframe, &nsstr);
+        nsAString_Finish(&nsstr);
+        if(NS_FAILED(nsres)) {
+            ERR("SetSrc failed: %08x\n", nsres);
+            return E_FAIL;
+        }
+
+        return S_OK;
     }
 
     return navigate_url(This->content_window, v, This->element.node.doc->basedoc.window->uri, BINDING_NAVIGATED);
@@ -144,8 +157,22 @@ static HRESULT WINAPI HTMLFrameBase_put_src(IHTMLFrameBase *iface, BSTR v)
 static HRESULT WINAPI HTMLFrameBase_get_src(IHTMLFrameBase *iface, BSTR *p)
 {
     HTMLFrameBase *This = impl_from_IHTMLFrameBase(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsAString nsstr;
+    nsresult nsres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    if(!This->nsframe && !This->nsiframe) {
+        ERR("No attached frame object\n");
+        return E_UNEXPECTED;
+    }
+
+    nsAString_Init(&nsstr, NULL);
+    if(This->nsframe)
+        nsres = nsIDOMHTMLFrameElement_GetSrc(This->nsframe, &nsstr);
+    else
+        nsres = nsIDOMHTMLIFrameElement_GetSrc(This->nsiframe, &nsstr);
+    return return_nsstr(nsres, &nsstr, p);
 }
 
 static HRESULT WINAPI HTMLFrameBase_put_name(IHTMLFrameBase *iface, BSTR v)
@@ -640,15 +667,20 @@ static HRESULT WINAPI HTMLFrameBase2_get_readyState(IHTMLFrameBase2 *iface, BSTR
 static HRESULT WINAPI HTMLFrameBase2_put_allowTransparency(IHTMLFrameBase2 *iface, VARIANT_BOOL v)
 {
     HTMLFrameBase *This = impl_from_IHTMLFrameBase2(iface);
-    FIXME("(%p)->(%x)\n", This, v);
-    return E_NOTIMPL;
+
+    FIXME("(%p)->(%x) semi-stub\n", This, v);
+
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLFrameBase2_get_allowTransparency(IHTMLFrameBase2 *iface, VARIANT_BOOL *p)
 {
     HTMLFrameBase *This = impl_from_IHTMLFrameBase2(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+
+    FIXME("(%p)->(%p) semi-stub\n", This, p);
+
+    *p = VARIANT_TRUE;
+    return S_OK;
 }
 
 static const IHTMLFrameBase2Vtbl HTMLFrameBase2Vtbl = {
diff --git a/dlls/mshtml/htmlstylesheet.c b/dlls/mshtml/htmlstylesheet.c
index 6480975..d2960d2 100644
--- a/dlls/mshtml/htmlstylesheet.c
+++ b/dlls/mshtml/htmlstylesheet.c
@@ -17,6 +17,7 @@
  */
 
 #include <stdarg.h>
+#include <assert.h>
 
 #define COBJMACROS
 
@@ -629,15 +630,70 @@ static HRESULT WINAPI HTMLStyleSheet_get_media(IHTMLStyleSheet *iface, BSTR *p)
 static HRESULT WINAPI HTMLStyleSheet_put_cssText(IHTMLStyleSheet *iface, BSTR v)
 {
     HTMLStyleSheet *This = impl_from_IHTMLStyleSheet(iface);
-    FIXME("(%p)->(%s)\n", This, debugstr_w(v));
-    return E_NOTIMPL;
+    nsresult nsres;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_w(v));
+
+    do {
+        nsres = nsIDOMCSSStyleSheet_DeleteRule(This->nsstylesheet, 0);
+    }while(NS_SUCCEEDED(nsres));
+
+    if(v && *v) {
+        nsAString nsstr;
+        UINT32 idx;
+
+        /* FIXME: This won't work for multiple rules in the string. */
+        nsAString_InitDepend(&nsstr, v);
+        nsres = nsIDOMCSSStyleSheet_InsertRule(This->nsstylesheet, &nsstr, 0, &idx);
+        nsAString_Finish(&nsstr);
+        if(NS_FAILED(nsres)) {
+            FIXME("InsertRule failed for string %s. Probably multiple rules passed.\n", debugstr_w(v));
+            return E_FAIL;
+        }
+    }
+
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLStyleSheet_get_cssText(IHTMLStyleSheet *iface, BSTR *p)
 {
     HTMLStyleSheet *This = impl_from_IHTMLStyleSheet(iface);
-    FIXME("(%p)->(%p)\n", This, p);
-    return E_NOTIMPL;
+    nsIDOMCSSRuleList *nslist = NULL;
+    nsIDOMCSSRule *nsrule;
+    nsAString nsstr;
+    UINT32 len;
+    nsresult nsres;
+
+    TRACE("(%p)->(%p)\n", This, p);
+
+    nsres = nsIDOMCSSStyleSheet_GetCssRules(This->nsstylesheet, &nslist);
+    if(NS_FAILED(nsres)) {
+        ERR("GetCssRules failed: %08x\n", nsres);
+        return E_FAIL;
+    }
+
+    nsres = nsIDOMCSSRuleList_GetLength(nslist, &len);
+    assert(nsres == NS_OK);
+
+    if(len) {
+        nsres = nsIDOMCSSRuleList_Item(nslist, 0, &nsrule);
+        if(NS_FAILED(nsres))
+            ERR("Item failed: %08x\n", nsres);
+    }
+
+    nsIDOMCSSRuleList_Release(nslist);
+    if(NS_FAILED(nsres))
+        return E_FAIL;
+
+    if(!len) {
+        *p = NULL;
+        return S_OK;
+    }
+
+    nsAString_Init(&nsstr, NULL);
+    nsres = nsIDOMCSSRule_GetCssText(nsrule, &nsstr);
+    nsIDOMCSSRule_Release(nsrule);
+    return return_nsstr(nsres, &nsstr, p);
 }
 
 static HRESULT WINAPI HTMLStyleSheet_get_rules(IHTMLStyleSheet *iface,
diff --git a/dlls/mshtml/htmltextnode.c b/dlls/mshtml/htmltextnode.c
index 27e00c0..fd4795b 100644
--- a/dlls/mshtml/htmltextnode.c
+++ b/dlls/mshtml/htmltextnode.c
@@ -36,6 +36,7 @@ WINE_DEFAULT_DEBUG_CHANNEL(mshtml);
 struct HTMLDOMTextNode {
     HTMLDOMNode node;
     IHTMLDOMTextNode IHTMLDOMTextNode_iface;
+    IHTMLDOMTextNode2 IHTMLDOMTextNode2_iface;
 
     nsIDOMText *nstext;
 };
@@ -170,6 +171,124 @@ static const IHTMLDOMTextNodeVtbl HTMLDOMTextNodeVtbl = {
     HTMLDOMTextNode_splitText
 };
 
+static inline HTMLDOMTextNode *impl_from_IHTMLDOMTextNode2(IHTMLDOMTextNode2 *iface)
+{
+    return CONTAINING_RECORD(iface, HTMLDOMTextNode, IHTMLDOMTextNode2_iface);
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_QueryInterface(IHTMLDOMTextNode2 *iface, REFIID riid, void **ppv)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+
+    return IHTMLDOMNode_QueryInterface(&This->node.IHTMLDOMNode_iface, riid, ppv);
+}
+
+static ULONG WINAPI HTMLDOMTextNode2_AddRef(IHTMLDOMTextNode2 *iface)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+
+    return IHTMLDOMNode_AddRef(&This->node.IHTMLDOMNode_iface);
+}
+
+static ULONG WINAPI HTMLDOMTextNode2_Release(IHTMLDOMTextNode2 *iface)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+
+    return IHTMLDOMNode_Release(&This->node.IHTMLDOMNode_iface);
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_GetTypeInfoCount(IHTMLDOMTextNode2 *iface, UINT *pctinfo)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_GetTypeInfoCount(&This->node.dispex.IDispatchEx_iface, pctinfo);
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_GetTypeInfo(IHTMLDOMTextNode2 *iface, UINT iTInfo,
+        LCID lcid, ITypeInfo **ppTInfo)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_GetTypeInfo(&This->node.dispex.IDispatchEx_iface, iTInfo, lcid, ppTInfo);
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_GetIDsOfNames(IHTMLDOMTextNode2 *iface, REFIID riid,
+        LPOLESTR *rgszNames, UINT cNames, LCID lcid, DISPID *rgDispId)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_GetIDsOfNames(&This->node.dispex.IDispatchEx_iface, riid, rgszNames, cNames,
+            lcid, rgDispId);
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_Invoke(IHTMLDOMTextNode2 *iface, DISPID dispIdMember,
+        REFIID riid, LCID lcid, WORD wFlags, DISPPARAMS *pDispParams, VARIANT *pVarResult,
+        EXCEPINFO *pExcepInfo, UINT *puArgErr)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    return IDispatchEx_Invoke(&This->node.dispex.IDispatchEx_iface, dispIdMember, riid, lcid,
+            wFlags, pDispParams, pVarResult, pExcepInfo, puArgErr);
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_substringData(IHTMLDOMTextNode2 *iface, LONG offset, LONG count, BSTR *string)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%d %d %p)\n", This, offset, count, string);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_appendData(IHTMLDOMTextNode2 *iface, BSTR string)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    nsAString nsstr;
+    nsresult nsres;
+
+    TRACE("(%p)->(%s)\n", This, debugstr_w(string));
+
+    nsAString_InitDepend(&nsstr, string);
+    nsres = nsIDOMText_AppendData(This->nstext, &nsstr);
+    nsAString_Finish(&nsstr);
+    if(NS_FAILED(nsres)) {
+        ERR("AppendData failed: %08x\n", nsres);
+        return E_FAIL;
+    }
+
+    return S_OK;
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_insertData(IHTMLDOMTextNode2 *iface, LONG offset, BSTR string)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%d %s)\n", This, offset, debugstr_w(string));
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_deleteData(IHTMLDOMTextNode2 *iface, LONG offset, LONG count)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%d %d)\n", This, offset, count);
+    return E_NOTIMPL;
+}
+
+static HRESULT WINAPI HTMLDOMTextNode2_replaceData(IHTMLDOMTextNode2 *iface, LONG offset, LONG count, BSTR string)
+{
+    HTMLDOMTextNode *This = impl_from_IHTMLDOMTextNode2(iface);
+    FIXME("(%p)->(%d %d %s)\n", This, offset, count, debugstr_w(string));
+    return E_NOTIMPL;
+}
+
+static const IHTMLDOMTextNode2Vtbl HTMLDOMTextNode2Vtbl = {
+    HTMLDOMTextNode2_QueryInterface,
+    HTMLDOMTextNode2_AddRef,
+    HTMLDOMTextNode2_Release,
+    HTMLDOMTextNode2_GetTypeInfoCount,
+    HTMLDOMTextNode2_GetTypeInfo,
+    HTMLDOMTextNode2_GetIDsOfNames,
+    HTMLDOMTextNode2_Invoke,
+    HTMLDOMTextNode2_substringData,
+    HTMLDOMTextNode2_appendData,
+    HTMLDOMTextNode2_insertData,
+    HTMLDOMTextNode2_deleteData,
+    HTMLDOMTextNode2_replaceData
+};
+
 static inline HTMLDOMTextNode *impl_from_HTMLDOMNode(HTMLDOMNode *iface)
 {
     return CONTAINING_RECORD(iface, HTMLDOMTextNode, node);
@@ -179,14 +298,14 @@ static HRESULT HTMLDOMTextNode_QI(HTMLDOMNode *iface, REFIID riid, void **ppv)
 {
     HTMLDOMTextNode *This = impl_from_HTMLDOMNode(iface);
 
-    *ppv =  NULL;
+    TRACE("(%p)->(%s %p)\n", This, debugstr_mshtml_guid(riid), ppv);
 
-    if(IsEqualGUID(&IID_IHTMLDOMTextNode, riid)) {
-        TRACE("(%p)->(IID_IHTMLDOMTextNode %p)\n", This, ppv);
+    if(IsEqualGUID(&IID_IHTMLDOMTextNode, riid))
         *ppv = &This->IHTMLDOMTextNode_iface;
-    }else {
+    else if(IsEqualGUID(&IID_IHTMLDOMTextNode2, riid))
+        *ppv = &This->IHTMLDOMTextNode2_iface;
+    else
         return HTMLDOMNode_QI(&This->node, riid, ppv);
-    }
 
     IUnknown_AddRef((IUnknown*)*ppv);
     return S_OK;
@@ -212,6 +331,7 @@ static const tid_t HTMLDOMTextNode_iface_tids[] = {
     IHTMLDOMNode_tid,
     IHTMLDOMNode2_tid,
     IHTMLDOMTextNode_tid,
+    IHTMLDOMTextNode2_tid,
     0
 };
 static dispex_static_data_t HTMLDOMTextNode_dispex = {
@@ -232,6 +352,7 @@ HRESULT HTMLDOMTextNode_Create(HTMLDocumentNode *doc, nsIDOMNode *nsnode, HTMLDO
 
     ret->node.vtbl = &HTMLDOMTextNodeImplVtbl;
     ret->IHTMLDOMTextNode_iface.lpVtbl = &HTMLDOMTextNodeVtbl;
+    ret->IHTMLDOMTextNode2_iface.lpVtbl = &HTMLDOMTextNode2Vtbl;
 
     init_dispex(&ret->node.dispex, (IUnknown*)&ret->IHTMLDOMTextNode_iface,
             &HTMLDOMTextNode_dispex);
diff --git a/dlls/mshtml/mshtml_private.h b/dlls/mshtml/mshtml_private.h
index 9c38df7..07d1564 100644
--- a/dlls/mshtml/mshtml_private.h
+++ b/dlls/mshtml/mshtml_private.h
@@ -140,6 +140,7 @@ typedef struct event_target_t event_target_t;
     XIID(IHTMLDOMNode) \
     XIID(IHTMLDOMNode2) \
     XIID(IHTMLDOMTextNode) \
+    XIID(IHTMLDOMTextNode2) \
     XIID(IHTMLElement) \
     XIID(IHTMLElement2) \
     XIID(IHTMLElement3) \
@@ -939,7 +940,6 @@ HRESULT HTMLGenericElement_Create(HTMLDocumentNode*,nsIDOMHTMLElement*,HTMLEleme
 
 void HTMLDOMNode_Init(HTMLDocumentNode*,HTMLDOMNode*,nsIDOMNode*) DECLSPEC_HIDDEN;
 void HTMLElement_Init(HTMLElement*,HTMLDocumentNode*,nsIDOMHTMLElement*,dispex_static_data_t*) DECLSPEC_HIDDEN;
-void HTMLElement3_Init(HTMLElement*) DECLSPEC_HIDDEN;
 void HTMLTextContainer_Init(HTMLTextContainer*,HTMLDocumentNode*,nsIDOMHTMLElement*,dispex_static_data_t*) DECLSPEC_HIDDEN;
 void HTMLFrameBase_Init(HTMLFrameBase*,HTMLDocumentNode*,nsIDOMHTMLElement*,dispex_static_data_t*) DECLSPEC_HIDDEN;
 
diff --git a/dlls/mshtml/navigate.c b/dlls/mshtml/navigate.c
index 39f298f..85e47aa 100644
--- a/dlls/mshtml/navigate.c
+++ b/dlls/mshtml/navigate.c
@@ -902,7 +902,8 @@ static HRESULT read_post_data_stream(nsIInputStream *stream, BOOL contains_heade
         post_data = new_data;
     }
 
-    post_data[data_len] = 0;
+    if(post_data)
+        post_data[data_len] = 0;
     request_data->post_data = post_data;
     request_data->post_data_len = data_len;
     TRACE("post_data = %s\n", debugstr_an(request_data->post_data, request_data->post_data_len));
diff --git a/dlls/mshtml/nsio.c b/dlls/mshtml/nsio.c
index 9216c1f..d8e1712 100644
--- a/dlls/mshtml/nsio.c
+++ b/dlls/mshtml/nsio.c
@@ -1824,6 +1824,43 @@ static nsresult NSAPI nsHttpChannelInternal_SetLoadUnblocked(nsIHttpChannelInter
     return NS_ERROR_NOT_IMPLEMENTED;
 }
 
+static nsresult NSAPI nsHttpChannelInternal_GetResponseTimeoutEnabled(nsIHttpChannelInternal *iface,
+        cpp_bool *aResponseTimeoutEnabled)
+{
+    nsChannel *This = impl_from_nsIHttpChannelInternal(iface);
+    FIXME("(%p)->(%p)\n", This, aResponseTimeoutEnabled);
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+static nsresult NSAPI nsHttpChannelInternal_SetResponseTimeoutEnabled(nsIHttpChannelInternal *iface,
+        cpp_bool aResponseTimeoutEnabled)
+{
+    nsChannel *This = impl_from_nsIHttpChannelInternal(iface);
+    FIXME("(%p)->(%x)\n", This, aResponseTimeoutEnabled);
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+static nsresult NSAPI nsHttpChannelInternal_GetApiRedirectToURI(nsIHttpChannelInternal *iface, nsIURI **aApiRedirectToURI)
+{
+    nsChannel *This = impl_from_nsIHttpChannelInternal(iface);
+    FIXME("(%p)->(%p)\n", This, aApiRedirectToURI);
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+static nsresult NSAPI nsHttpChannelInternal_AddRedirect(nsIHttpChannelInternal *iface, nsIPrincipal *aPrincipal)
+{
+    nsChannel *This = impl_from_nsIHttpChannelInternal(iface);
+    FIXME("(%p)->(%p)\n", This, aPrincipal);
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
+static nsresult NSAPI nsHttpChannelInternal_GetLastModifiedTime(nsIHttpChannelInternal *iface, PRTime *aLastModifiedTime)
+{
+    nsChannel *This = impl_from_nsIHttpChannelInternal(iface);
+    FIXME("(%p)->(%p)\n", This, aLastModifiedTime);
+    return NS_ERROR_NOT_IMPLEMENTED;
+}
+
 static const nsIHttpChannelInternalVtbl nsHttpChannelInternalVtbl = {
     nsHttpChannelInternal_QueryInterface,
     nsHttpChannelInternal_AddRef,
@@ -1851,7 +1888,12 @@ static const nsIHttpChannelInternalVtbl nsHttpChannelInternalVtbl = {
     nsHttpChannelInternal_GetLoadAsBlocking,
     nsHttpChannelInternal_SetLoadAsBlocking,
     nsHttpChannelInternal_GetLoadUnblocked,
-    nsHttpChannelInternal_SetLoadUnblocked
+    nsHttpChannelInternal_SetLoadUnblocked,
+    nsHttpChannelInternal_GetResponseTimeoutEnabled,
+    nsHttpChannelInternal_SetResponseTimeoutEnabled,
+    nsHttpChannelInternal_GetApiRedirectToURI,
+    nsHttpChannelInternal_AddRedirect,
+    nsHttpChannelInternal_GetLastModifiedTime
 };
 
 
@@ -2034,8 +2076,42 @@ static nsresult NSAPI nsURI_SetSpec(nsIFileURL *iface, const nsACString *aSpec)
 static nsresult NSAPI nsURI_GetPrePath(nsIFileURL *iface, nsACString *aPrePath)
 {
     nsWineURI *This = impl_from_nsIFileURL(iface);
-    FIXME("(%p)->(%p)\n", This, aPrePath);
-    return NS_ERROR_NOT_IMPLEMENTED;
+    IUriBuilder *uri_builder;
+    BSTR display_uri;
+    IUri *uri;
+    int len;
+    nsresult nsres;
+    HRESULT hres;
+
+    TRACE("(%p)->(%p)\n", This, aPrePath);
+
+    if(!ensure_uri(This))
+        return NS_ERROR_UNEXPECTED;
+
+    hres = CreateIUriBuilder(This->uri, 0, 0, &uri_builder);
+    if(FAILED(hres))
+        return NS_ERROR_FAILURE;
+
+    hres = IUriBuilder_RemoveProperties(uri_builder, Uri_HAS_PATH|Uri_HAS_QUERY|Uri_HAS_FRAGMENT);
+    if(SUCCEEDED(hres))
+        hres = IUriBuilder_CreateUriSimple(uri_builder, 0, 0, &uri);
+    IUriBuilder_Release(uri_builder);
+    if(FAILED(hres))
+        return NS_ERROR_FAILURE;
+
+    hres = IUri_GetDisplayUri(uri, &display_uri);
+    IUri_Release(uri);
+    if(FAILED(hres))
+        return NS_ERROR_FAILURE;
+
+    /* Remove trailing slash that may be appended as default path. */
+    len = SysStringLen(display_uri);
+    if(len && display_uri[len-1] == '/')
+        display_uri[len-1] = 0;
+
+    nsres = return_wstr_nsacstr(aPrePath, display_uri, -1);
+    SysFreeString(display_uri);
+    return nsres;
 }
 
 static nsresult NSAPI nsURI_GetScheme(nsIFileURL *iface, nsACString *aScheme)
diff --git a/dlls/mshtml/olecmd.c b/dlls/mshtml/olecmd.c
index 082777c..eea3aa2 100644
--- a/dlls/mshtml/olecmd.c
+++ b/dlls/mshtml/olecmd.c
@@ -615,8 +615,13 @@ static HRESULT exec_baselinefont3(HTMLDocument *This, DWORD cmdexecopt, VARIANT
 static HRESULT exec_respectvisibility_indesign(HTMLDocument *This, DWORD cmdexecopt,
         VARIANT *in, VARIANT *out)
 {
-    FIXME("(%p)->(%08x %p %p)\n", This, cmdexecopt, in, out);
-    return E_NOTIMPL;
+    TRACE("(%p)->(%x %s %p)\n", This, cmdexecopt, debugstr_variant(in), out);
+
+    /* This is turned on by default in Gecko. */
+    if(!in || V_VT(in) != VT_BOOL || !V_BOOL(in))
+        FIXME("Unsupported argument %s\n", debugstr_variant(in));
+
+    return S_OK;
 }
 
 static HRESULT query_enabled_stub(HTMLDocument *This, OLECMD *cmd)
diff --git a/dlls/mshtml/tests/dom.c b/dlls/mshtml/tests/dom.c
index 39c3a7d..8a47207 100644
--- a/dlls/mshtml/tests/dom.c
+++ b/dlls/mshtml/tests/dom.c
@@ -264,6 +264,7 @@ static const IID * const text_iids[] = {
     &IID_IHTMLDOMNode,
     &IID_IHTMLDOMNode2,
     &IID_IHTMLDOMTextNode,
+    &IID_IHTMLDOMTextNode2,
     NULL
 };
 
@@ -478,6 +479,20 @@ static int strcmp_wa(LPCWSTR strw, const char *stra)
     return lstrcmpA(stra, buf);
 }
 
+static BOOL is_prefix_wa(const WCHAR *strw, const char *prefix)
+{
+    int len, prefix_len;
+    CHAR buf[512];
+
+    len = WideCharToMultiByte(CP_ACP, 0, strw, -1, buf, sizeof(buf), NULL, NULL)-1;
+    prefix_len = lstrlenA(prefix);
+    if(len < prefix_len)
+        return FALSE;
+
+    buf[prefix_len] = 0;
+    return !lstrcmpA(buf, prefix);
+}
+
 static BSTR a2bstr(const char *str)
 {
     BSTR ret;
@@ -859,6 +874,17 @@ static IHTMLDOMTextNode *_get_text_iface(unsigned line, IUnknown *unk)
     return text;
 }
 
+#define get_text2_iface(u) _get_text2_iface(__LINE__,u)
+static IHTMLDOMTextNode2 *_get_text2_iface(unsigned line, IUnknown *unk)
+{
+    IHTMLDOMTextNode2 *text2;
+    HRESULT hres;
+
+    hres = IUnknown_QueryInterface(unk, &IID_IHTMLDOMTextNode2, (void**)&text2);
+    ok_(__FILE__,line) (hres == S_OK, "Could not get IHTMLDOMTextNode2: %08x\n", hres);
+    return text2;
+}
+
 #define get_comment_iface(u) _get_comment_iface(__LINE__,u)
 static IHTMLCommentElement *_get_comment_iface(unsigned line, IUnknown *unk)
 {
@@ -2155,8 +2181,8 @@ static void _test_range_paste_html(unsigned line, IHTMLTxtRange *range, const ch
     HRESULT hres;
 
     hres = IHTMLTxtRange_pasteHTML(range, str);
-     ok_(__FILE__,line)(hres == S_OK, "pasteHTML failed: %08x\n", hres);
-     SysFreeString(str);
+    ok_(__FILE__,line)(hres == S_OK, "pasteHTML failed: %08x\n", hres);
+    SysFreeString(str);
 }
 
 #define test_range_parent(r,t) _test_range_parent(__LINE__,r,t)
@@ -2695,6 +2721,19 @@ static void _set_text_data(unsigned line, IUnknown *unk, const char *data)
     SysFreeString(str);
 }
 
+#define text_append_data(a,b) _text_append_data(__LINE__,a,b)
+static void _text_append_data(unsigned line, IUnknown *unk, const char *data)
+{
+    IHTMLDOMTextNode2 *text = _get_text2_iface(line, unk);
+    BSTR str = a2bstr(data);
+    HRESULT hres;
+
+    hres = IHTMLDOMTextNode2_appendData(text, str);
+    ok_(__FILE__,line)(hres == S_OK, "appendData failed: %08x\n", hres);
+    IHTMLDOMTextNode2_Release(text);
+    SysFreeString(str);
+}
+
 #define test_select_set_disabled(i,b) _test_select_set_disabled(__LINE__,i,b)
 static void _test_select_set_disabled(unsigned line, IHTMLSelectElement *select, VARIANT_BOOL b)
 {
@@ -4862,6 +4901,30 @@ static IHTMLTxtRange *test_create_body_range(IHTMLDocument2 *doc)
     return range;
 }
 
+#define range_duplicate(a) _range_duplicate(__LINE__,a)
+static IHTMLTxtRange *_range_duplicate(unsigned line, IHTMLTxtRange *range)
+{
+    IHTMLTxtRange *ret;
+    HRESULT hres;
+
+    hres = IHTMLTxtRange_duplicate(range, &ret);
+    ok_(__FILE__,line)(hres == S_OK, "duplicate failed: %08x\n", hres);
+
+    return ret;
+}
+
+#define test_range_set_end_point(a,b,c,d) _test_range_set_end_point(__LINE__,a,b,c,d)
+static void _test_range_set_end_point(unsigned line, IHTMLTxtRange *range, const char *how,
+        IHTMLTxtRange *ref_range, HRESULT exhres)
+{
+    BSTR str = a2bstr(how);
+    HRESULT hres;
+
+    hres = IHTMLTxtRange_setEndPoint(range, str, ref_range);
+    ok_(__FILE__,line)(hres == exhres, "setEndPoint failed: %08x, expected %08x\n", hres, exhres);
+    SysFreeString(str);
+}
+
 static void test_txtrange(IHTMLDocument2 *doc)
 {
     IHTMLTxtRange *body_range, *range, *range2;
@@ -4876,11 +4939,9 @@ static void test_txtrange(IHTMLDocument2 *doc)
 
     test_range_text(body_range, "test abc 123\r\nit's text");
 
-    hres = IHTMLTxtRange_duplicate(body_range, &range);
-    ok(hres == S_OK, "duplicate failed: %08x\n", hres);
+    range = range_duplicate(body_range);
+    range2 = range_duplicate(body_range);
 
-    hres = IHTMLTxtRange_duplicate(body_range, &range2);
-    ok(hres == S_OK, "duplicate failed: %08x\n", hres);
     test_range_isequal(range, range2, VARIANT_TRUE);
 
     test_range_text(range, "test abc 123\r\nit's text");
@@ -4920,8 +4981,7 @@ static void test_txtrange(IHTMLDocument2 *doc)
 
     IHTMLTxtRange_Release(range);
 
-    hres = IHTMLTxtRange_duplicate(body_range, &range);
-    ok(hres == S_OK, "duplicate failed: %08x\n", hres);
+    range = range_duplicate(body_range);
 
     test_range_text(range, "test abc 123\r\nit's text");
     test_range_move(range, characterW, 3, 3);
@@ -4939,8 +4999,7 @@ static void test_txtrange(IHTMLDocument2 *doc)
 
     IHTMLTxtRange_Release(range);
 
-    hres = IHTMLTxtRange_duplicate(body_range, &range);
-    ok(hres == S_OK, "duplicate failed: %08x\n", hres);
+    range = range_duplicate(body_range);
 
     test_range_move(range, wordW, 1, 1);
     test_range_moveend(range, characterW, 2, 2);
@@ -4966,8 +5025,7 @@ static void test_txtrange(IHTMLDocument2 *doc)
 
     IHTMLTxtRange_Release(range);
 
-    hres = IHTMLTxtRange_duplicate(body_range, &range);
-    ok(hres == S_OK, "duplicate failed: %08x\n", hres);
+    range = range_duplicate(body_range);
 
     test_range_move(range, wordW, 2, 2);
     test_range_moveend(range, characterW, 2, 2);
@@ -4991,8 +5049,7 @@ static void test_txtrange(IHTMLDocument2 *doc)
 
     IHTMLTxtRange_Release(range);
 
-    hres = IHTMLTxtRange_duplicate(body_range, &range);
-    ok(hres == S_OK, "duplicate failed: %08x\n", hres);
+    range = range_duplicate(body_range);
 
     test_range_collapse(range, TRUE);
     test_range_expand(range, wordW, VARIANT_TRUE, "test ");
@@ -5015,7 +5072,6 @@ static void test_txtrange(IHTMLDocument2 *doc)
     test_range_text(range, NULL);
 
     IHTMLTxtRange_Release(range);
-    IHTMLTxtRange_Release(body_range);
 
     hres = IHTMLDocument2_get_selection(doc, &selection);
     ok(hres == S_OK, "IHTMLDocument2_get_selection failed: %08x\n", hres);
@@ -5077,9 +5133,39 @@ static void test_txtrange(IHTMLDocument2 *doc)
 
     test_range_text(range, "abc \r\npaste\r\nxyz abc 123\r\nit's text");
 
-    IHTMLElement_Release(body);
+    test_range_move(range, wordW, 2, 2);
+    test_range_collapse(range, VARIANT_TRUE);
+    test_range_moveend(range, characterW, 5, 5);
+    test_range_text(range, "paste");
+
+    range2 = range_duplicate(range);
+
+    test_range_set_end_point(range, "starttostart", body_range, S_OK);
+    test_range_text(range, "abc \r\npaste");
+
+    test_range_set_end_point(range, "endtoend", body_range, S_OK);
+    test_range_text(range, "abc \r\npaste\r\nxyz abc 123\r\nit's text");
+
+    test_range_set_end_point(range, "starttoend", range2, S_OK);
+    test_range_text(range, "\r\nxyz abc 123\r\nit's text");
+
+    test_range_set_end_point(range, "starttostart", body_range, S_OK);
+    test_range_set_end_point(range, "endtostart", range2, S_OK);
+    test_range_text(range, "abc ");
+
+    test_range_set_end_point(range, "starttoend", body_range, S_OK);
+    test_range_text(range, "paste\r\nxyz abc 123\r\nit's text");
+
+    test_range_set_end_point(range, "EndToStart", body_range, S_OK);
+    test_range_text(range, "abc ");
+
+    test_range_set_end_point(range, "xxx", body_range, E_INVALIDARG);
 
     IHTMLTxtRange_Release(range);
+    IHTMLTxtRange_Release(range2);
+    IHTMLTxtRange_Release(body_range);
+    IHTMLElement_Release(body);
+
 }
 
 static void test_txtrange2(IHTMLDocument2 *doc)
@@ -5269,6 +5355,27 @@ static void _test_framebase_put_name(unsigned line, IHTMLElement *elem, const ch
     IHTMLFrameBase_Release(fbase);
 }
 
+#define test_framebase_src(a,b) _test_framebase_src(__LINE__,a,b)
+static void _test_framebase_src(unsigned line, IHTMLElement *elem, const char *src)
+{
+    BSTR str = (void*)0xdeadbeef;
+    IHTMLFrameBase *fbase;
+    HRESULT hres;
+
+    hres = IHTMLElement_QueryInterface(elem, &IID_IHTMLFrameBase, (void**)&fbase);
+    ok(hres == S_OK, "Could not get IHTMLFrameBase interface: 0x%08x\n", hres);
+
+    hres = IHTMLFrameBase_get_src(fbase, &str);
+    ok_(__FILE__,line)(hres == S_OK, "IHTMLFrameBase_get_src failed: 0x%08x\n", hres);
+    if(src)
+        ok_(__FILE__,line)(!strcmp_wa(str, src), "src = %s, expected %s\n", wine_dbgstr_w(str), src);
+    else
+        ok_(__FILE__,line)(!str, "src = %s, expected NULL\n", wine_dbgstr_w(str));
+    SysFreeString(str);
+
+    IHTMLFrameBase_Release(fbase);
+}
+
 #define test_framebase_marginheight(a,b) _test_framebase_marginheight(__LINE__,a,b)
 static void _test_framebase_marginheight(unsigned line, IHTMLFrameBase *framebase, const char *exval)
 {
@@ -5945,8 +6052,10 @@ static void test_defaults(IHTMLDocument2 *doc)
     IHTMLElement2 *elem2;
     IHTMLElement *elem;
     IHTMLStyle *style;
+    VARIANT v;
     BSTR str;
     LONG l;
+    VARIANT_BOOL b;
     HRESULT hres;
     IHTMLElementCollection *collection;
 
@@ -6069,6 +6178,22 @@ static void test_defaults(IHTMLDocument2 *doc)
     hres = IHTMLElement_QueryInterface(elem, &IID_IHTMLFiltersCollection, (void**)&body);
     ok(hres == E_NOINTERFACE, "got interface IHTMLFiltersCollection\n");
 
+    str = a2bstr("xxx");
+    b = 100;
+    V_VT(&v) = VT_EMPTY;
+    hres = IHTMLDocument2_execCommand(doc, str, FALSE, v, &b);
+    ok(hres == OLECMDERR_E_NOTSUPPORTED || hres == E_INVALIDARG,
+       "execCommand failed: %08x, expected OLECMDERR_E_NOTSUPPORTED or E_INVALIDARG\n", hres);
+    SysFreeString(str);
+
+    str = a2bstr("respectvisibilityindesign");
+    b = 100;
+    V_VT(&v) = VT_BOOL;
+    V_BOOL(&v) = VARIANT_TRUE;
+    hres = IHTMLDocument2_execCommand(doc, str, FALSE, v, &b);
+    ok(hres == S_OK, "execCommand failed: %08x, expected DRAGDROP_E_NOTREGISTERED\n", hres);
+    SysFreeString(str);
+
     test_default_selection(doc);
     test_doc_title(doc, "");
     test_dom_implementation(doc);
@@ -6876,6 +7001,7 @@ static void test_iframe_elem(IHTMLElement *elem)
     set_iframe_width(elem, "150px");
     set_iframe_width(elem, "70%");
     test_iframe_width(elem, "70%");
+    test_framebase_src(elem, "about:blank");
 
     str = a2bstr("text/html");
     V_VT(&errv) = VT_ERROR;
@@ -6911,6 +7037,43 @@ static void test_iframe_elem(IHTMLElement *elem)
     IHTMLDocument2_Release(content_doc);
 }
 
+#define test_stylesheet_csstext(a,b,c) _test_stylesheet_csstext(__LINE__,a,b,c)
+static void _test_stylesheet_csstext(unsigned line, IHTMLStyleSheet *stylesheet, const char *exstr, BOOL is_todo)
+{
+    BSTR str;
+    HRESULT hres;
+
+    hres = IHTMLStyleSheet_get_cssText(stylesheet, &str);
+    ok_(__FILE__,line)(hres == S_OK, "get_cssText failed: %08x\n", hres);
+    if(!is_todo) {
+        if(exstr)
+            ok_(__FILE__,line)(is_prefix_wa(str, exstr), "cssText = %s\n", wine_dbgstr_w(str));
+        else
+            ok_(__FILE__,line)(!str, "cssText = %s\n", wine_dbgstr_w(str));
+    }else todo_wine {
+        if(exstr)
+            ok_(__FILE__,line)(is_prefix_wa(str, exstr), "cssText = %s\n", wine_dbgstr_w(str));
+        else
+            ok_(__FILE__,line)(!str, "cssText = %s\n", wine_dbgstr_w(str));
+    }
+
+    SysFreeString(str);
+}
+
+#define set_stylesheet_csstext(a,b,c) _set_stylesheet_csstext(__LINE__,a,b,c)
+static void _set_stylesheet_csstext(unsigned line, IHTMLStyleSheet *stylesheet, const char *csstext, BOOL is_todo)
+{
+    BSTR str = a2bstr(csstext);
+    HRESULT hres;
+
+    hres = IHTMLStyleSheet_put_cssText(stylesheet, str);
+    if(!is_todo)
+        ok_(__FILE__,line)(hres == S_OK, "put_cssText failed: %08x\n", hres);
+    else
+        todo_wine ok_(__FILE__,line)(hres == S_OK, "put_cssText failed: %08x\n", hres);
+    SysFreeString(str);
+}
+
 static void test_stylesheet(IDispatch *disp)
 {
     IHTMLStyleSheetRulesCollection *col = NULL;
@@ -6936,6 +7099,14 @@ static void test_stylesheet(IDispatch *disp)
     ok(href == NULL, "got href != NULL\n");
     SysFreeString(href);
 
+    test_stylesheet_csstext(stylesheet, ".body {", FALSE);
+    set_stylesheet_csstext(stylesheet, ".div { margin-right: 1px; }\n.body { margin-right: 2px; }", TRUE);
+    test_stylesheet_csstext(stylesheet, ".div {", TRUE);
+    set_stylesheet_csstext(stylesheet, "", FALSE);
+    test_stylesheet_csstext(stylesheet, NULL, FALSE);
+    set_stylesheet_csstext(stylesheet, ".div { margin-right: 1px; }", FALSE);
+    test_stylesheet_csstext(stylesheet, ".div {", FALSE);
+
     IHTMLStyleSheet_Release(stylesheet);
 }
 
@@ -8074,6 +8245,11 @@ static void test_create_elems(IHTMLDocument2 *doc)
     test_text_data((IUnknown*)node, "abc");
     set_text_data((IUnknown*)node, "test");
     test_text_data((IUnknown*)node, "test");
+    text_append_data((IUnknown*)node, " append");
+    test_text_data((IUnknown*)node, "test append");
+    text_append_data((IUnknown*)node, NULL);
+    test_text_data((IUnknown*)node, "test append");
+    set_text_data((IUnknown*)node, "test");
 
     V_VT(&var) = VT_NULL;
     node2 = test_node_insertbefore((IUnknown*)body, node, &var);
@@ -8577,6 +8753,7 @@ static void test_frameset(IHTMLDocument2 *doc)
     test_framebase_put_name(elem, "frame name");
     test_framebase_put_name(elem, NULL);
     test_framebase_put_name(elem, "nm1");
+    test_framebase_src(elem, "about:blank");
     IHTMLElement_Release(elem);
 
     /* get_name with no name attr */
diff --git a/dlls/mshtml/tests/htmldoc.c b/dlls/mshtml/tests/htmldoc.c
index 84b8806..ace3128 100644
--- a/dlls/mshtml/tests/htmldoc.c
+++ b/dlls/mshtml/tests/htmldoc.c
@@ -2988,6 +2988,9 @@ static HRESULT WINAPI OleCommandTarget_Exec(IOleCommandTarget *iface, const GUID
         case 144: /* TODO */
         case 178:
         case 179:
+        case 180:
+        case 181:
+        case 182:
             return E_NOTIMPL;
 
         default:
diff --git a/dlls/mshtml/tests/nav_test.html b/dlls/mshtml/tests/nav_test.html
index 536b238..11c4c0c 100644
--- a/dlls/mshtml/tests/nav_test.html
+++ b/dlls/mshtml/tests/nav_test.html
@@ -43,9 +43,24 @@ function window_navigate_test() {
     iframe.contentWindow.navigate("about:blank");
 }
 
+function detached_src_test() {
+    var iframe = document.createElement("iframe");
+    var onload_called = false;
+
+    iframe.onload = function() {
+        onload_called = true;
+        next_test();
+    }
+
+    iframe.src = "blank.html";
+    document.body.appendChild(iframe);
+    ok(onload_called === false, "called onload too early?");
+}
+
 var tests = [
     nav_back_test,
     window_navigate_test,
+    detached_src_test,
     function() { external.reportSuccess(); }
 ];
 
diff --git a/dlls/mshtml/txtrange.c b/dlls/mshtml/txtrange.c
index 43c9f1a..0dd3aae 100644
--- a/dlls/mshtml/txtrange.c
+++ b/dlls/mshtml/txtrange.c
@@ -1627,8 +1627,74 @@ static HRESULT WINAPI HTMLTxtRange_setEndPoint(IHTMLTxtRange *iface, BSTR how,
         IHTMLTxtRange *SourceRange)
 {
     HTMLTxtRange *This = impl_from_IHTMLTxtRange(iface);
-    FIXME("(%p)->(%s %p)\n", This, debugstr_w(how), SourceRange);
-    return E_NOTIMPL;
+    HTMLTxtRange *src_range;
+    nsIDOMNode *ref_node;
+    INT32 ref_offset;
+    BOOL set_start;
+    int how_type;
+    INT16 cmp;
+    nsresult nsres;
+
+    TRACE("(%p)->(%s %p)\n", This, debugstr_w(how), SourceRange);
+
+    how_type = string_to_nscmptype(how);
+    if(how_type == -1)
+        return E_INVALIDARG;
+
+    src_range = get_range_object(This->doc, SourceRange);
+    if(!src_range)
+        return E_FAIL;
+
+    switch(how_type) {
+    case NS_START_TO_START:
+    case NS_END_TO_START:
+        nsres = nsIDOMRange_GetStartContainer(src_range->nsrange, &ref_node);
+        assert(nsres == NS_OK);
+
+        nsres = nsIDOMRange_GetStartOffset(src_range->nsrange, &ref_offset);
+        assert(nsres == NS_OK);
+
+        set_start = how_type == NS_START_TO_START;
+        break;
+    case NS_END_TO_END:
+    case NS_START_TO_END:
+        nsres = nsIDOMRange_GetEndContainer(src_range->nsrange, &ref_node);
+        assert(nsres == NS_OK);
+
+        nsres = nsIDOMRange_GetEndOffset(src_range->nsrange, &ref_offset);
+        assert(nsres == NS_OK);
+
+        set_start = how_type == NS_START_TO_END;
+        break;
+    DEFAULT_UNREACHABLE;
+    }
+
+    nsres = nsIDOMRange_ComparePoint(This->nsrange, ref_node, ref_offset, &cmp);
+    assert(nsres == NS_OK);
+
+    if(set_start) {
+        if(cmp <= 0) {
+            nsres = nsIDOMRange_SetStart(This->nsrange, ref_node, ref_offset);
+        }else {
+            nsres = nsIDOMRange_Collapse(This->nsrange, FALSE);
+            assert(nsres == NS_OK);
+
+            nsres = nsIDOMRange_SetEnd(This->nsrange, ref_node, ref_offset);
+        }
+    }else {
+        if(cmp >= 0) {
+            nsres = nsIDOMRange_SetEnd(This->nsrange, ref_node, ref_offset);
+        }else {
+            nsres = nsIDOMRange_Collapse(This->nsrange, TRUE);
+            assert(nsres == NS_OK);
+
+            nsres = nsIDOMRange_SetStart(This->nsrange, ref_node, ref_offset);
+        }
+    }
+    assert(nsres == NS_OK);
+
+    nsIDOMNode_Release(ref_node);
+    return S_OK;
 }
 
 static HRESULT WINAPI HTMLTxtRange_compareEndPoints(IHTMLTxtRange *iface, BSTR how,
diff --git a/dlls/msi/tests/automation.c b/dlls/msi/tests/automation.c
index beed6fd..016b1a2 100644
--- a/dlls/msi/tests/automation.c
+++ b/dlls/msi/tests/automation.c
@@ -1935,7 +1935,7 @@ static void test_Session(IDispatch *pSession)
 
     hr = Session_ModePut(pSession, MSIRUNMODE_REBOOTNOW, TRUE);
     ok(hr == S_OK, "Session_ModePut failed, hresult 0x%08x\n", hr);
-    if (hr == DISP_E_EXCEPTION) ok_exception(hr, szModeFlag);
+    ok_exception(hr, szModeFlag);
 
     hr = Session_ModeGet(pSession, MSIRUNMODE_REBOOTNOW, &bool);
     ok(hr == S_OK, "Session_ModeGet failed, hresult 0x%08x\n", hr);
@@ -1943,7 +1943,7 @@ static void test_Session(IDispatch *pSession)
 
     hr = Session_ModePut(pSession, MSIRUNMODE_REBOOTNOW, FALSE);  /* set it again so we don't reboot */
     ok(hr == S_OK, "Session_ModePut failed, hresult 0x%08x\n", hr);
-    if (hr == DISP_E_EXCEPTION) ok_exception(hr, szModeFlag);
+    ok_exception(hr, szModeFlag);
 
     hr = Session_ModePut(pSession, MSIRUNMODE_MAINTENANCE, TRUE);
     ok(hr == DISP_E_EXCEPTION, "Session_ModePut failed, hresult 0x%08x\n", hr);
diff --git a/dlls/msvcp120/msvcp120.spec b/dlls/msvcp120/msvcp120.spec
index 0c346ca..422f0b6 100644
--- a/dlls/msvcp120/msvcp120.spec
+++ b/dlls/msvcp120/msvcp120.spec
@@ -517,9 +517,9 @@
 @ cdecl -arch=arm ??1ctype_base@std@@UAA@XZ(ptr) ctype_base_dtor
 @ thiscall -arch=i386 ??1ctype_base@std@@UAE@XZ(ptr) ctype_base_dtor
 @ cdecl -arch=win64 ??1ctype_base@std@@UEAA@XZ(ptr) ctype_base_dtor
-@ stub -arch=arm ??1facet@locale@std@@MAA@XZ
-@ stub -arch=i386 ??1facet@locale@std@@MAE@XZ
-@ stub -arch=win64 ??1facet@locale@std@@MEAA@XZ
+@ cdecl -arch=arm ??1facet@locale@std@@MAA@XZ(ptr) locale_facet_dtor
+@ thiscall -arch=i386 ??1facet@locale@std@@MAE@XZ(ptr) locale_facet_dtor
+@ cdecl -arch=win64 ??1facet@locale@std@@MEAA@XZ(ptr) locale_facet_dtor
 @ cdecl -arch=arm ??1ios_base@std@@UAA@XZ(ptr) ios_base_dtor
 @ thiscall -arch=i386 ??1ios_base@std@@UAE@XZ(ptr) ios_base_dtor
 @ cdecl -arch=win64 ??1ios_base@std@@UEAA@XZ(ptr) ios_base_dtor
@@ -913,9 +913,9 @@
 @ cdecl -arch=arm ??Bid@locale@std@@QAAIXZ(ptr) locale_id_operator_size_t
 @ thiscall -arch=i386 ??Bid@locale@std@@QAEIXZ(ptr) locale_id_operator_size_t
 @ cdecl -arch=win64 ??Bid@locale@std@@QEAA_KXZ(ptr) locale_id_operator_size_t
-@ stub -arch=arm ??Bios_base@std@@QBA_NXZ
-@ stub -arch=win32 ??Bios_base@std@@QBE_NXZ
-@ stub -arch=win64 ??Bios_base@std@@QEBA_NXZ
+@ cdecl -arch=arm ??Bios_base@std@@QBA_NXZ(ptr) ios_base_operator_bool
+@ thiscall -arch=i386 ??Bios_base@std@@QBE_NXZ(ptr) ios_base_operator_bool
+@ cdecl -arch=win64 ??Bios_base@std@@QEBA_NXZ(ptr) ios_base_operator_bool
 @ extern ??_7?$basic_ios@DU?$char_traits@D@std@@@std@@6B@ MSVCP_basic_ios_char_vtable
 @ extern ??_7?$basic_ios@GU?$char_traits@G@std@@@std@@6B@ MSVCP_basic_ios_short_vtable
 @ extern ??_7?$basic_ios@_WU?$char_traits@_W@std@@@std@@6B@ MSVCP_basic_ios_wchar_vtable
diff --git a/dlls/msvcp90/ios.c b/dlls/msvcp90/ios.c
index b758887..80aebec 100644
--- a/dlls/msvcp90/ios.c
+++ b/dlls/msvcp90/ios.c
@@ -5042,6 +5042,16 @@ void* __thiscall ios_base_op_fail(const ios_base *this)
     return ios_base_fail(this) ? NULL : (void*)this;
 }
 
+/* ??Bios_base@std@@QBA_NXZ */
+/* ??Bios_base@std@@QBE_NXZ */
+/* ??Bios_base@std@@QEBA_NXZ */
+DEFINE_THISCALL_WRAPPER(ios_base_operator_bool, 4)
+MSVCP_bool __thiscall ios_base_operator_bool(const ios_base *this)
+{
+    TRACE("(%p)\n", this);
+    return (this->state & (IOSTATE_failbit|IOSTATE_badbit)) == 0;
+}
+
 /* ?_Addstd@ios_base@std@@SAXPAV12@@Z */
 /* ?_Addstd@ios_base@std@@SAXPEAV12@@Z */
 void CDECL ios_base_Addstd(ios_base *add)
diff --git a/dlls/msvcp90/locale.c b/dlls/msvcp90/locale.c
index 551a924d..097dad8 100644
--- a/dlls/msvcp90/locale.c
+++ b/dlls/msvcp90/locale.c
@@ -214,6 +214,9 @@ static void ostreambuf_iterator_wchar_put(ostreambuf_iterator_wchar *this, wchar
 
 /* ??1facet@locale@std@@UAE@XZ */
 /* ??1facet@locale@std@@UEAA@XZ */
+/* ??1facet@locale@std@@MAA@XZ */
+/* ??1facet@locale@std@@MAE@XZ */
+/* ??1facet@locale@std@@MEAA@XZ */
 DEFINE_THISCALL_WRAPPER(locale_facet_dtor, 4)
 void __thiscall locale_facet_dtor(locale_facet *this)
 {
diff --git a/dlls/msxml3/xdr.c b/dlls/msxml3/xdr.c
index af86907..fd7a9b7 100644
--- a/dlls/msxml3/xdr.c
+++ b/dlls/msxml3/xdr.c
@@ -38,7 +38,6 @@ WINE_DEFAULT_DEBUG_CHANNEL(msxml);
 
 static const xmlChar DT_prefix[] = "dt";
 static const xmlChar DT_href[] = "urn:schemas-microsoft-com:datatypes";
-static const xmlChar XDR_prefix[] = "xdr";
 static const xmlChar XDR_href[] = "urn:schemas-microsoft-com:xml-data";
 static const xmlChar XSD_prefix[] = "xsd";
 static const xmlChar XSD_href[] = "http://www.w3.org/2001/XMLSchema";
@@ -51,7 +50,6 @@ static const xmlChar xs_attribute[] = "attribute";
 static const xmlChar xs_AttributeType[] = "AttributeType";
 static const xmlChar xs_base[] = "base";
 static const xmlChar xs_choice[] = "choice";
-static const xmlChar xs_complexContent[] = "complexContent";
 static const xmlChar xs_complexType[] = "complexType";
 static const xmlChar xs_content[] = "content";
 static const xmlChar xs_datatype[] = "datatype";
@@ -61,7 +59,6 @@ static const xmlChar xs_documentation[] = "documentation";
 static const xmlChar xs_element[] = "element";
 static const xmlChar xs_ElementType[] = "ElementType";
 static const xmlChar xs_eltOnly[] = "eltOnly";
-static const xmlChar xs_empty[] = "empty";
 static const xmlChar xs_enumeration[] = "enumeration";
 static const xmlChar xs_extension[] = "extension";
 static const xmlChar xs_group[] = "group";
@@ -75,7 +72,6 @@ static const xmlChar xs_model[] = "model";
 static const xmlChar xs_name[] = "name";
 static const xmlChar xs_namespace[] = "namespace";
 static const xmlChar xs_no[] = "no";
-static const xmlChar xs_one[] = "one";
 static const xmlChar xs_open[] = "open";
 static const xmlChar xs_optional[] = "optional";
 static const xmlChar xs_order[] = "order";
@@ -84,7 +80,6 @@ static const xmlChar xs_ref[] = "ref";
 static const xmlChar xs_required[] = "required";
 static const xmlChar xs_restriction[] = "restriction";
 static const xmlChar xs_schema[] = "schema";
-static const xmlChar xs_Schema[] = "Schema";
 static const xmlChar xs_seq[] = "seq";
 static const xmlChar xs_sequence[] = "sequence";
 static const xmlChar xs_simpleContent[] = "simpleContent";
@@ -99,7 +94,6 @@ static const xmlChar xs_use[] = "use";
 static const xmlChar xs_value[] = "value";
 static const xmlChar xs_values[] = "values";
 static const xmlChar xs_xsd_string[] = "xsd:string";
-static const xmlChar xs_yes[] = "yes";
 
 typedef enum _CONTENT_TYPE
 {
diff --git a/dlls/ole2disp.dll16/ole2disp.c b/dlls/ole2disp.dll16/ole2disp.c
index 957d1bc..61a4043 100644
--- a/dlls/ole2disp.dll16/ole2disp.c
+++ b/dlls/ole2disp.dll16/ole2disp.c
@@ -214,6 +214,16 @@ int WINAPI SysStringLen16(BSTR16 str)
 }
 
 /******************************************************************************
+ * VariantChangeType [OLE2DISP.12]
+ */
+HRESULT WINAPI VariantChangeType16(VARIANTARG *vargDest, VARIANTARG *varSrc, unsigned short flags, VARTYPE vt)
+{
+    FIXME("stub: (%p, %p, %d, %d)\n", vargDest, varSrc, flags, vt);
+    return E_NOTIMPL;
+}
+
+
+/******************************************************************************
  * CreateDispTypeInfo [OLE2DISP.31]
  */
 HRESULT WINAPI CreateDispTypeInfo16(
diff --git a/dlls/ole2disp.dll16/ole2disp.dll16.spec b/dlls/ole2disp.dll16/ole2disp.dll16.spec
index 0bc4bae..c027d12 100644
--- a/dlls/ole2disp.dll16/ole2disp.dll16.spec
+++ b/dlls/ole2disp.dll16/ole2disp.dll16.spec
@@ -9,7 +9,7 @@
 9 stub VARIANTCLEAR
 10 stub VARIANTCOPY
 11 stub VARIANTCOPYIND
-12 stub VARIANTCHANGETYPE
+12 pascal VARIANTCHANGETYPE(ptr ptr long long) VariantChangeType16
 13 stub VARIANTTIMETODOSDATETIME
 14 stub DOSDATETIMETOVARIANTTIME
 15 stub SAFEARRAYCREATE
diff --git a/dlls/ole32/compobj.c b/dlls/ole32/compobj.c
index 1fab04f..da466c4 100644
--- a/dlls/ole32/compobj.c
+++ b/dlls/ole32/compobj.c
@@ -4427,10 +4427,22 @@ HRESULT WINAPI CoWaitForMultipleHandles(DWORD dwFlags, DWORD dwTimeout,
     DWORD start_time = GetTickCount();
     APARTMENT *apt = COM_CurrentApt();
     BOOL message_loop = apt && !apt->multi_threaded;
+    BOOL check_apc = (dwFlags & COWAIT_ALERTABLE) != 0;
 
     TRACE("(0x%08x, 0x%08x, %d, %p, %p)\n", dwFlags, dwTimeout, cHandles,
         pHandles, lpdwindex);
 
+    if (!lpdwindex)
+        return E_INVALIDARG;
+
+    *lpdwindex = 0;
+
+    if (!pHandles)
+        return E_INVALIDARG;
+
+    if (!cHandles)
+        return RPC_E_NO_SYNC;
+
     while (TRUE)
     {
         DWORD now = GetTickCount();
@@ -4449,9 +4461,19 @@ HRESULT WINAPI CoWaitForMultipleHandles(DWORD dwFlags, DWORD dwTimeout,
 
             TRACE("waiting for rpc completion or window message\n");
 
-            res = MsgWaitForMultipleObjectsEx(cHandles, pHandles,
-                (dwTimeout == INFINITE) ? INFINITE : start_time + dwTimeout - now,
-                QS_SENDMESSAGE | QS_ALLPOSTMESSAGE | QS_PAINT, wait_flags);
+            res = WAIT_TIMEOUT;
+
+            if (check_apc)
+            {
+                res = WaitForMultipleObjectsEx(cHandles, pHandles,
+                    (dwFlags & COWAIT_WAITALL) != 0, 0, TRUE);
+                check_apc = FALSE;
+            }
+
+            if (res == WAIT_TIMEOUT)
+                res = MsgWaitForMultipleObjectsEx(cHandles, pHandles,
+                    (dwTimeout == INFINITE) ? INFINITE : start_time + dwTimeout - now,
+                    QS_SENDMESSAGE | QS_ALLPOSTMESSAGE | QS_PAINT, wait_flags);
 
             if (res == WAIT_OBJECT_0 + cHandles)  /* messages available */
             {
diff --git a/dlls/ole32/tests/compobj.c b/dlls/ole32/tests/compobj.c
index 1dfa9fb..eed5ac8 100644
--- a/dlls/ole32/tests/compobj.c
+++ b/dlls/ole32/tests/compobj.c
@@ -31,6 +31,7 @@
 #include "objbase.h"
 #include "shlguid.h"
 #include "urlmon.h" /* for CLSID_FileProtocol */
+#include "dde.h"
 
 #include "ctxtcall.h"
 
@@ -1910,10 +1911,10 @@ static void test_CoGetContextToken(void)
     ok(hr == S_OK, "Expected S_OK, got 0x%08x\n", hr);
     todo_wine ok(ctx == (IObjContext *)token, "Expected interface pointers to be the same\n");
 
-    refs = IUnknown_AddRef((IUnknown *)ctx);
+    refs = IObjContext_AddRef(ctx);
     todo_wine ok(refs == 3, "Expected 3, got %u\n", refs);
 
-    refs = IUnknown_Release((IUnknown *)ctx);
+    refs = IObjContext_Release(ctx);
     todo_wine ok(refs == 2, "Expected 2, got %u\n", refs);
 
     refs = IUnknown_Release((IUnknown *)token);
@@ -1926,13 +1927,13 @@ static void test_CoGetContextToken(void)
     ok(token, "Expected token != 0\n");
     todo_wine ok(ctx == (IObjContext *)token, "Expected interface pointers to be the same\n");
 
-    refs = IUnknown_AddRef((IUnknown *)ctx);
+    refs = IObjContext_AddRef(ctx);
     ok(refs == 2, "Expected 1, got %u\n", refs);
 
-    refs = IUnknown_Release((IUnknown *)ctx);
+    refs = IObjContext_Release(ctx);
     ok(refs == 1, "Expected 0, got %u\n", refs);
 
-    refs = IUnknown_Release((IUnknown *)ctx);
+    refs = IObjContext_Release(ctx);
     ok(refs == 0, "Expected 0, got %u\n", refs);
 
     CoUninitialize();
@@ -2034,6 +2035,7 @@ static void test_CoInitializeEx(void)
     /* Cleanup */
     CoUninitialize();
     OleUninitialize();
+    OleUninitialize();
 }
 
 static void test_OleRegGetMiscStatus(void)
@@ -2088,6 +2090,199 @@ static void test_CoCreateGuid(void)
     ok(hr == E_INVALIDARG, "got 0x%08x\n", hr);
 }
 
+static void CALLBACK apc_test_proc(ULONG_PTR param)
+{
+    /* nothing */
+}
+
+static DWORD CALLBACK release_semaphore_thread( LPVOID arg )
+{
+    HANDLE handle = arg;
+    if (WaitForSingleObject(handle, 200) == WAIT_TIMEOUT)
+        ReleaseSemaphore(handle, 1, NULL);
+    return 0;
+}
+
+static void test_CoWaitForMultipleHandles(void)
+{
+    static const char cls_name[] = "cowait_test_class";
+    HANDLE handles[2], thread;
+    DWORD index, tid;
+    WNDCLASSEXA wc;
+    BOOL success;
+    HRESULT hr;
+    HWND hWnd;
+    MSG msg;
+
+    hr = pCoInitializeEx(NULL, COINIT_APARTMENTTHREADED);
+    ok(hr == S_OK, "CoInitializeEx failed with error 0x%08x\n", hr);
+
+    memset(&wc, 0, sizeof(wc));
+    wc.cbSize        = sizeof(wc);
+    wc.style         = CS_VREDRAW | CS_HREDRAW;
+    wc.hInstance     = GetModuleHandleA(0);
+    wc.hCursor       = LoadCursorA(NULL, (LPCSTR)IDC_ARROW);
+    wc.hbrBackground = NULL;
+    wc.lpszClassName = cls_name;
+    wc.lpfnWndProc   = DefWindowProcA;
+    success = RegisterClassExA(&wc) != 0;
+    ok(success, "RegisterClassExA failed %u\n", GetLastError());
+
+    hWnd = CreateWindowExA(0, cls_name, "Test", WS_TILEDWINDOW, 0, 0, 640, 480, 0, 0, 0, 0);
+    ok(hWnd != 0, "CreateWindowExA failed %u\n", GetLastError());
+    handles[0] = CreateSemaphoreA(NULL, 1, 1, NULL);
+    ok(handles[0] != 0, "CreateSemaphoreA failed %u\n", GetLastError());
+    handles[1] = CreateSemaphoreA(NULL, 1, 1, NULL);
+    ok(handles[1] != 0, "CreateSemaphoreA failed %u\n", GetLastError());
+
+    /* test without flags */
+
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 0, handles, NULL);
+    ok(hr == E_INVALIDARG, "expected E_INVALIDARG, got 0x%08x\n", hr);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 0, NULL, &index);
+    ok(hr == E_INVALIDARG, "expected E_INVALIDARG, got 0x%08x\n", hr);
+    ok(index == 0, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 0, handles, &index);
+    ok(hr == RPC_E_NO_SYNC, "expected RPC_E_NO_SYNC, got 0x%08x\n", hr);
+    ok(index == 0, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 1, handles, &index);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(index == 0, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 2, handles, &index);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(index == 1, "expected index 1, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
+
+    ReleaseSemaphore(handles[0], 1, NULL);
+    ReleaseSemaphore(handles[1], 1, NULL);
+
+    /* test with COWAIT_WAITALL */
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(COWAIT_WAITALL, 50, 2, handles, &index);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(index == 0, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(0, 50, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
+
+    ReleaseSemaphore(handles[0], 1, NULL);
+    ReleaseSemaphore(handles[1], 1, NULL);
+
+    /* test with COWAIT_ALERTABLE */
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(COWAIT_ALERTABLE, 50, 1, handles, &index);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(index == 0, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(COWAIT_ALERTABLE, 50, 2, handles, &index);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(index == 1, "expected index 1, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    hr = CoWaitForMultipleHandles(COWAIT_ALERTABLE, 50, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    success = QueueUserAPC(apc_test_proc, GetCurrentThread(), 0);
+    ok(success, "QueueUserAPC failed %u\n", GetLastError());
+    hr = CoWaitForMultipleHandles(COWAIT_ALERTABLE, 50, 2, handles, &index);
+    ok(hr == S_OK, "expected S_OK, got 0x%08x\n", hr);
+    ok(index == WAIT_IO_COMPLETION, "expected index WAIT_IO_COMPLETION, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(success, "CoWaitForMultipleHandles unexpectedly pumped messages\n");
+
+    /* test with COWAIT_INPUTAVAILABLE (semaphores are still locked) */
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_NOREMOVE);
+    ok(success, "PeekMessageA returned FALSE\n");
+    hr = CoWaitForMultipleHandles(0, 50, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING, "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ok(index == 0 || broken(index == 0xdeadbeef) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success, "CoWaitForMultipleHandles didn't pump any messages\n");
+
+    index = 0xdeadbeef;
+    PostMessageA(hWnd, WM_DDE_FIRST, 0, 0);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_NOREMOVE);
+    ok(success, "PeekMessageA returned FALSE\n");
+    thread = CreateThread(NULL, 0, release_semaphore_thread, handles[1], 0, &tid);
+    ok(thread != NULL, "CreateThread failed, error %u\n", GetLastError());
+    hr = CoWaitForMultipleHandles(COWAIT_INPUTAVAILABLE, 50, 2, handles, &index);
+    ok(hr == RPC_S_CALLPENDING || broken(hr == E_INVALIDARG) || broken(hr == S_OK) /* Win 8 */,
+       "expected RPC_S_CALLPENDING, got 0x%08x\n", hr);
+    ReleaseSemaphore(handles[1], 1, NULL);
+    ok(index == 0 || broken(index == 1) /* Win 8 */, "expected index 0, got %u\n", index);
+    success = PeekMessageA(&msg, hWnd, WM_DDE_FIRST, WM_DDE_FIRST, PM_REMOVE);
+    ok(!success || broken(success && hr == E_INVALIDARG),
+       "CoWaitForMultipleHandles didn't pump any messages\n");
+    index = WaitForSingleObject(thread, 200);
+    ok(index == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(thread);
+
+    CloseHandle(handles[0]);
+    CloseHandle(handles[1]);
+    DestroyWindow(hWnd);
+
+    success = UnregisterClassA(cls_name, GetModuleHandleA(0));
+    ok(success, "UnregisterClass failed %u\n", GetLastError());
+
+    CoUninitialize();
+}
+
 static void init_funcs(void)
 {
     HMODULE hOle32 = GetModuleHandleA("ole32");
@@ -2148,4 +2343,5 @@ START_TEST(compobj)
     test_CoInitializeEx();
     test_OleRegGetMiscStatus();
     test_CoCreateGuid();
+    test_CoWaitForMultipleHandles();
 }
diff --git a/dlls/ole32/tests/moniker.c b/dlls/ole32/tests/moniker.c
index 1ff7159..695f67a 100644
--- a/dlls/ole32/tests/moniker.c
+++ b/dlls/ole32/tests/moniker.c
@@ -2022,9 +2022,7 @@ static void test_save_load_filemoniker(void)
 
     hr = IMoniker_Save(pMk, pStm, TRUE);
     ok_ole_success(hr, "IMoniker_Save");
-
-    hr = IMoniker_Release(pMk);
-    ok_ole_success(hr, "IMoniker_Release");
+    IMoniker_Release(pMk);
 
     /* overwrite the constants with various values */
     hr = IStream_Seek(pStm, zero_pos, STREAM_SEEK_SET, NULL);
@@ -2055,11 +2053,8 @@ static void test_save_load_filemoniker(void)
     hr = IMoniker_Load(pMk, pStm);
     ok_ole_success(hr, "IMoniker_Load");
 
-    hr = IMoniker_Release(pMk);
-    ok_ole_success(hr, "IMoniker_Release");
-
-    hr = IStream_Release(pStm);
-    ok_ole_success(hr, "IStream_Release");
+    IMoniker_Release(pMk);
+    IStream_Release(pStm);
 }
 
 START_TEST(moniker)
diff --git a/dlls/opengl32/Makefile.in b/dlls/opengl32/Makefile.in
index 890b5b6..4df6bce 100644
--- a/dlls/opengl32/Makefile.in
+++ b/dlls/opengl32/Makefile.in
@@ -1,6 +1,7 @@
 MODULE    = opengl32.dll
 IMPORTLIB = opengl32
 IMPORTS   = user32 gdi32 advapi32
+EXTRADLLFLAGS = -Wl,--image-base,0x7a800000
 
 C_SRCS = \
 	opengl_ext.c \
diff --git a/dlls/riched20/editor.c b/dlls/riched20/editor.c
index 8fdaa53..ca316d2 100644
--- a/dlls/riched20/editor.c
+++ b/dlls/riched20/editor.c
@@ -2889,7 +2889,7 @@ void ME_DestroyEditor(ME_TextEditor *editor)
   ITextHost_Release(editor->texthost);
   if (editor->reOle)
   {
-    DestroyIRichEditOle(editor->reOle);
+    IRichEditOle_Release(editor->reOle);
     editor->reOle = NULL;
   }
   OleUninitialize();
diff --git a/dlls/scrrun/tests/filesystem.c b/dlls/scrrun/tests/filesystem.c
index faa0b0c..54cf4e3 100644
--- a/dlls/scrrun/tests/filesystem.c
+++ b/dlls/scrrun/tests/filesystem.c
@@ -893,7 +893,7 @@ static void test_FolderCollection(void)
 
     hr = IFolder_get_Path(folder, &str);
     ok(hr == S_OK, "got 0x%08x\n", hr);
-    ok(!lstrcmpW(buffW, str), "got %s, expected %s\n", wine_dbgstr_w(str), wine_dbgstr_w(buffW));
+    ok(!lstrcmpiW(buffW, str), "got %s, expected %s\n", wine_dbgstr_w(str), wine_dbgstr_w(buffW));
     SysFreeString(str);
 
     lstrcpyW(pathW, buffW);
diff --git a/dlls/shell32/tests/shlfileop.c b/dlls/shell32/tests/shlfileop.c
index 51de635..07e4ee2 100644
--- a/dlls/shell32/tests/shlfileop.c
+++ b/dlls/shell32/tests/shlfileop.c
@@ -251,7 +251,7 @@ static void test_get_file_info(void)
     ok(rc == 1, "SHGetFileInfoA(c:\\nonexistent) should return 1, got 0x%x\n", rc);
     if (rc)
     {
-        ok(strcpy(shfi.szDisplayName, "dummy") != 0, "SHGetFileInfoA(c:\\nonexistent) displayname is not set\n");
+        ok(strcmp(shfi.szDisplayName, "dummy"), "SHGetFileInfoA(c:\\nonexistent) displayname is not set\n");
         ok(shfi.iIcon != 0xdeadbeef, "SHGetFileInfoA(c:\\nonexistent) iIcon is not set\n");
     }
 
diff --git a/dlls/shlwapi/ordinal.c b/dlls/shlwapi/ordinal.c
index 8d3f1eb..0ea235c 100644
--- a/dlls/shlwapi/ordinal.c
+++ b/dlls/shlwapi/ordinal.c
@@ -5054,11 +5054,8 @@ INT WINAPI SHFormatDateTimeW(const FILETIME UNALIGNED *fileTime, DWORD *flags,
         {
             if ((fmt_flags & FDTF_LONGDATE) && (ret < size + 2))
             {
-                if (ret < size + 2)
-                {
-                   lstrcatW(&buf[ret-1], sep1);
-                   ret += 2;
-                }
+                lstrcatW(&buf[ret-1], sep1);
+                ret += 2;
             }
             else
             {
diff --git a/dlls/shlwapi/path.c b/dlls/shlwapi/path.c
index 5c7a88a..a3b462c 100644
--- a/dlls/shlwapi/path.c
+++ b/dlls/shlwapi/path.c
@@ -3313,6 +3313,9 @@ HRESULT WINAPI PathCreateFromUrlW(LPCWSTR pszUrl, LPWSTR pszPath,
     if (!pszUrl || !pszPath || !pcchPath || !*pcchPath)
         return E_INVALIDARG;
 
+    if (lstrlenW(pszUrl) < 5)
+        return E_INVALIDARG;
+
     if (CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, pszUrl, 5,
                        file_colon, 5) != CSTR_EQUAL)
         return E_INVALIDARG;
@@ -3354,9 +3357,8 @@ HRESULT WINAPI PathCreateFromUrlW(LPCWSTR pszUrl, LPWSTR pszPath,
             src -= 1;
         break;
     case 2:
-        if (CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE, src, 9,
-                           localhost, 9) == CSTR_EQUAL &&
-            (src[9] == '/' || src[9] == '\\'))
+        if (lstrlenW(src) >= 10 && CompareStringW(LOCALE_INVARIANT, NORM_IGNORECASE,
+            src, 9, localhost, 9) == CSTR_EQUAL && (src[9] == '/' || src[9] == '\\'))
         {
             /* 'file://localhost/' + escaped DOS path */
             src += 10;
diff --git a/dlls/shlwapi/string.c b/dlls/shlwapi/string.c
index b4b5b8a..9ba6038 100644
--- a/dlls/shlwapi/string.c
+++ b/dlls/shlwapi/string.c
@@ -364,7 +364,7 @@ int WINAPI StrCmpIW(LPCWSTR lpszStr, LPCWSTR lpszComp)
  * PARAMS
  *  lpszStr  [I] First string to compare
  *  lpszComp [I] Second string to compare
- *  iLen     [I] Maximum number of chars to compare.
+ *  iLen     [I] Number of chars to compare
  *
  * RETURNS
  *  An integer less than, equal to or greater than 0, indicating that
@@ -395,7 +395,7 @@ INT WINAPI StrCmpNW(LPCWSTR lpszStr, LPCWSTR lpszComp, INT iLen)
  * PARAMS
  *  lpszStr  [I] First string to compare
  *  lpszComp [I] Second string to compare
- *  iLen     [I] Maximum number of chars to compare.
+ *  iLen     [I] Number of chars to compare
  *
  * RETURNS
  *  An integer less than, equal to or greater than 0, indicating that
@@ -521,13 +521,15 @@ static LPSTR SHLWAPI_StrStrHelperA(LPCSTR lpszStr, LPCSTR lpszSearch,
                                    INT (WINAPI *pStrCmpFn)(LPCSTR,LPCSTR,INT))
 {
   size_t iLen;
+  LPCSTR end;
 
   if (!lpszStr || !lpszSearch || !*lpszSearch)
     return NULL;
 
   iLen = strlen(lpszSearch);
+  end = lpszStr + strlen(lpszStr);
 
-  while (*lpszStr)
+  while (lpszStr + iLen <= end)
   {
     if (!pStrCmpFn(lpszStr, lpszSearch, iLen))
       return (LPSTR)lpszStr;
@@ -583,6 +585,7 @@ LPWSTR WINAPI StrStrW(LPCWSTR lpszStr, LPCWSTR lpszSearch)
  */
 LPSTR WINAPI StrRStrIA(LPCSTR lpszStr, LPCSTR lpszEnd, LPCSTR lpszSearch)
 {
+  LPSTR lpszRet = NULL;
   WORD ch1, ch2;
   INT iLen;
 
@@ -591,28 +594,28 @@ LPSTR WINAPI StrRStrIA(LPCSTR lpszStr, LPCSTR lpszEnd, LPCSTR lpszSearch)
   if (!lpszStr || !lpszSearch || !*lpszSearch)
     return NULL;
 
-  if (!lpszEnd)
-    lpszEnd = lpszStr + lstrlenA(lpszStr);
-  if (lpszEnd == lpszStr)
-    return NULL;
-
   if (IsDBCSLeadByte(*lpszSearch))
     ch1 = *lpszSearch << 8 | (UCHAR)lpszSearch[1];
   else
     ch1 = *lpszSearch;
   iLen = lstrlenA(lpszSearch);
 
-  do
+  if (!lpszEnd)
+    lpszEnd = lpszStr + lstrlenA(lpszStr);
+  else /* reproduce the broken behaviour on Windows */
+    lpszEnd += min(iLen - 1, lstrlenA(lpszEnd));
+
+  while (lpszStr + iLen <= lpszEnd && *lpszStr)
   {
-    lpszEnd = CharPrevA(lpszStr, lpszEnd);
-    ch2 = IsDBCSLeadByte(*lpszEnd)? *lpszEnd << 8 | (UCHAR)lpszEnd[1] : *lpszEnd;
+    ch2 = IsDBCSLeadByte(*lpszStr)? *lpszStr << 8 | (UCHAR)lpszStr[1] : *lpszStr;
     if (!ChrCmpIA(ch1, ch2))
     {
-      if (!StrCmpNIA(lpszEnd, lpszSearch, iLen))
-        return (LPSTR)lpszEnd;
+      if (!StrCmpNIA(lpszStr, lpszSearch, iLen))
+        lpszRet = (LPSTR)lpszStr;
     }
-  } while (lpszEnd > lpszStr);
-  return NULL;
+    lpszStr = CharNextA(lpszStr);
+  }
+  return lpszRet;
 }
 
 /*************************************************************************
@@ -622,6 +625,7 @@ LPSTR WINAPI StrRStrIA(LPCSTR lpszStr, LPCSTR lpszEnd, LPCSTR lpszSearch)
  */
 LPWSTR WINAPI StrRStrIW(LPCWSTR lpszStr, LPCWSTR lpszEnd, LPCWSTR lpszSearch)
 {
+  LPWSTR lpszRet = NULL;
   INT iLen;
 
   TRACE("(%s,%s)\n", debugstr_w(lpszStr), debugstr_w(lpszSearch));
@@ -629,18 +633,23 @@ LPWSTR WINAPI StrRStrIW(LPCWSTR lpszStr, LPCWSTR lpszEnd, LPCWSTR lpszSearch)
   if (!lpszStr || !lpszSearch || !*lpszSearch)
     return NULL;
 
+  iLen = strlenW(lpszSearch);
+
   if (!lpszEnd)
     lpszEnd = lpszStr + strlenW(lpszStr);
+  else /* reproduce the broken behaviour on Windows */
+    lpszEnd += min(iLen - 1, lstrlenW(lpszEnd));
 
-  iLen = strlenW(lpszSearch);
-
-  while (lpszEnd > lpszStr)
+  while (lpszStr + iLen <= lpszEnd && *lpszStr)
   {
-    lpszEnd--;
-    if (!StrCmpNIW(lpszEnd, lpszSearch, iLen))
-      return (LPWSTR)lpszEnd;
+    if (!ChrCmpIW(*lpszSearch, *lpszStr))
+    {
+      if (!StrCmpNIW(lpszStr, lpszSearch, iLen))
+        lpszRet = (LPWSTR)lpszStr;
+    }
+    lpszStr++;
   }
-  return NULL;
+  return lpszRet;
 }
 
 /*************************************************************************
@@ -670,6 +679,7 @@ LPSTR WINAPI StrStrIA(LPCSTR lpszStr, LPCSTR lpszSearch)
 LPWSTR WINAPI StrStrIW(LPCWSTR lpszStr, LPCWSTR lpszSearch)
 {
   int iLen;
+  LPCWSTR end;
 
   TRACE("(%s,%s)\n", debugstr_w(lpszStr), debugstr_w(lpszSearch));
 
@@ -677,8 +687,9 @@ LPWSTR WINAPI StrStrIW(LPCWSTR lpszStr, LPCWSTR lpszSearch)
     return NULL;
 
   iLen = strlenW(lpszSearch);
+  end = lpszStr + strlenW(lpszStr);
 
-  while (*lpszStr)
+  while (lpszStr + iLen <= end)
   {
     if (!StrCmpNIW(lpszStr, lpszSearch, iLen))
       return (LPWSTR)lpszStr;
diff --git a/dlls/user32/tests/msg.c b/dlls/user32/tests/msg.c
index 9b7453f..778b3cf 100644
--- a/dlls/user32/tests/msg.c
+++ b/dlls/user32/tests/msg.c
@@ -4621,9 +4621,21 @@ static void test_MsgWaitForMultipleObjects(HWND hwnd)
     ok(ret == WAIT_IO_COMPLETION, "MsgWaitForMultipleObjectsEx returned %x\n", ret);
 }
 
+static DWORD CALLBACK show_window_thread(LPVOID arg)
+{
+   HWND hwnd = arg;
+
+   /* function will not return if ShowWindow(SW_HIDE) calls SendMessage() */
+   ok(ShowWindow(hwnd, SW_HIDE) == FALSE, "ShowWindow(SW_HIDE) expected FALSE\n");
+
+   return 0;
+}
+
 /* test if we receive the right sequence of messages */
 static void test_messages(void)
 {
+    DWORD tid;
+    HANDLE hthread;
     HWND hwnd, hparent, hchild;
     HWND hchild2, hbutton;
     HMENU hmenu;
@@ -4656,6 +4668,19 @@ static void test_messages(void)
     flush_events();
     ok_sequence(WmHideOverlappedSeq, "ShowWindow(SW_HIDE):overlapped", FALSE);
 
+    /* test ShowWindow(SW_HIDE) on a hidden window - single threaded */
+    ok(ShowWindow(hwnd, SW_HIDE) == FALSE, "ShowWindow(SW_HIDE) expected FALSE\n");
+    flush_events();
+    ok_sequence(WmEmptySeq, "ShowWindow(SW_HIDE):overlapped", FALSE);
+
+    /* test ShowWindow(SW_HIDE) on a hidden window -  multi-threaded */
+    hthread = CreateThread(NULL, 0, show_window_thread, hwnd, 0, &tid);
+    ok(hthread != NULL, "CreateThread failed, error %d\n", GetLastError());
+    ok(WaitForSingleObject(hthread, INFINITE) == WAIT_OBJECT_0, "WaitForSingleObject failed\n");
+    CloseHandle(hthread);
+    flush_events();
+    ok_sequence(WmEmptySeq, "ShowWindow(SW_HIDE):overlapped", FALSE);
+
     ShowWindow(hwnd, SW_SHOW);
     flush_events();
     ok_sequence(WmShowOverlappedSeq, "ShowWindow(SW_SHOW):overlapped", TRUE);
diff --git a/dlls/user32/tests/win.c b/dlls/user32/tests/win.c
index cfc2a02..404017f 100644
--- a/dlls/user32/tests/win.c
+++ b/dlls/user32/tests/win.c
@@ -63,6 +63,8 @@ static DWORD (WINAPI *pGetLayout)(HDC hdc);
 static BOOL (WINAPI *pMirrorRgn)(HWND hwnd, HRGN hrgn);
 
 static BOOL test_lbuttondown_flag;
+static DWORD num_gettext_msgs;
+static DWORD num_settext_msgs;
 static HWND hwndMessage;
 static HWND hwndMain, hwndMain2;
 static HHOOK hhook;
@@ -794,6 +796,12 @@ static LRESULT WINAPI main_window_procA(HWND hwnd, UINT msg, WPARAM wparam, LPAR
                 flush_events( FALSE );
             }
             break;
+        case WM_GETTEXT:
+            num_gettext_msgs++;
+            break;
+        case WM_SETTEXT:
+            num_settext_msgs++;
+            break;
     }
 
     return DefWindowProcA(hwnd, msg, wparam, lparam);
@@ -5685,23 +5693,132 @@ static void test_ShowWindow(void)
     ok(!IsWindow(hwnd), "window should not exist\n");
 }
 
+static DWORD CALLBACK gettext_msg_thread( LPVOID arg )
+{
+    HWND hwnd = arg;
+    char buf[32];
+    INT buf_len;
+
+    /* test GetWindowTextA */
+    num_gettext_msgs = 0;
+    memset( buf, 0, sizeof(buf) );
+    buf_len = GetWindowTextA( hwnd, buf, sizeof(buf) );
+    ok( buf_len != 0, "expected a nonempty window text\n" );
+    ok( !strcmp(buf, "another_caption"), "got wrong window text '%s'\n", buf );
+    ok( num_gettext_msgs == 1, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    return 0;
+}
+
+static DWORD CALLBACK settext_msg_thread( LPVOID arg )
+{
+    HWND hwnd = arg;
+    BOOL success;
+
+    /* test SetWindowTextA */
+    num_settext_msgs = 0;
+    success = SetWindowTextA( hwnd, "thread_caption" );
+    ok( success, "SetWindowTextA failed\n" );
+    ok( num_settext_msgs == 1, "got %u WM_SETTEXT messages\n", num_settext_msgs );
+
+    return 0;
+}
+
 static void test_gettext(void)
 {
-    WNDCLASSA cls;
-    LPCSTR clsname = "gettexttest";
+    DWORD tid, num_msgs;
+    HANDLE thread;
+    BOOL success;
+    char buf[32];
+    INT buf_len;
     HWND hwnd;
     LRESULT r;
+    MSG msg;
 
-    memset( &cls, 0, sizeof cls );
-    cls.lpfnWndProc = DefWindowProcA;
-    cls.lpszClassName = clsname;
-    cls.hInstance = GetModuleHandleA(NULL);
+    hwnd = CreateWindowExA( 0, "MainWindowClass", "caption", WS_POPUP, 0, 0, 0, 0, 0, 0, 0, NULL );
+    ok( hwnd != 0, "CreateWindowExA error %d\n", GetLastError() );
 
-    if (!RegisterClassA( &cls )) return;
+    /* test GetWindowTextA */
+    num_gettext_msgs = 0;
+    memset( buf, 0, sizeof(buf) );
+    buf_len = GetWindowTextA( hwnd, buf, sizeof(buf) );
+    ok( buf_len != 0, "expected a nonempty window text\n" );
+    ok( !strcmp(buf, "caption"), "got wrong window text '%s'\n", buf );
+    ok( num_gettext_msgs == 1, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    /* test WM_GETTEXT */
+    num_gettext_msgs = 0;
+    memset( buf, 0, sizeof(buf) );
+    r = SendMessageA( hwnd, WM_GETTEXT, sizeof(buf), (LONG_PTR)buf );
+    ok( r != 0, "expected a nonempty window text\n" );
+    ok( !strcmp(buf, "caption"), "got wrong window text '%s'\n", buf );
+    ok( num_gettext_msgs == 1, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    /* test SetWindowTextA */
+    num_settext_msgs = 0;
+    success = SetWindowTextA( hwnd, "new_caption" );
+    ok( success, "SetWindowTextA failed\n" );
+    ok( num_settext_msgs == 1, "got %u WM_SETTEXT messages\n", num_settext_msgs );
+
+    num_gettext_msgs = 0;
+    memset( buf, 0, sizeof(buf) );
+    buf_len = GetWindowTextA( hwnd, buf, sizeof(buf) );
+    ok( buf_len != 0, "expected a nonempty window text\n" );
+    ok( !strcmp(buf, "new_caption"), "got wrong window text '%s'\n", buf );
+    ok( num_gettext_msgs == 1, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    /* test WM_SETTEXT */
+    num_settext_msgs = 0;
+    r = SendMessageA( hwnd, WM_SETTEXT, 0, (ULONG_PTR)"another_caption" );
+    ok( r != 0, "WM_SETTEXT failed\n" );
+    ok( num_settext_msgs == 1, "got %u WM_SETTEXT messages\n", num_settext_msgs );
+
+    num_gettext_msgs = 0;
+    memset( buf, 0, sizeof(buf) );
+    buf_len = GetWindowTextA( hwnd, buf, sizeof(buf) );
+    ok( buf_len != 0, "expected a nonempty window text\n" );
+    ok( !strcmp(buf, "another_caption"), "got wrong window text '%s'\n", buf );
+    ok( num_gettext_msgs == 1, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE ))
+        DispatchMessageA( &msg );
+
+    /* test interthread GetWindowTextA */
+    num_msgs = 0;
+    thread = CreateThread( NULL, 0, gettext_msg_thread, hwnd, 0, &tid );
+    ok(thread != NULL, "CreateThread failed, error %d\n", GetLastError());
+    while (MsgWaitForMultipleObjects( 1, &thread, FALSE, INFINITE, QS_SENDMESSAGE ) != WAIT_OBJECT_0)
+    {
+        while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE ))
+            DispatchMessageA( &msg );
+        num_msgs++;
+    }
+    CloseHandle( thread );
+    ok( num_msgs == 1, "got %u wakeups from MsgWaitForMultipleObjects\n", num_msgs );
+
+    /* test interthread SetWindowText */
+    num_msgs = 0;
+    thread = CreateThread( NULL, 0, settext_msg_thread, hwnd, 0, &tid );
+    ok(thread != NULL, "CreateThread failed, error %d\n", GetLastError());
+    while (MsgWaitForMultipleObjects( 1, &thread, FALSE, INFINITE, QS_SENDMESSAGE ) != WAIT_OBJECT_0)
+    {
+        while (PeekMessageA( &msg, 0, 0, 0, PM_REMOVE | PM_QS_SENDMESSAGE ))
+            DispatchMessageA( &msg );
+        num_msgs++;
+    }
+    CloseHandle( thread );
+    ok( num_msgs == 1, "got %u wakeups from MsgWaitForMultipleObjects\n", num_msgs );
 
-    hwnd = CreateWindowA( clsname, "test text", WS_OVERLAPPED, 0, 0, 10, 10, 0, NULL, NULL, NULL);
-    ok( hwnd != NULL, "window was null\n");
+    num_gettext_msgs = 0;
+    memset( buf, 0, sizeof(buf) );
+    buf_len = GetWindowTextA( hwnd, buf, sizeof(buf) );
+    ok( buf_len != 0, "expected a nonempty window text\n" );
+    ok( !strcmp(buf, "thread_caption"), "got wrong window text '%s'\n", buf );
+    ok( num_gettext_msgs == 1, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
 
+    /* seems to crash on every modern Windows version */
+    if (0)
+    {
     r = SendMessageA( hwnd, WM_GETTEXT, 0x10, 0x1000);
     ok( r == 0, "settext should return zero\n");
 
@@ -5713,9 +5830,9 @@ static void test_gettext(void)
 
     r = SendMessageA( hwnd, WM_GETTEXT, 0x1000, 0xff000000);
     ok( r == 0, "settext should return zero (%ld)\n", r);
+    }
 
     DestroyWindow(hwnd);
-    UnregisterClassA( clsname, NULL );
 }
 
 
@@ -6931,32 +7048,44 @@ todo_wine
 static void test_FindWindowEx(void)
 {
     HWND hwnd, found;
-    CHAR title[1];
 
     hwnd = CreateWindowExA( 0, "MainWindowClass", "caption", WS_POPUP, 0,0,0,0, 0, 0, 0, NULL );
     ok( hwnd != 0, "CreateWindowExA error %d\n", GetLastError() );
 
-    title[0] = 0;
-
-    found = FindWindowExA( 0, 0, "MainWindowClass", title );
+    num_gettext_msgs = 0;
+    found = FindWindowExA( 0, 0, "MainWindowClass", "" );
     ok( found == NULL, "expected a NULL hwnd\n" );
+    ok( num_gettext_msgs == 0, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    num_gettext_msgs = 0;
     found = FindWindowExA( 0, 0, "MainWindowClass", NULL );
     ok( found == hwnd, "found is %p, expected a valid hwnd\n", found );
+    ok( num_gettext_msgs == 0, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    num_gettext_msgs = 0;
+    found = FindWindowExA( 0, 0, "MainWindowClass", "caption" );
+    ok( found == hwnd, "found is %p, expected a valid hwnd\n", found );
+    ok( num_gettext_msgs == 0, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
 
     DestroyWindow( hwnd );
 
     hwnd = CreateWindowExA( 0, "MainWindowClass", NULL, WS_POPUP, 0,0,0,0, 0, 0, 0, NULL );
     ok( hwnd != 0, "CreateWindowExA error %d\n", GetLastError() );
 
-    found = FindWindowExA( 0, 0, "MainWindowClass", title );
+    num_gettext_msgs = 0;
+    found = FindWindowExA( 0, 0, "MainWindowClass", "" );
     ok( found == hwnd, "found is %p, expected a valid hwnd\n", found );
+    ok( num_gettext_msgs == 0, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
+
+    num_gettext_msgs = 0;
     found = FindWindowExA( 0, 0, "MainWindowClass", NULL );
     ok( found == hwnd, "found is %p, expected a valid hwnd\n", found );
+    ok( num_gettext_msgs == 0, "got %u WM_GETTEXT messages\n", num_gettext_msgs );
 
     DestroyWindow( hwnd );
 
     /* test behaviour with a window title that is an empty character */
-    found = FindWindowExA( 0, 0, "Shell_TrayWnd", title );
+    found = FindWindowExA( 0, 0, "Shell_TrayWnd", "" );
     ok( found != NULL, "found is NULL, expected a valid hwnd\n" );
     found = FindWindowExA( 0, 0, "Shell_TrayWnd", NULL );
     ok( found != NULL, "found is NULL, expected a valid hwnd\n" );
@@ -7968,7 +8097,7 @@ START_TEST(win)
     test_csparentdc();
     test_SetWindowLong();
     test_ShowWindow();
-    if (0) test_gettext(); /* crashes on NT4 */
+    test_gettext();
     test_GetUpdateRect();
     test_Expose();
     test_layered_window();
diff --git a/dlls/user32/win.c b/dlls/user32/win.c
index 73cad0c..0516193 100644
--- a/dlls/user32/win.c
+++ b/dlls/user32/win.c
@@ -1941,7 +1941,7 @@ HWND WINAPI FindWindowExW( HWND parent, HWND child, LPCWSTR className, LPCWSTR t
     {
         while (list[i])
         {
-            if (GetWindowTextW( list[i], buffer, len + 1 ))
+            if (InternalGetWindowText( list[i], buffer, len + 1 ))
             {
                 if (!strcmpiW( buffer, title )) break;
             }
diff --git a/dlls/user32/winpos.c b/dlls/user32/winpos.c
index 5373733..12d3ffa 100644
--- a/dlls/user32/winpos.c
+++ b/dlls/user32/winpos.c
@@ -1219,6 +1219,9 @@ BOOL WINAPI ShowWindow( HWND hwnd, INT cmd )
     if ((full_handle = WIN_IsCurrentThread( hwnd )))
         return show_window( full_handle, cmd );
 
+    if ((cmd == SW_HIDE) && !(GetWindowLongW( hwnd, GWL_STYLE ) & WS_VISIBLE))
+        return FALSE;
+
     return SendMessageW( hwnd, WM_WINE_SHOWWINDOW, cmd, 0 );
 }
 
diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
index a7bc23d..fecce4c 100644
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -706,7 +706,7 @@ static void shader_arb_load_constants_internal(struct shader_arb_priv *priv,
     {
         const struct wined3d_shader *pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         const struct arb_ps_compiled_shader *gl_shader = priv->compiled_fprog;
-        UINT rt_height = state->fb->render_targets[0]->height;
+        UINT rt_height = state->fb.render_targets[0]->height;
 
         /* Load DirectX 9 float constants for pixel shader */
         priv->highest_dirty_ps_const = shader_arb_load_constantsF(pshader, gl_info, GL_FRAGMENT_PROGRAM_ARB,
@@ -4673,7 +4673,7 @@ static void shader_arb_select(void *shader_priv, struct wined3d_context *context
         }
         else
         {
-            UINT rt_height = state->fb->render_targets[0]->height;
+            UINT rt_height = state->fb.render_targets[0]->height;
             shader_arb_ps_local_constants(compiled, context, state, rt_height);
         }
 
@@ -5279,6 +5279,7 @@ static const SHADER_HANDLER shader_arb_instruction_handler_table[WINED3DSIH_TABL
     /* WINED3DSIH_TEXREG2GB             */ pshader_hw_texreg2gb,
     /* WINED3DSIH_TEXREG2RGB            */ pshader_hw_texreg2rgb,
     /* WINED3DSIH_UDIV                  */ NULL,
+    /* WINED3DSIH_UGE                   */ NULL,
     /* WINED3DSIH_USHR                  */ NULL,
     /* WINED3DSIH_UTOF                  */ NULL,
     /* WINED3DSIH_XOR                   */ NULL,
@@ -7643,7 +7644,7 @@ HRESULT arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
 
     /* Now load the surface */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-            && (src_surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
+            && (src_surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_DRAWABLE))
             == WINED3D_LOCATION_DRAWABLE
             && !wined3d_resource_is_offscreen(&src_surface->container->resource))
     {
@@ -7673,15 +7674,17 @@ HRESULT arbfp_blit_surface(struct wined3d_device *device, DWORD filter,
     /* Leave the opengl state valid for blitting */
     arbfp_blit_unset(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
+    if (wined3d_settings.cs_multithreaded)
+        context->gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
             || (dst_surface->container->swapchain
             && (dst_surface->container->swapchain->front_buffer == dst_surface->container)))
         context->gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
 
-    surface_validate_location(dst_surface, dst_surface->container->resource.draw_binding);
-    surface_invalidate_location(dst_surface, ~dst_surface->container->resource.draw_binding);
+    wined3d_resource_validate_location(&dst_surface->resource, dst_surface->container->resource.draw_binding);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->container->resource.draw_binding);
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/buffer.c b/dlls/wined3d/buffer.c
index 989026f..b33dd5a 100644
--- a/dlls/wined3d/buffer.c
+++ b/dlls/wined3d/buffer.c
@@ -32,17 +32,16 @@ WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 #define WINED3D_BUFFER_HASDESC      0x01    /* A vertex description has been found. */
 #define WINED3D_BUFFER_CREATEBO     0x02    /* Create a buffer object for this buffer. */
 #define WINED3D_BUFFER_DOUBLEBUFFER 0x04    /* Keep both a buffer object and a system memory copy for this buffer. */
-#define WINED3D_BUFFER_FLUSH        0x08    /* Manual unmap flushing. */
-#define WINED3D_BUFFER_DISCARD      0x10    /* A DISCARD lock has occurred since the last preload. */
-#define WINED3D_BUFFER_SYNC         0x20    /* There has been at least one synchronized map since the last preload. */
-#define WINED3D_BUFFER_APPLESYNC    0x40    /* Using sync as in GL_APPLE_flush_buffer_range. */
+#define WINED3D_BUFFER_DISCARD      0x08    /* The next PreLoad may discard the buffer contents. */
+#define WINED3D_BUFFER_SYNC         0x10    /* There has been at least one synchronized map since the last preload. */
+#define WINED3D_BUFFER_APPLESYNC    0x20    /* Using sync as in GL_APPLE_flush_buffer_range. */
 
 #define VB_MAXDECLCHANGES     100     /* After that number of decl changes we stop converting */
 #define VB_RESETDECLCHANGE    1000    /* Reset the decl changecount after that number of draws */
 #define VB_MAXFULLCONVERSIONS 5       /* Number of full conversions before we stop converting */
 #define VB_RESETFULLCONVS     20      /* Reset full conversion counts after that number of draws */
 
-static void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
+void buffer_invalidate_bo_range(struct wined3d_buffer *buffer, UINT offset, UINT size)
 {
     if (!offset && !size)
         goto invalidate_all;
@@ -118,7 +117,7 @@ static void delete_gl_buffer(struct wined3d_buffer *This, const struct wined3d_g
 }
 
 /* Context activation is done by the caller. */
-static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
+void buffer_create_buffer_object(struct wined3d_buffer *This, struct wined3d_context *context)
 {
     GLenum gl_usage = GL_STATIC_DRAW_ARB;
     GLenum error;
@@ -167,8 +166,6 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
         {
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_FLUSHING_UNMAP_APPLE, GL_FALSE)");
-            This->flags |= WINED3D_BUFFER_FLUSH;
-
             GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE));
             checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_FALSE)");
             This->flags |= WINED3D_BUFFER_APPLESYNC;
@@ -194,7 +191,10 @@ static void buffer_create_buffer_object(struct wined3d_buffer *This, struct wine
     if (This->flags & WINED3D_BUFFER_DOUBLEBUFFER)
         buffer_invalidate_bo_range(This, 0, 0);
     else
+    {
         wined3d_resource_free_sysmem(&This->resource);
+        This->resource.map_heap_memory = NULL;
+    }
 
     return;
 
@@ -423,7 +423,7 @@ static inline void fixup_d3dcolor(DWORD *dst_color)
 {
     DWORD src_color = *dst_color;
 
-    /* Color conversion like in drawStridedSlow. watch out for little endianity
+    /* Color conversion like in draw_strided_slow. watch out for little endianity
      * If we want that stuff to work on big endian machines too we have to consider more things
      *
      * 0xff000000: Alpha mask
@@ -457,7 +457,8 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
     data->buffer_object = buffer->buffer_object;
     if (!buffer->buffer_object)
     {
-        if ((buffer->flags & WINED3D_BUFFER_CREATEBO) && !buffer->resource.map_count)
+        if ((!buffer->resource.map_count || buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER)
+                && buffer->flags & WINED3D_BUFFER_CREATEBO)
         {
             buffer_create_buffer_object(buffer, context);
             buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
@@ -496,6 +497,7 @@ BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *con
 
     if (!wined3d_resource_allocate_sysmem(&This->resource))
         ERR("Failed to allocate system memory.\n");
+    This->resource.heap_memory = This->resource.map_heap_memory;
 
     if (This->buffer_type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
         context_invalidate_state(context, STATE_INDEXBUFFER);
@@ -543,28 +545,38 @@ static void buffer_unload(struct wined3d_resource *resource)
     resource_unload(resource);
 }
 
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer)
+{
+    struct wined3d_context *context;
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->buffer_object)
+    {
+        context = context_acquire(device, NULL);
+        delete_gl_buffer(buffer, context->gl_info);
+        context_release(context);
+
+        HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
+    }
+
+    HeapFree(GetProcessHeap(), 0, buffer->maps);
+    HeapFree(GetProcessHeap(), 0, buffer);
+}
+
 ULONG CDECL wined3d_buffer_decref(struct wined3d_buffer *buffer)
 {
     ULONG refcount = InterlockedDecrement(&buffer->resource.ref);
-    struct wined3d_context *context;
 
     TRACE("%p decreasing refcount to %u.\n", buffer, refcount);
 
     if (!refcount)
     {
-        if (buffer->buffer_object)
-        {
-            context = context_acquire(buffer->resource.device, NULL);
-            delete_gl_buffer(buffer, context->gl_info);
-            context_release(context);
-
-            HeapFree(GetProcessHeap(), 0, buffer->conversion_map);
-        }
+        struct wined3d_device *device = buffer->resource.device;
 
         resource_cleanup(&buffer->resource);
+
         buffer->resource.parent_ops->wined3d_object_destroyed(buffer->resource.parent);
-        HeapFree(GetProcessHeap(), 0, buffer->maps);
-        HeapFree(GetProcessHeap(), 0, buffer);
+        wined3d_cs_emit_buffer_cleanup(device->cs, buffer);
     }
 
     return refcount;
@@ -649,43 +661,29 @@ drop_query:
 /* The caller provides a GL context */
 static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined3d_gl_info *gl_info, DWORD flags)
 {
-    BYTE *map;
     UINT start = 0, len = 0;
 
     /* This potentially invalidates the element array buffer binding, but the
      * caller always takes care of this. */
     GL_EXTCALL(glBindBufferARB(This->buffer_type_hint, This->buffer_object));
     checkGLcall("glBindBufferARB");
-    if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+
+    if (flags & WINED3D_BUFFER_DISCARD)
     {
-        GLbitfield mapflags;
-        mapflags = GL_MAP_WRITE_BIT | GL_MAP_FLUSH_EXPLICIT_BIT;
-        if (flags & WINED3D_BUFFER_DISCARD)
-            mapflags |= GL_MAP_INVALIDATE_BUFFER_BIT;
-        else if (!(flags & WINED3D_BUFFER_SYNC))
-            mapflags |= GL_MAP_UNSYNCHRONIZED_BIT;
-        map = GL_EXTCALL(glMapBufferRange(This->buffer_type_hint, 0,
-                    This->resource.size, mapflags));
-        checkGLcall("glMapBufferRange");
+        GL_EXTCALL(glBufferDataARB(This->buffer_type_hint, This->resource.size, NULL, GL_STREAM_DRAW_ARB));
+        checkGLcall("glBufferDataARB");
     }
-    else
+    else if (flags & WINED3D_BUFFER_SYNC && This->flags & WINED3D_BUFFER_APPLESYNC)
     {
-        if (This->flags & WINED3D_BUFFER_APPLESYNC)
-        {
-            DWORD syncflags = 0;
-            if (flags & WINED3D_BUFFER_DISCARD)
-                syncflags |= WINED3D_MAP_DISCARD;
-            else if (!(flags & WINED3D_BUFFER_SYNC))
-                syncflags |= WINED3D_MAP_NOOVERWRITE;
-            buffer_sync_apple(This, syncflags, gl_info);
-        }
-        map = GL_EXTCALL(glMapBufferARB(This->buffer_type_hint, GL_WRITE_ONLY_ARB));
-        checkGLcall("glMapBufferARB");
-    }
-    if (!map)
-    {
-        ERR("Failed to map opengl buffer\n");
-        return;
+        /* OSX doesn't do non-blocking asynchonous glBufferSubData like Linux drivers do, so we want to set
+         * GL_BUFFER_SERIALIZED_MODIFY_APPLE to GL_FALSE. Unfortunately ARB_sync and APPLE_fence are pretty
+         * slow on OSX. Putting the buffer back into synchronized mode for future maps is a lot faster.
+         * (GeForce 650M, Mavericks). The difference between ARB_sync and normal buffer operation is small
+         * in the glMapBuffer codepath without CSMT. */
+        glFinish();
+        GL_EXTCALL(glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE));
+        checkGLcall("glBufferParameteriAPPLE(This->buffer_type_hint, GL_BUFFER_SERIALIZED_MODIFY_APPLE, GL_TRUE)");
+        This->flags &= ~WINED3D_BUFFER_APPLESYNC;
     }
 
     while (This->modified_areas)
@@ -694,24 +692,12 @@ static void buffer_direct_upload(struct wined3d_buffer *This, const struct wined
         start = This->maps[This->modified_areas].offset;
         len = This->maps[This->modified_areas].size;
 
-        memcpy(map + start, (BYTE *)This->resource.heap_memory + start, len);
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GL_EXTCALL(glFlushMappedBufferRange(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRange");
-        }
-        else if (This->flags & WINED3D_BUFFER_FLUSH)
-        {
-            GL_EXTCALL(glFlushMappedBufferRangeAPPLE(This->buffer_type_hint, start, len));
-            checkGLcall("glFlushMappedBufferRangeAPPLE");
-        }
+        GL_EXTCALL(glBufferSubDataARB(This->buffer_type_hint, start, len, (BYTE *)This->resource.heap_memory + start));
+        checkGLcall("glBufferSubDataARB");
     }
-    GL_EXTCALL(glUnmapBufferARB(This->buffer_type_hint));
-    checkGLcall("glUnmapBufferARB");
 }
 
-void buffer_mark_used(struct wined3d_buffer *buffer)
+static void buffer_mark_used(struct wined3d_buffer *buffer)
 {
     buffer->flags &= ~(WINED3D_BUFFER_SYNC | WINED3D_BUFFER_DISCARD);
 }
@@ -730,12 +716,6 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
     TRACE("buffer %p.\n", buffer);
 
-    if (buffer->resource.map_count)
-    {
-        WARN("Buffer is mapped, skipping preload.\n");
-        return;
-    }
-
     buffer_mark_used(buffer);
 
     if (!buffer->buffer_object)
@@ -924,10 +904,15 @@ void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_conte
 
 void CDECL wined3d_buffer_preload(struct wined3d_buffer *buffer)
 {
-    struct wined3d_context *context;
-    context = context_acquire(buffer->resource.device, NULL);
-    buffer_internal_preload(buffer, context, NULL);
-    context_release(context);
+    struct wined3d_device *device = buffer->resource.device;
+
+    if (buffer->resource.map_count)
+    {
+        WARN("Buffer is mapped, skipping preload.\n");
+        return;
+    }
+
+    wined3d_cs_emit_buffer_preload(device->cs, buffer);
 }
 
 struct wined3d_resource * CDECL wined3d_buffer_get_resource(struct wined3d_buffer *buffer)
@@ -941,9 +926,31 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
 {
     LONG count;
     BYTE *base;
+    struct wined3d_device *device = buffer->resource.device;
+    struct wined3d_context *context;
 
     TRACE("buffer %p, offset %u, size %u, data %p, flags %#x\n", buffer, offset, size, data, flags);
 
+    /* FIXME: There is a race condition with the same code in
+     * buffer_internal_preload and buffer_get_memory.
+     *
+     * This deals with a race condition concering buffer creation and buffer maps.
+     * If a VBO is created by the worker thread while the buffer is mapped, outdated
+     * data may be uploaded, and the BO range is not properly invaliated. Keep in
+     * mind that a broken application might draw from a buffer before mapping it.
+     *
+     * Don't try to solve this by going back to always invalidating changed areas.
+     * This won't work if we ever want to support glMapBufferRange mapping with
+     * GL_ARB_buffer_storage in the CS.
+     *
+     * Also keep in mind that UnLoad can destroy the VBO, so simply creating it
+     * on buffer creation won't work either. */
+    if (buffer->flags & WINED3D_BUFFER_CREATEBO)
+    {
+        wined3d_cs_emit_create_vbo(device->cs, buffer);
+        buffer->flags &= ~WINED3D_BUFFER_CREATEBO;
+    }
+
     flags = wined3d_resource_sanitize_map_flags(&buffer->resource, flags);
     /* Filter redundant WINED3D_MAP_DISCARD maps. The 3DMark2001 multitexture
      * fill rate test seems to depend on this. When we map a buffer with
@@ -951,7 +958,7 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
      * previous contents of the buffer. The r600g driver only does this when
      * the buffer is currently in use, while the proprietary NVIDIA driver
      * appears to do this unconditionally. */
-    if (buffer->flags & WINED3D_BUFFER_DISCARD)
+    if (buffer->ignore_discard)
         flags &= ~WINED3D_MAP_DISCARD;
     count = ++buffer->resource.map_count;
 
@@ -962,18 +969,24 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
          * being uploaded in that case. Two such applications are Port Royale
          * and Darkstar One. */
         if (flags & WINED3D_MAP_DISCARD)
-            buffer_invalidate_bo_range(buffer, 0, 0);
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, 0, 0);
         else if (!(flags & WINED3D_MAP_READONLY))
-            buffer_invalidate_bo_range(buffer, offset, size);
+            wined3d_cs_emit_buffer_invalidate_bo_range(device->cs, buffer, offset, size);
 
         if (!(buffer->flags & WINED3D_BUFFER_DOUBLEBUFFER))
         {
             if (count == 1)
             {
                 struct wined3d_device *device = buffer->resource.device;
-                struct wined3d_context *context;
                 const struct wined3d_gl_info *gl_info;
 
+                if (wined3d_settings.cs_multithreaded)
+                {
+                    FIXME("waiting for cs\n");
+                    wined3d_cs_emit_glfinish(device->cs);
+                    device->cs->ops->finish(device->cs);
+                }
+
                 context = context_acquire(device, NULL);
                 gl_info = context->gl_info;
 
@@ -1023,19 +1036,42 @@ HRESULT CDECL wined3d_buffer_map(struct wined3d_buffer *buffer, UINT offset, UIN
                         buffer_get_sysmem(buffer, context);
                     }
                     TRACE("New pointer is %p.\n", buffer->resource.heap_memory);
-                    buffer->map_ptr = NULL;
                 }
                 context_release(context);
             }
         }
+        else if(!wined3d_settings.cs_multithreaded)
+        {
+            if (flags & WINED3D_MAP_DISCARD)
+            {
+                buffer->flags |= WINED3D_BUFFER_DISCARD;
+                buffer->ignore_discard = TRUE;
+            }
+            else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+                buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
+    }
 
-        if (flags & WINED3D_MAP_DISCARD)
-            buffer->flags |= WINED3D_BUFFER_DISCARD;
-        else if (!(flags & WINED3D_MAP_NOOVERWRITE))
+    if (wined3d_settings.cs_multithreaded && count == 1)
+    {
+        BOOL swvp = device->create_parms.flags & WINED3DCREATE_SOFTWARE_VERTEXPROCESSING;
+        if (flags & WINED3D_MAP_DISCARD && !swvp)
+        {
+            buffer->ignore_discard = TRUE;
+            wined3d_resource_allocate_sysmem(&buffer->resource);
+            wined3d_cs_emit_buffer_swap_mem(device->cs, buffer, buffer->resource.map_heap_memory);
+        }
+        else if(!(flags & (WINED3D_MAP_NOOVERWRITE | WINED3D_MAP_READONLY)) && !buffer->ignore_discard)
+        {
+            wined3d_resource_wait_fence(&buffer->resource);
+            /* Writing to the (otherwise worker thread controlled)
+             * flags field is OK here since the wait_fence call made
+             * sure the buffer is idle. */
             buffer->flags |= WINED3D_BUFFER_SYNC;
+        }
     }
 
-    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.heap_memory;
+    base = buffer->map_ptr ? buffer->map_ptr : buffer->resource.map_heap_memory;
     *data = base + offset;
 
     TRACE("Returning memory at %p (base %p, offset %u).\n", *data, base, offset);
@@ -1089,7 +1125,7 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
                 checkGLcall("glFlushMappedBufferRange");
             }
         }
-        else if (buffer->flags & WINED3D_BUFFER_FLUSH)
+        else if (buffer->flags & WINED3D_BUFFER_APPLESYNC)
         {
             for (i = 0; i < buffer->modified_areas; ++i)
             {
@@ -1100,17 +1136,15 @@ void CDECL wined3d_buffer_unmap(struct wined3d_buffer *buffer)
         }
 
         GL_EXTCALL(glUnmapBufferARB(buffer->buffer_type_hint));
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
         context_release(context);
 
         buffer_clear_dirty_areas(buffer);
         buffer->map_ptr = NULL;
     }
-    else if (buffer->flags & WINED3D_BUFFER_HASDESC)
-    {
-        wined3d_buffer_preload(buffer);
-    }
 }
 
 static ULONG buffer_resource_incref(struct wined3d_resource *resource)
@@ -1123,11 +1157,25 @@ static ULONG buffer_resource_decref(struct wined3d_resource *resource)
     return wined3d_buffer_decref(buffer_from_resource(resource));
 }
 
+static void wined3d_buffer_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    ERR("Not yet implemented.\n");
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_buffer_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Not yet implemented.\n");
+}
+
 static const struct wined3d_resource_ops buffer_resource_ops =
 {
     buffer_resource_incref,
     buffer_resource_decref,
     buffer_unload,
+    wined3d_buffer_location_invalidated,
+    wined3d_buffer_load_location,
 };
 
 static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device *device,
@@ -1154,6 +1202,7 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
         return hr;
     }
     buffer->buffer_type_hint = bind_hint;
+    buffer->ignore_discard = TRUE;
 
     TRACE("size %#x, usage %#x, format %s, memory @ %p, iface @ %p.\n", buffer->resource.size, buffer->resource.usage,
             debug_d3dformat(buffer->resource.format->id), buffer->resource.heap_memory, buffer);
@@ -1169,11 +1218,11 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
 
     dynamic_buffer_ok = gl_info->supported[APPLE_FLUSH_BUFFER_RANGE] || gl_info->supported[ARB_MAP_BUFFER_RANGE];
 
-    /* Observations show that drawStridedSlow is faster on dynamic VBs than converting +
+    /* Observations show that draw_strided_slow is faster on dynamic VBs than converting +
      * drawStridedFast (half-life 2 and others).
      *
      * Basically converting the vertices in the buffer is quite expensive, and observations
-     * show that drawStridedSlow is faster than converting + uploading + drawStridedFast.
+     * show that draw_strided_slow is faster than converting + uploading + drawStridedFast.
      * Therefore do not create a VBO for WINED3DUSAGE_DYNAMIC buffers.
      */
     if (!gl_info->supported[ARB_VERTEX_BUFFER_OBJECT])
@@ -1221,6 +1270,9 @@ static HRESULT buffer_init(struct wined3d_buffer *buffer, struct wined3d_device
     }
     buffer->maps_size = 1;
 
+    if (wined3d_settings.cs_multithreaded)
+        buffer->flags |= WINED3D_BUFFER_DOUBLEBUFFER;
+
     return WINED3D_OK;
 }
 
@@ -1326,3 +1378,10 @@ HRESULT CDECL wined3d_buffer_create_ib(struct wined3d_device *device, UINT size,
 
     return WINED3D_OK;
 }
+
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem)
+{
+    wined3d_resource_free_sysmem(&buffer->resource);
+    buffer->resource.heap_memory = mem;
+    buffer->flags |= WINED3D_BUFFER_DISCARD;
+}
diff --git a/dlls/wined3d/context.c b/dlls/wined3d/context.c
index 376f68c..2a43061 100644
--- a/dlls/wined3d/context.c
+++ b/dlls/wined3d/context.c
@@ -1448,6 +1448,14 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
         goto out;
     }
 
+    ret->current_fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*ret->current_fb.render_targets) * gl_info->limits.buffers);
+    ret->current_fb.rt_size = gl_info->limits.buffers;
+    if (!ret->current_fb.render_targets)
+        goto out;
+    if (device->context_count)
+        ret->offscreenBuffer = device->contexts[0]->offscreenBuffer;
+
     /* Initialize the texture unit mapping to a 1:1 mapping */
     for (s = 0; s < MAX_COMBINED_SAMPLERS; ++s)
     {
@@ -1764,6 +1772,7 @@ struct wined3d_context *context_create(struct wined3d_swapchain *swapchain,
 
 out:
     device->shader_backend->shader_free_context_data(ret);
+    HeapFree(GetProcessHeap(), 0, ret->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, ret->free_event_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_occlusion_queries);
     HeapFree(GetProcessHeap(), 0, ret->free_timestamp_queries);
@@ -1797,6 +1806,7 @@ void context_destroy(struct wined3d_device *device, struct wined3d_context *cont
     }
 
     device->shader_backend->shader_free_context_data(context);
+    HeapFree(GetProcessHeap(), 0, context->current_fb.render_targets);
     HeapFree(GetProcessHeap(), 0, context->draw_buffers);
     HeapFree(GetProcessHeap(), 0, context->blit_targets);
     device_context_remove(device, context);
@@ -2199,7 +2209,7 @@ static BOOL match_depth_stencil_format(const struct wined3d_format *existing,
     return TRUE;
 }
 
-/* The caller provides a context */
+/* Context activation is done by the caller. */
 static void context_validate_onscreen_formats(struct wined3d_context *context,
         const struct wined3d_rendertarget_view *depth_stencil)
 {
@@ -2215,20 +2225,20 @@ static void context_validate_onscreen_formats(struct wined3d_context *context,
     WARN("Depth stencil format is not supported by WGL, rendering the backbuffer in an FBO\n");
 
     /* The currently active context is the necessary context to access the swapchain's onscreen buffers */
-    surface_load_location(context->current_rt, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_load_location(&context->current_rt->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     swapchain->render_to_fbo = TRUE;
     swapchain_update_draw_bindings(swapchain);
     context_set_render_offscreen(context, TRUE);
 }
 
-static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_device *device, const struct wined3d_surface *rt)
+static DWORD context_generate_rt_mask_no_fbo(const struct wined3d_context *context, const struct wined3d_surface *rt)
 {
     if (!rt || rt->resource.format->id == WINED3DFMT_NULL)
         return 0;
     else if (rt->container->swapchain)
         return context_generate_rt_mask_from_surface(rt);
     else
-        return context_generate_rt_mask(device->offscreenBuffer);
+        return context_generate_rt_mask(context->offscreenBuffer);
 }
 
 /* Context activation is done by the caller. */
@@ -2260,7 +2270,7 @@ void context_apply_blit_state(struct wined3d_context *context, const struct wine
     }
     else
     {
-        rt_mask = context_generate_rt_mask_no_fbo(device, rt);
+        rt_mask = context_generate_rt_mask_no_fbo(context, rt);
     }
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
@@ -2306,7 +2316,7 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     DWORD rt_mask = 0, *cur_mask;
     UINT i;
 
-    if (isStateDirty(context, STATE_FRAMEBUFFER) || fb != &device->fb
+    if (isStateDirty(context, STATE_FRAMEBUFFER) || !wined3d_fb_equal(fb, &context->current_fb)
             || rt_count != context->gl_info->limits.buffers)
     {
         if (!context_validate_rt_config(rt_count, rts, fb->depth_stencil))
@@ -2346,9 +2356,11 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
         }
         else
         {
-            rt_mask = context_generate_rt_mask_no_fbo(device,
+            rt_mask = context_generate_rt_mask_no_fbo(context,
                     rt_count ? wined3d_rendertarget_view_get_surface(rts[0]) : NULL);
         }
+
+        wined3d_fb_copy(&context->current_fb, fb);
     }
     else if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && (!rt_count || wined3d_resource_is_offscreen(rts[0]->resource)))
@@ -2361,7 +2373,7 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     }
     else
     {
-        rt_mask = context_generate_rt_mask_no_fbo(device,
+        rt_mask = context_generate_rt_mask_no_fbo(context,
                 rt_count ? wined3d_rendertarget_view_get_surface(rts[0]) : NULL);
     }
 
@@ -2396,16 +2408,15 @@ BOOL context_apply_clear_state(struct wined3d_context *context, const struct win
     return TRUE;
 }
 
-static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_device *device)
+static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const struct wined3d_state *state)
 {
-    const struct wined3d_state *state = &device->state;
-    struct wined3d_rendertarget_view **rts = state->fb->render_targets;
+    struct wined3d_rendertarget_view **rts = state->fb.render_targets;
     struct wined3d_shader *ps = state->shader[WINED3D_SHADER_TYPE_PIXEL];
     DWORD rt_mask, rt_mask_bits;
     unsigned int i;
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO)
-        return context_generate_rt_mask_no_fbo(device, wined3d_rendertarget_view_get_surface(rts[0]));
+        return context_generate_rt_mask_no_fbo(context, wined3d_rendertarget_view_get_surface(rts[0]));
     else if (!context->render_offscreen)
         return context_generate_rt_mask_from_surface(wined3d_rendertarget_view_get_surface(rts[0]));
 
@@ -2428,9 +2439,8 @@ static DWORD find_draw_buffers_mask(const struct wined3d_context *context, const
 /* Context activation is done by the caller. */
 void context_state_fb(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_device *device = context->swapchain->device;
-    const struct wined3d_fb_state *fb = state->fb;
-    DWORD rt_mask = find_draw_buffers_mask(context, device);
+    const struct wined3d_fb_state *fb = &state->fb;
+    DWORD rt_mask = find_draw_buffers_mask(context, state);
     DWORD *cur_mask;
 
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO)
@@ -2459,6 +2469,8 @@ void context_state_fb(struct wined3d_context *context, const struct wined3d_stat
         context_apply_draw_buffers(context, rt_mask);
         *cur_mask = rt_mask;
     }
+
+    wined3d_fb_copy(&context->current_fb, &state->fb);
 }
 
 static void context_map_stage(struct wined3d_context *context, DWORD stage, DWORD unit)
@@ -2696,13 +2708,12 @@ static void context_update_tex_unit_map(struct wined3d_context *context, const s
 /* Context activation is done by the caller. */
 void context_state_drawbuf(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_device *device = context->swapchain->device;
     DWORD rt_mask, *cur_mask;
 
     if (isStateDirty(context, STATE_FRAMEBUFFER)) return;
 
     cur_mask = context->current_fbo ? &context->current_fbo->rt_mask : &context->draw_buffers_mask;
-    rt_mask = find_draw_buffers_mask(context, device);
+    rt_mask = find_draw_buffers_mask(context, state);
     if (rt_mask != *cur_mask)
     {
         context_apply_draw_buffers(context, rt_mask);
@@ -2884,7 +2895,7 @@ static void context_update_stream_info(struct wined3d_context *context, const st
     {
         if (state->vertex_declaration->half_float_conv_needed && !stream_info->all_vbo)
         {
-            TRACE("Using drawStridedSlow with vertex shaders for FLOAT16 conversion.\n");
+            TRACE("Using draw_strided_slow with vertex shaders for FLOAT16 conversion.\n");
             context->use_immediate_mode_draw = TRUE;
         }
         else
@@ -2956,11 +2967,11 @@ static void context_preload_textures(struct wined3d_context *context, const stru
 }
 
 /* Context activation is done by the caller. */
-BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device)
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state)
 {
-    const struct wined3d_state *state = &device->state;
     const struct StateEntry *state_table = context->state_table;
-    const struct wined3d_fb_state *fb = state->fb;
+    const struct wined3d_fb_state *fb = &state->fb;
     unsigned int i, j;
     WORD map;
 
@@ -2987,8 +2998,12 @@ BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_de
         for (i = 0, map = context->stream_info.use_map; map; map >>= 1, ++i)
         {
             if (map & 1)
-                buffer_mark_used(state->streams[context->stream_info.elements[i].stream_idx].buffer);
+                buffer_internal_preload(state->streams[context->stream_info.elements[i].stream_idx].buffer,
+                        context, state);
         }
+        /* PreLoad may kick buffers out of vram. */
+        if (isStateDirty(context, STATE_STREAMSRC))
+            context_update_stream_info(context, state);
     }
     if (state->index_buffer)
     {
@@ -3085,7 +3100,7 @@ static void context_setup_target(struct wined3d_context *context, struct wined3d
             if (texture->texture_srgb.name)
                 wined3d_texture_load(texture, context, TRUE);
             wined3d_texture_load(texture, context, FALSE);
-            surface_invalidate_location(context->current_rt, WINED3D_LOCATION_DRAWABLE);
+            wined3d_resource_invalidate_location(&context->current_rt->resource, WINED3D_LOCATION_DRAWABLE);
         }
     }
 
diff --git a/dlls/wined3d/cs.c b/dlls/wined3d/cs.c
index b8a32e5..9b890ae 100644
--- a/dlls/wined3d/cs.c
+++ b/dlls/wined3d/cs.c
@@ -22,10 +22,11 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d);
 
-#define WINED3D_INITIAL_CS_SIZE 4096
-
 enum wined3d_cs_op
 {
+    WINED3D_CS_OP_NOP,
+    WINED3D_CS_OP_SKIP,
+    WINED3D_CS_OP_FENCE,
     WINED3D_CS_OP_PRESENT,
     WINED3D_CS_OP_CLEAR,
     WINED3D_CS_OP_DRAW,
@@ -51,28 +52,84 @@ enum wined3d_cs_op
     WINED3D_CS_OP_SET_CLIP_PLANE,
     WINED3D_CS_OP_SET_MATERIAL,
     WINED3D_CS_OP_RESET_STATE,
+    WINED3D_CS_OP_SET_VS_CONSTS_F,
+    WINED3D_CS_OP_SET_VS_CONSTS_B,
+    WINED3D_CS_OP_SET_VS_CONSTS_I,
+    WINED3D_CS_OP_SET_PS_CONSTS_F,
+    WINED3D_CS_OP_SET_PS_CONSTS_B,
+    WINED3D_CS_OP_SET_PS_CONSTS_I,
+    WINED3D_CS_OP_GLFINISH,
+    WINED3D_CS_OP_SET_BASE_VERTEX_INDEX,
+    WINED3D_CS_OP_SET_PRIMITIVE_TYPE,
+    WINED3D_CS_OP_SET_LIGHT,
+    WINED3D_CS_OP_SET_LIGHT_ENABLE,
+    WINED3D_CS_OP_BLT,
+    WINED3D_CS_OP_CLEAR_RTV,
+    WINED3D_CS_OP_RESOURCE_CHANGED,
+    WINED3D_CS_OP_RESOURCE_MAP,
+    WINED3D_CS_OP_RESOURCE_UNMAP,
+    WINED3D_CS_OP_BUFFER_SWAP_MEM,
+    WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE,
+    WINED3D_CS_OP_BUFFER_PRELOAD,
+    WINED3D_CS_OP_QUERY_ISSUE,
+    WINED3D_CS_OP_QUERY_DESTROY,
+    WINED3D_CS_OP_UPDATE_SURFACE,
+    WINED3D_CS_OP_TEXTURE_PRELOAD,
+    WINED3D_CS_OP_SURFACE_PRELOAD,
+    WINED3D_CS_OP_UPDATE_TEXTURE,
+    WINED3D_CS_OP_EVICT_RESOURCE,
+    WINED3D_CS_OP_VIEW_DESTROY,
+    WINED3D_CS_OP_VDECL_DESTROY,
+    WINED3D_CS_OP_SHADER_CLEANUP,
+    WINED3D_CS_OP_CREATE_VBO,
+    WINED3D_CS_OP_RESOURCE_CLEANUP,
+    WINED3D_CS_OP_BUFFER_CLEANUP,
+    WINED3D_CS_OP_VOLUME_CLEANUP,
+    WINED3D_CS_OP_SURFACE_CLEANUP,
+    WINED3D_CS_OP_TEXTURE_CLEANUP,
+    WINED3D_CS_OP_CREATE_DUMMY_TEXTURES,
+    WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT,
+    WINED3D_CS_OP_DELETE_GL_CONTEXTS,
+    WINED3D_CS_OP_GETDC,
+    WINED3D_CS_OP_RELEASEDC,
+    WINED3D_CS_OP_STOP,
+};
+
+struct wined3d_cs_stop
+{
+    enum wined3d_cs_op opcode;
+};
+
+struct wined3d_cs_fence
+{
+    enum wined3d_cs_op opcode;
+    BOOL *signalled;
 };
 
+#define CS_PRESENT_SRC_RECT 1
+#define CS_PRESENT_DST_RECT 2
+#define CS_PRESENT_DIRTY_RGN 4
 struct wined3d_cs_present
 {
     enum wined3d_cs_op opcode;
     HWND dst_window_override;
     struct wined3d_swapchain *swapchain;
-    const RECT *src_rect;
-    const RECT *dst_rect;
-    const RGNDATA *dirty_region;
+    RECT src_rect;
+    RECT dst_rect;
+    RGNDATA dirty_region;
     DWORD flags;
+    DWORD set_data;
 };
 
 struct wined3d_cs_clear
 {
     enum wined3d_cs_op opcode;
     DWORD rect_count;
-    const RECT *rects;
     DWORD flags;
-    const struct wined3d_color *color;
+    struct wined3d_color color;
     float depth;
     DWORD stencil;
+    RECT rects[1];
 };
 
 struct wined3d_cs_draw
@@ -95,13 +152,13 @@ struct wined3d_cs_set_predication
 struct wined3d_cs_set_viewport
 {
     enum wined3d_cs_op opcode;
-    const struct wined3d_viewport *viewport;
+    struct wined3d_viewport viewport;
 };
 
 struct wined3d_cs_set_scissor_rect
 {
     enum wined3d_cs_op opcode;
-    const RECT *rect;
+    RECT rect;
 };
 
 struct wined3d_cs_set_rendertarget_view
@@ -220,20 +277,20 @@ struct wined3d_cs_set_transform
 {
     enum wined3d_cs_op opcode;
     enum wined3d_transform_state state;
-    const struct wined3d_matrix *matrix;
+    struct wined3d_matrix matrix;
 };
 
 struct wined3d_cs_set_clip_plane
 {
     enum wined3d_cs_op opcode;
     UINT plane_idx;
-    const struct wined3d_vec4 *plane;
+    struct wined3d_vec4 plane;
 };
 
 struct wined3d_cs_set_material
 {
     enum wined3d_cs_op opcode;
-    const struct wined3d_material *material;
+    struct wined3d_material material;
 };
 
 struct wined3d_cs_reset_state
@@ -241,244 +298,737 @@ struct wined3d_cs_reset_state
     enum wined3d_cs_op opcode;
 };
 
-static void wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_set_consts_f
 {
-    const struct wined3d_cs_present *op = data;
-    struct wined3d_swapchain *swapchain;
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4f_count;
+    float constants[4];
+};
 
-    swapchain = op->swapchain;
-    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+struct wined3d_cs_set_consts_b
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, bool_count;
+    BOOL constants[1];
+};
 
-    swapchain->swapchain_ops->swapchain_present(swapchain,
-            op->src_rect, op->dst_rect, op->dirty_region, op->flags);
-}
+struct wined3d_cs_set_consts_i
+{
+    enum wined3d_cs_op opcode;
+    UINT start_register, vector4i_count;
+    int constants[4];
+};
 
-void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
-        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
-        const RGNDATA *dirty_region, DWORD flags)
+struct wined3d_cs_finish
 {
-    struct wined3d_cs_present *op;
+    enum wined3d_cs_op opcode;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_PRESENT;
-    op->dst_window_override = dst_window_override;
-    op->swapchain = swapchain;
-    op->src_rect = src_rect;
-    op->dst_rect = dst_rect;
-    op->dirty_region = dirty_region;
-    op->flags = flags;
+struct wined3d_cs_set_base_vertex_index
+{
+    enum wined3d_cs_op opcode;
+    UINT base_vertex_index;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_set_primitive_type
+{
+    enum wined3d_cs_op opcode;
+    GLenum gl_primitive_type;
+};
 
-static void wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_set_light
 {
-    const struct wined3d_cs_clear *op = data;
-    struct wined3d_device *device;
-    RECT draw_rect;
+    enum wined3d_cs_op opcode;
+    struct wined3d_light_info light;
+};
 
-    device = cs->device;
-    wined3d_get_draw_rect(&device->state, &draw_rect);
-    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
-            &device->fb, op->rect_count, op->rects, &draw_rect, op->flags,
-            op->color, op->depth, op->stencil);
-}
+struct wined3d_cs_set_light_enable
+{
+    enum wined3d_cs_op opcode;
+    UINT idx;
+    BOOL enable;
+};
 
-void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
-        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+struct wined3d_cs_blt
 {
-    struct wined3d_cs_clear *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *dst_surface;
+    RECT dst_rect;
+    struct wined3d_surface *src_surface;
+    RECT src_rect;
+    DWORD flags;
+    WINEDDBLTFX fx;
+    enum wined3d_texture_filter_type filter;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_CLEAR;
-    op->rect_count = rect_count;
-    op->rects = rects;
-    op->flags = flags;
-    op->color = color;
-    op->depth = depth;
-    op->stencil = stencil;
+struct wined3d_cs_clear_rtv
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+    RECT rect;
+    struct wined3d_color color;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_resource_map
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    DWORD flags;
+    void **mem;
+};
 
-static void wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_resource_unmap
 {
-    const struct wined3d_cs_draw *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-    draw_primitive(cs->device, op->start_idx, op->index_count,
-            op->start_instance, op->instance_count, op->indexed);
-}
+struct wined3d_cs_resource_changed
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+    struct wined3d_gl_bo *swap_buffer;
+    void *swap_heap_memory;
+};
 
-void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed)
+struct wined3d_cs_buffer_swap_mem
 {
-    struct wined3d_cs_draw *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    BYTE *mem;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_DRAW;
-    op->start_idx = start_idx;
-    op->index_count = index_count;
-    op->start_instance = start_instance;
-    op->instance_count = instance_count;
-    op->indexed = indexed;
+struct wined3d_cs_buffer_invalidate_bo_range
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+    UINT offset, size;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_skip
+{
+    enum wined3d_cs_op opcode;
+    DWORD size;
+};
 
-static void wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_query_issue
 {
-    const struct wined3d_cs_set_predication *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+    DWORD flags;
+};
 
-    cs->state.predicate = op->predicate;
-    cs->state.predicate_value = op->value;
-}
+struct wined3d_cs_query_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_query *query;
+};
 
-void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
+struct wined3d_cs_update_surface
 {
-    struct wined3d_cs_set_predication *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *src, *dst;
+    RECT src_rect;
+    POINT dst_point;
+    BOOL has_src_rect, has_dst_point;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_PREDICATION;
-    op->predicate = predicate;
-    op->value = value;
+struct wined3d_cs_texture_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_surface_preload
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-static void wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_update_texture
 {
-    const struct wined3d_cs_set_viewport *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *src, *dst;
+};
 
-    cs->state.viewport = *op->viewport;
-    device_invalidate_state(cs->device, STATE_VIEWPORT);
-}
+struct wined3d_cs_evict_resource
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+struct wined3d_cs_buffer_preload
 {
-    struct wined3d_cs_set_viewport *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
-    op->viewport = viewport;
+struct wined3d_cs_view_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_rendertarget_view *view;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_vertex_declaration_destroy
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_vertex_declaration *declaration;
+};
 
-static void wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_shader_cleanup
 {
-    const struct wined3d_cs_set_scissor_rect *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_shader *shader;
+};
 
-    cs->state.scissor_rect = *op->rect;
-    device_invalidate_state(cs->device, STATE_SCISSORRECT);
-}
+struct wined3d_cs_create_vbo
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+struct wined3d_cs_resource_cleanup
 {
-    struct wined3d_cs_set_scissor_rect *op;
+    enum wined3d_cs_op opcode;
+    struct wined3d_resource *resource;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
-    op->rect = rect;
+struct wined3d_cs_buffer_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_buffer *buffer;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_volume_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_volume *volume;
+};
 
-static void wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_surface_cleanup
 {
-    const struct wined3d_cs_set_rendertarget_view *op = data;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-    cs->state.fb->render_targets[op->view_idx] = op->view;
-    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
-}
+struct wined3d_cs_texture_cleanup
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_texture *texture;
+};
 
-void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
-        struct wined3d_rendertarget_view *view)
+struct wined3d_cs_create_dummy_textures
 {
-    struct wined3d_cs_set_rendertarget_view *op;
+    enum wined3d_cs_op opcode;
+};
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
-    op->view_idx = view_idx;
-    op->view = view;
+struct wined3d_cs_create_swapchain_context
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+    HRESULT *ret;
+};
 
-    cs->ops->submit(cs);
-}
+struct wined3d_cs_delete_gl_contexts
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_swapchain *swapchain;
+};
 
-static void wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+struct wined3d_cs_getdc
 {
-    const struct wined3d_cs_set_depth_stencil_view *op = data;
-    struct wined3d_device *device = cs->device;
-    struct wined3d_rendertarget_view *prev;
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-    if ((prev = cs->state.fb->depth_stencil))
-    {
-        struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
+struct wined3d_cs_releasedc
+{
+    enum wined3d_cs_op opcode;
+    struct wined3d_surface *surface;
+};
 
-        if (prev_surface && (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
-                || prev_surface->flags & SFLAG_DISCARD))
-        {
-            surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
-            if (prev_surface == device->onscreen_depth_stencil)
-            {
-                wined3d_surface_decref(device->onscreen_depth_stencil);
-                device->onscreen_depth_stencil = NULL;
-            }
-        }
-    }
+static void wined3d_cs_mt_submit(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->queue.head, new_val);
 
-    cs->fb.depth_stencil = op->view;
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
+}
 
-    if (!prev != !op->view)
-    {
-        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
-    }
-    else if (prev && prev->format->depth_size != op->view->format->depth_size)
-    {
-        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
-    }
+static void wined3d_cs_mt_submit_prio(struct wined3d_cs *cs, size_t size)
+{
+    LONG new_val = (cs->prio_queue.head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+    /* There is only one thread writing to queue.head, InterlockedExchange
+     * is used for the memory barrier. */
+    InterlockedExchange(&cs->prio_queue.head, new_val);
 
-    device_invalidate_state(device, STATE_FRAMEBUFFER);
+    if (InterlockedCompareExchange(&cs->waiting_for_event, FALSE, TRUE))
+        SetEvent(cs->event);
 }
 
-void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
+static UINT wined3d_cs_exec_nop(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_cs_set_depth_stencil_view *op;
+    return sizeof(enum wined3d_cs_op);
+}
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
-    op->view = view;
+static UINT wined3d_cs_exec_skip(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_skip *op = data;
 
-    cs->ops->submit(cs);
+    return op->size;
 }
 
-static void wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_fence(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_vertex_declaration *op = data;
+    const struct wined3d_cs_fence *op = data;
 
-    cs->state.vertex_declaration = op->declaration;
-    device_invalidate_state(cs->device, STATE_VDECL);
+    InterlockedExchange(op->signalled, TRUE);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+static void wined3d_cs_emit_fence(struct wined3d_cs *cs, BOOL *signalled)
 {
-    struct wined3d_cs_set_vertex_declaration *op;
+    struct wined3d_cs_fence *op;
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
-    op->declaration = declaration;
+    *signalled = FALSE;
 
-    cs->ops->submit(cs);
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+static void wined3d_cs_emit_fence_prio(struct wined3d_cs *cs, BOOL *signalled)
 {
-    const struct wined3d_cs_set_stream_source *op = data;
-    struct wined3d_stream_state *stream;
-    struct wined3d_buffer *prev;
+    struct wined3d_cs_fence *op;
+
+    *signalled = FALSE;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_FENCE;
+    op->signalled = signalled;
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_present(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_present *op = data;
+    struct wined3d_swapchain *swapchain;
+    const RECT *src_rect = op->set_data & CS_PRESENT_SRC_RECT ? &op->src_rect : NULL;
+    const RECT *dst_rect = op->set_data & CS_PRESENT_DST_RECT ? &op->dst_rect : NULL;
+    const RGNDATA *dirty_region = op->set_data & CS_PRESENT_DIRTY_RGN ? &op->dirty_region : NULL;
+    unsigned int i;
+
+    swapchain = op->swapchain;
+    wined3d_swapchain_set_window(swapchain, op->dst_window_override);
+
+    swapchain->swapchain_ops->swapchain_present(swapchain,
+            src_rect, dst_rect, dirty_region, op->flags,
+            wined3d_rendertarget_view_get_surface(cs->state.fb.depth_stencil));
+
+    InterlockedDecrement(&cs->pending_presents);
+
+    wined3d_resource_dec_fence(&swapchain->front_buffer->resource);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_resource_dec_fence(&swapchain->back_buffers[i]->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_present(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain,
+        const RECT *src_rect, const RECT *dst_rect, HWND dst_window_override,
+        const RGNDATA *dirty_region, DWORD flags)
+{
+    struct wined3d_cs_present *op;
+    LONG pending;
+    unsigned int i;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_PRESENT;
+    op->dst_window_override = dst_window_override;
+    op->swapchain = swapchain;
+    op->set_data = 0;
+    if (src_rect)
+    {
+        op->src_rect = *src_rect;
+        op->set_data |= CS_PRESENT_SRC_RECT;
+    }
+    if (dst_rect)
+    {
+        op->dst_rect = *dst_rect;
+        op->set_data |= CS_PRESENT_DST_RECT;
+    }
+    if (dirty_region)
+    {
+        op->dirty_region = *dirty_region;
+        op->set_data = CS_PRESENT_DIRTY_RGN;
+    }
+    op->flags = flags;
+
+    wined3d_resource_inc_fence(&swapchain->front_buffer->resource);
+    for (i = 0; i < swapchain->desc.backbuffer_count; i++)
+        wined3d_resource_inc_fence(&swapchain->back_buffers[i]->resource);
+
+    pending = InterlockedIncrement(&cs->pending_presents);
+
+    cs->ops->submit(cs, sizeof(*op));
+
+    /* D3D10 documentation suggests that Windows allows the game to run
+     * 3 frames ahead of the GPU. Increasing this above 1 causes uneven
+     * animation in some games, most notably StarCraft II. The framerates
+     * don't show this problem. The issue is more noticable with vsync
+     * on, but also happens with vsync off.
+     *
+     * In Counter-Strike: Source a frame difference of 3 causes noticable
+     * input delay that makes the game unplayable. */
+    while (pending > 1)
+        pending = InterlockedCompareExchange(&cs->pending_presents, 0, 0);
+}
+
+static UINT wined3d_cs_exec_clear(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear *op = data;
+    struct wined3d_device *device;
+    RECT draw_rect;
+    unsigned int extra_rects = op->rect_count ? op->rect_count - 1 : 0, i;
+
+    device = cs->device;
+    wined3d_get_draw_rect(&cs->state, &draw_rect);
+    device_clear_render_targets(device, device->adapter->gl_info.limits.buffers,
+            &cs->state.fb, op->rect_count, op->rect_count ? op->rects : NULL, &draw_rect, op->flags,
+            &op->color, op->depth, op->stencil);
+
+    if (op->flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+        {
+            if (cs->state.fb.render_targets[i])
+                wined3d_resource_dec_fence(cs->state.fb.render_targets[i]->resource);
+        }
+    }
+    if (op->flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_resource_dec_fence(cs->state.fb.depth_stencil->resource);
+
+    return sizeof(*op) + sizeof(*op->rects) * extra_rects;
+}
+
+void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
+        DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
+{
+    struct wined3d_cs_clear *op;
+    unsigned int extra_rects = rect_count ? rect_count - 1 : 0, i;
+    size_t size = sizeof(*op) + sizeof(*op->rects) * extra_rects;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, size);
+    op->opcode = WINED3D_CS_OP_CLEAR;
+    op->rect_count = rect_count;
+    if (rect_count)
+        memcpy(op->rects, rects, rect_count * sizeof(*rects));
+    op->flags = flags;
+    op->color = *color;
+    op->depth = depth;
+    op->stencil = stencil;
+
+    if (flags & WINED3DCLEAR_TARGET)
+    {
+        for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+        {
+            if (state->fb.render_targets[i])
+                wined3d_resource_inc_fence(state->fb.render_targets[i]->resource);
+        }
+    }
+    if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
+        wined3d_resource_inc_fence(state->fb.depth_stencil->resource);
+
+    cs->ops->submit(cs, size);
+}
+
+static inline BOOL wined3d_cs_colorwrite_enabled(const struct wined3d_state *state, unsigned int i)
+{
+    switch (i)
+    {
+        case 0:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE];
+        case 1:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE1];
+        case 2:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE2];
+        case 3:
+            return !!state->render_states[WINED3D_RS_COLORWRITEENABLE3];
+        default:
+            ERR("Unexpected color target %u.\n", i);
+            return TRUE;
+    }
+}
+
+static inline BOOL wined3d_cs_depth_stencil_enabled(const struct wined3d_state *state)
+{
+    return state->render_states[WINED3D_RS_ZENABLE]
+            || state->render_states[WINED3D_RS_STENCILENABLE];
+}
+
+static UINT wined3d_cs_exec_draw(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_draw *op = data;
+    const struct wined3d_gl_info *gl_info = &cs->device->adapter->gl_info;
+    unsigned int i;
+
+    if (op->indexed && !gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX])
+    {
+        if (cs->state.load_base_vertex_index != cs->state.base_vertex_index)
+        {
+            cs->state.load_base_vertex_index = cs->state.base_vertex_index;
+            device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+        }
+    }
+    else if (cs->state.load_base_vertex_index)
+    {
+        cs->state.load_base_vertex_index = 0;
+        device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+    }
+
+    draw_primitive(cs->device, &cs->state, op->start_idx, op->index_count,
+            op->start_instance, op->instance_count, op->indexed);
+
+    if (op->indexed)
+        wined3d_resource_dec_fence(&cs->state.index_buffer->resource);
+    for (i = 0; i < sizeof(cs->state.streams) / sizeof(*cs->state.streams); i++)
+    {
+        if (cs->state.streams[i].buffer)
+            wined3d_resource_dec_fence(&cs->state.streams[i].buffer->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.textures) / sizeof(*cs->state.textures); i++)
+    {
+        if (cs->state.textures[i])
+            wined3d_resource_dec_fence(&cs->state.textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(cs->state.fb.render_targets) / sizeof(*cs->state.fb.render_targets); i++)
+    {
+        if (cs->state.fb.render_targets[i] && wined3d_cs_colorwrite_enabled(&cs->state, i))
+            wined3d_resource_dec_fence(cs->state.fb.render_targets[i]->resource);
+    }
+    if (cs->state.fb.depth_stencil && wined3d_cs_depth_stencil_enabled(&cs->state))
+        wined3d_resource_dec_fence(cs->state.fb.depth_stencil->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_draw(struct wined3d_cs *cs, UINT start_idx, UINT index_count,
+        UINT start_instance, UINT instance_count, BOOL indexed)
+{
+    struct wined3d_cs_draw *op;
+    unsigned int i;
+    const struct wined3d_state *state = &cs->device->state;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_DRAW;
+    op->start_idx = start_idx;
+    op->index_count = index_count;
+    op->start_instance = start_instance;
+    op->instance_count = instance_count;
+    op->indexed = indexed;
+
+    if (indexed)
+    {
+        wined3d_resource_inc_fence(&state->index_buffer->resource);
+        state->index_buffer->ignore_discard = FALSE;
+    }
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+    {
+        if (state->streams[i].buffer)
+        {
+            wined3d_resource_inc_fence(&state->streams[i].buffer->resource);
+            state->streams[i].buffer->ignore_discard = FALSE;
+        }
+    }
+    for (i = 0; i < sizeof(state->textures) / sizeof(*state->textures); i++)
+    {
+        if (state->textures[i])
+            wined3d_resource_inc_fence(&state->textures[i]->resource);
+    }
+    for (i = 0; i < sizeof(state->fb.render_targets) / sizeof(*state->fb.render_targets); i++)
+    {
+        if (state->fb.render_targets[i] && wined3d_cs_colorwrite_enabled(state, i))
+            wined3d_resource_inc_fence(state->fb.render_targets[i]->resource);
+    }
+    if (state->fb.depth_stencil && wined3d_cs_depth_stencil_enabled(state))
+        wined3d_resource_inc_fence(state->fb.depth_stencil->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_predication(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_predication *op = data;
+
+    cs->state.predicate = op->predicate;
+    cs->state.predicate_value = op->value;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_predication(struct wined3d_cs *cs, struct wined3d_query *predicate, BOOL value)
+{
+    struct wined3d_cs_set_predication *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PREDICATION;
+    op->predicate = predicate;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_viewport(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_viewport *op = data;
+    struct wined3d_device *device = cs->device;
+
+    cs->state.viewport = op->viewport;
+    device_invalidate_state(device, STATE_VIEWPORT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport)
+{
+    struct wined3d_cs_set_viewport *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VIEWPORT;
+    op->viewport = *viewport;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_scissor_rect(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_scissor_rect *op = data;
+
+    cs->state.scissor_rect = op->rect;
+    device_invalidate_state(cs->device, STATE_SCISSORRECT);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_scissor_rect(struct wined3d_cs *cs, const RECT *rect)
+{
+    struct wined3d_cs_set_scissor_rect *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SCISSOR_RECT;
+    op->rect = *rect;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_rendertarget_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_rendertarget_view *op = data;
+
+    cs->state.fb.render_targets[op->view_idx] = op->view;
+    device_invalidate_state(cs->device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_rendertarget_view(struct wined3d_cs *cs, unsigned int view_idx,
+        struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_set_rendertarget_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDERTARGET_VIEW;
+    op->view_idx = view_idx;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_depth_stencil_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_depth_stencil_view *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_rendertarget_view *prev;
+
+    if ((prev = cs->state.fb.depth_stencil))
+    {
+        struct wined3d_surface *prev_surface = wined3d_rendertarget_view_get_surface(prev);
+
+        if (prev_surface && (device->swapchains[0]->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || prev_surface->flags & SFLAG_DISCARD))
+        {
+            surface_modify_ds_location(prev_surface, WINED3D_LOCATION_DISCARDED, prev->width, prev->height);
+            if (prev_surface == cs->onscreen_depth_stencil)
+            {
+                wined3d_surface_decref(cs->onscreen_depth_stencil);
+                cs->onscreen_depth_stencil = NULL;
+            }
+        }
+    }
+
+    cs->state.fb.depth_stencil = op->view;
+
+    if (!prev != !op->view)
+    {
+        /* Swapping NULL / non NULL depth stencil affects the depth and tests */
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_ZENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILENABLE));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_STENCILWRITEMASK));
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+    else if (prev && prev->format->depth_size != op->view->format->depth_size)
+    {
+        device_invalidate_state(device, STATE_RENDER(WINED3D_RS_DEPTHBIAS));
+    }
+
+    device_invalidate_state(device, STATE_FRAMEBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_depth_stencil_view(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_set_depth_stencil_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_DEPTH_STENCIL_VIEW;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vertex_declaration(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_vertex_declaration *op = data;
+
+    cs->state.vertex_declaration = op->declaration;
+    device_invalidate_state(cs->device, STATE_VDECL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs, struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_set_vertex_declaration *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_VERTEX_DECLARATION;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source *op = data;
+    struct wined3d_stream_state *stream;
+    struct wined3d_buffer *prev;
 
     stream = &cs->state.streams[op->stream_idx];
     prev = stream->buffer;
@@ -486,430 +1036,1619 @@ static void wined3d_cs_exec_set_stream_source(struct wined3d_cs *cs, const void
     stream->offset = op->offset;
     stream->stride = op->stride;
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+{
+    struct wined3d_cs_set_stream_source *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->stride = stride;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_source_freq *op = data;
+    struct wined3d_stream_state *stream;
+
+    stream = &cs->state.streams[op->stream_idx];
+    stream->frequency = op->frequency;
+    stream->flags = op->flags;
+
+    device_invalidate_state(cs->device, STATE_STREAMSRC);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+{
+    struct wined3d_cs_set_stream_source_freq *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
+    op->stream_idx = stream_idx;
+    op->frequency = frequency;
+    op->flags = flags;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_stream_output *op = data;
+    struct wined3d_stream_output *stream;
+    struct wined3d_buffer *prev;
+
+    stream = &cs->state.stream_output[op->stream_idx];
+    prev = stream->buffer;
+    stream->buffer = op->buffer;
+    stream->offset = op->offset;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
+        struct wined3d_buffer *buffer, UINT offset)
+{
+    struct wined3d_cs_set_stream_output *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
+    op->stream_idx = stream_idx;
+    op->buffer = buffer;
+    op->offset = offset;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_index_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.index_buffer;
+    cs->state.index_buffer = op->buffer;
+    cs->state.index_format = op->format_id;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        enum wined3d_format_id format_id)
+{
+    struct wined3d_cs_set_index_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
+    op->buffer = buffer;
+    op->format_id = format_id;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_constant_buffer *op = data;
+    struct wined3d_buffer *prev;
+
+    prev = cs->state.cb[op->type][op->cb_idx];
+    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+
+    if (op->buffer)
+        InterlockedIncrement(&op->buffer->resource.bind_count);
+    if (prev)
+        InterlockedDecrement(&prev->resource.bind_count);
+
+    device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT cb_idx, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_set_constant_buffer *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
+    op->type = type;
+    op->cb_idx = cb_idx;
+    op->buffer = buffer;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
+    const struct wined3d_cs_set_texture *op = data;
+    struct wined3d_texture *prev;
+
+    prev = cs->state.textures[op->stage];
+    cs->state.textures[op->stage] = op->texture;
+
+    if (op->texture)
+    {
+        const struct wined3d_format *new_format = op->texture->resource.format;
+        const struct wined3d_format *old_format = prev ? prev->resource.format : NULL;
+
+        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
+            op->texture->sampler = op->stage;
+
+        if (!prev || op->texture->target != prev->target
+                || !is_same_fixup(new_format->color_fixup, old_format->color_fixup)
+                || (new_format->flags & WINED3DFMT_FLAG_SHADOW) != (old_format->flags & WINED3DFMT_FLAG_SHADOW))
+            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+
+        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            /* The source arguments for color and alpha ops have different
+             * meanings when a NULL texture is bound, so the COLOR_OP and
+             * ALPHA_OP have to be dirtified. */
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+    }
+
+    if (prev)
+    {
+        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
+        {
+            unsigned int i;
+
+            /* Search for other stages the texture is bound to. Shouldn't
+             * happen if applications bind textures to a single stage only. */
+            TRACE("Searching for other stages the texture is bound to.\n");
+            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
+            {
+                if (cs->state.textures[i] == prev)
+                {
+                    TRACE("Texture is also bound to stage %u.\n", i);
+                    prev->sampler = i;
+                    break;
+                }
+            }
+        }
+
+        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
+        {
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
+            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
+        }
+    }
+
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+{
+    struct wined3d_cs_set_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
+    op->stage = stage;
+    op->texture = texture;
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader_resource_view *op = data;
+
+    cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT view_idx, struct wined3d_shader_resource_view *view)
+{
+    struct wined3d_cs_set_shader_resource_view *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
+    op->type = type;
+    op->view_idx = view_idx;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler *op = data;
+
+    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
+        UINT sampler_idx, struct wined3d_sampler *sampler)
+{
+    struct wined3d_cs_set_sampler *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
+    op->type = type;
+    op->sampler_idx = sampler_idx;
+    op->sampler = sampler;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_shader *op = data;
+
+    cs->state.shader[op->type] = op->shader;
+    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_set_shader *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SHADER;
+    op->type = type;
+    op->shader = shader;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.vs_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.vs_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_vertex_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_f(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_f *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(cs->state.ps_consts_f + op->start_register * 4, op->constants,
+            sizeof(*cs->state.ps_consts_f) * 4 * op->vector4f_count);
+
+    device->shader_backend->shader_update_float_pixel_constants(device,
+            op->start_register, op->vector4f_count);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4f_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register,
+        const float *constants, UINT vector4f_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_f *op;
+    UINT extra_space = vector4f_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_F;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4f_count = vector4f_count;
+    memcpy(op->constants, constants, sizeof(*constants) * 4 * vector4f_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_render_state *op = data;
+
+    cs->state.render_states[op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+{
+    struct wined3d_cs_set_render_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.vs_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_b(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_b *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_b[op->start_register], op->constants,
+            sizeof(*cs->state.ps_consts_b) * op->bool_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->bool_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_b *op;
+    UINT extra_space = bool_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_B;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            FIXME("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->bool_count = bool_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * bool_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_vs_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.vs_consts_i[op->start_register * 4], op->constants,
+            sizeof(*cs->state.vs_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+static UINT wined3d_cs_exec_set_ps_consts_i(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_consts_i *op = data;
+    struct wined3d_device *device = cs->device;
+
+    memcpy(&cs->state.ps_consts_i[op->start_register * 4], op->constants,
+            sizeof(*cs->state.ps_consts_i) * 4 * op->vector4i_count);
+
+    device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+
+    return sizeof(*op) + sizeof(op->constants) * (op->vector4i_count - 1);
+}
+
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type)
+{
+    struct wined3d_cs_set_consts_i *op;
+    UINT extra_space = vector4i_count - 1;
+    size_t size = sizeof(*op) + sizeof(op->constants) * extra_space;
+
+    op = cs->ops->require_space(cs, size);
+    switch (type)
+    {
+        case WINED3D_SHADER_TYPE_PIXEL:
+            op->opcode = WINED3D_CS_OP_SET_PS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+            op->opcode = WINED3D_CS_OP_SET_VS_CONSTS_I;
+            break;
+
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+            ERR("Invalid for geometry shaders\n");
+            return;
+
+        case WINED3D_SHADER_TYPE_COUNT:
+            break;
+    }
+    op->start_register = start_register;
+    op->vector4i_count = vector4i_count;
+    memcpy(op->constants, constants, sizeof(op->constants) * vector4i_count);
+
+    cs->ops->submit(cs, size);
+}
+
+static UINT wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_texture_state *op = data;
+
+    cs->state.texture_states[op->stage][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
+        enum wined3d_texture_stage_state state, DWORD value)
+{
+    struct wined3d_cs_set_texture_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
+    op->stage = stage;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_sampler_state *op = data;
+
+    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
+    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
+        enum wined3d_sampler_state state, DWORD value)
+{
+    struct wined3d_cs_set_sampler_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
+    op->sampler_idx = sampler_idx;
+    op->state = state;
+    op->value = value;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_transform *op = data;
+
+    cs->state.transforms[op->state] = op->matrix;
+    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
+        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
+        const struct wined3d_matrix *matrix)
+{
+    struct wined3d_cs_set_transform *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
+    op->state = state;
+    op->matrix = *matrix;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_clip_plane *op = data;
+
+    cs->state.clip_planes[op->plane_idx] = op->plane;
+    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+{
+    struct wined3d_cs_set_clip_plane *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
+    op->plane_idx = plane_idx;
+    op->plane = *plane;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_material *op = data;
+
+    cs->state.material = op->material;
+    device_invalidate_state(cs->device, STATE_MATERIAL);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+{
+    struct wined3d_cs_set_material *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
+    op->material = *material;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+{
+    struct wined3d_adapter *adapter = cs->device->adapter;
+    HRESULT hr;
+
+    state_cleanup(&cs->state);
+    memset(&cs->state, 0, sizeof(cs->state));
+    if (FAILED(hr = state_init(&cs->state, &adapter->gl_info, &adapter->d3d_info,
+            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
+        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+
+    return sizeof(struct wined3d_cs_reset_state);
+}
+
+void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_reset_state *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESET_STATE;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_glfinish(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_finish *op = data;
+    struct wined3d_device *device = cs->device;
+    struct wined3d_context *context;
+
+    if (!device->d3d_initialized)
+        return sizeof(*op);
+
+    context = context_acquire(device, NULL);
+    context->gl_info->gl_ops.gl.p_glFinish();
+    context_release(context);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_finish *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_GLFINISH;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_base_vertex_index(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_base_vertex_index *op = data;
+
+    cs->state.base_vertex_index = op->base_vertex_index;
+    device_invalidate_state(cs->device, STATE_BASEVERTEXINDEX);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index)
+{
+    struct wined3d_cs_set_base_vertex_index *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_BASE_VERTEX_INDEX;
+    op->base_vertex_index = base_vertex_index;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_primitive_type(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_primitive_type *op = data;
+    GLenum prev;
+
+    prev = cs->state.gl_primitive_type;
+
+    if (op->gl_primitive_type == GL_POINTS || prev == GL_POINTS)
+        device_invalidate_state(cs->device, STATE_POINT_SIZE_ENABLE);
+
+    cs->state.gl_primitive_type = op->gl_primitive_type;
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs, GLenum primitive_type)
+{
+    struct wined3d_cs_set_primitive_type *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_PRIMITIVE_TYPE;
+    op->gl_primitive_type = primitive_type;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light *op = data;
+
+    UINT light_idx = op->light.OriginalIndex;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->light.OriginalIndex);
+    struct wined3d_light_info *object = NULL;
+    struct list *e;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        object = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (object->OriginalIndex == light_idx)
+            break;
+        object = NULL;
+    }
+
+    if (!object)
+    {
+        TRACE("Adding new light\n");
+        object = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*object));
+        if (!object)
+            return E_OUTOFMEMORY;
+
+        list_add_head(&cs->state.light_map[hash_idx], &object->entry);
+        object->glIndex = -1;
+        object->OriginalIndex = light_idx;
+    }
+
+    object->OriginalParms = op->light.OriginalParms;
+    memcpy(object->lightPosn, op->light.lightPosn, sizeof(object->lightPosn));
+    memcpy(object->lightDirn, op->light.lightDirn, sizeof(object->lightDirn));
+    object->exponent = op->light.exponent;
+    object->cutoff = op->light.cutoff;
+
+    /* Update the live definitions if the light is currently assigned a glIndex. */
+    if (object->glIndex != -1)
+    {
+        if (object->OriginalParms.type != op->light.OriginalParms.type)
+            device_invalidate_state(cs->device, STATE_LIGHT_TYPE);
+        device_invalidate_state(cs->device, STATE_ACTIVELIGHT(object->glIndex));
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light)
+{
+    struct wined3d_cs_set_light *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT;
+    op->light = *light;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_set_light_enable(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_set_light_enable *op = data;
+    UINT hash_idx = LIGHTMAP_HASHFUNC(op->idx);
+    struct wined3d_light_info *light_info = NULL;
+    struct list *e;
+    struct wined3d_device *device = cs->device;
+
+    LIST_FOR_EACH(e, &cs->state.light_map[hash_idx])
+    {
+        light_info = LIST_ENTRY(e, struct wined3d_light_info, entry);
+        if (light_info->OriginalIndex == op->idx)
+            break;
+        light_info = NULL;
+    }
+    TRACE("Found light %p.\n", light_info);
+
+    /* Should be handled by the device by emitting a set_light op */
+    if (!light_info)
+    {
+        ERR("Light enabled requested but light not defined in cs state!\n");
+        return sizeof(*op);
+    }
+
+    if (!op->enable)
+    {
+        if (light_info->glIndex != -1)
+        {
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
+            cs->state.lights[light_info->glIndex] = NULL;
+            light_info->glIndex = -1;
+        }
+        else
+        {
+            TRACE("Light already disabled, nothing to do\n");
+        }
+        light_info->enabled = FALSE;
+    }
+    else
+    {
+        light_info->enabled = TRUE;
+        if (light_info->glIndex != -1)
+        {
+            TRACE("Nothing to do as light was enabled\n");
+        }
+        else
+        {
+            unsigned int i;
+            const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+            /* Find a free GL light. */
+            for (i = 0; i < gl_info->limits.lights; ++i)
+            {
+                if (!cs->state.lights[i])
+                {
+                    cs->state.lights[i] = light_info;
+                    light_info->glIndex = i;
+                    break;
+                }
+            }
+            if (light_info->glIndex == -1)
+            {
+                /* Should be caught by the device before emitting
+                 * the light_enable op */
+                ERR("Too many concurrently active lights in cs\n");
+                return sizeof(*op);
+            }
+
+            /* i == light_info->glIndex */
+            device_invalidate_state(device, STATE_LIGHT_TYPE);
+            device_invalidate_state(device, STATE_ACTIVELIGHT(i));
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable)
+{
+    struct wined3d_cs_set_light_enable *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SET_LIGHT_ENABLE;
+    op->idx = idx;
+    op->enable = enable;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_blt(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_blt *op = data;
+
+    surface_blt_ugly(op->dst_surface, &op->dst_rect,
+            op->src_surface, &op->src_rect,
+            op->flags, &op->fx, op->filter);
+
+    wined3d_resource_dec_fence(&op->dst_surface->container->resource);
+    if (op->src_surface && op->src_surface != op->dst_surface)
+        wined3d_resource_dec_fence(&op->src_surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_cs_blt *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BLT;
+    op->dst_surface = dst_surface;
+    op->dst_rect = *dst_rect;
+    op->src_surface = src_surface;
+    op->src_rect = *src_rect;
+    op->flags = flags;
+    op->filter = filter;
+    if (fx)
+        op->fx = *fx;
+
+    wined3d_resource_inc_fence(&dst_surface->container->resource);
+    if (src_surface && src_surface != dst_surface)
+        wined3d_resource_inc_fence(&src_surface->container->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_clear_rtv(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_clear_rtv *op = data;
+    struct wined3d_resource *resource = op->view->resource;
+
+    resource = wined3d_texture_get_sub_resource(wined3d_texture_from_resource(resource), op->view->sub_resource_idx);
+
+    surface_color_fill(surface_from_resource(resource), &op->rect, &op->color);
+
+    wined3d_resource_dec_fence(op->view->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, const struct wined3d_color *color)
+{
+    struct wined3d_cs_clear_rtv *op;
 
-    device_invalidate_state(cs->device, STATE_STREAMSRC);
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CLEAR_RTV;
+    op->view = view;
+    op->rect = *rect;
+    op->color = *color;
+
+    wined3d_resource_inc_fence(view->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-void wined3d_cs_emit_set_stream_source(struct wined3d_cs *cs, UINT stream_idx,
-        struct wined3d_buffer *buffer, UINT offset, UINT stride)
+static UINT wined3d_cs_exec_resource_changed(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_cs_set_stream_source *op;
+    const struct wined3d_cs_resource_changed *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_changed(resource, op->swap_buffer, op->swap_heap_memory);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory)
+{
+    struct wined3d_cs_resource_changed *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE;
-    op->stream_idx = stream_idx;
-    op->buffer = buffer;
-    op->offset = offset;
-    op->stride = stride;
+    op->opcode = WINED3D_CS_OP_RESOURCE_CHANGED;
+    op->resource = resource;
+    op->swap_buffer = swap_buffer;
+    op->swap_heap_memory = swap_heap_memory;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_source_freq(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_resource_map(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_source_freq *op = data;
-    struct wined3d_stream_state *stream;
+    const struct wined3d_cs_resource_map *op = data;
 
-    stream = &cs->state.streams[op->stream_idx];
-    stream->frequency = op->frequency;
-    stream->flags = op->flags;
+    *op->mem = wined3d_resource_map_internal(op->resource, op->flags);
 
-    device_invalidate_state(cs->device, STATE_STREAMSRC);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_source_freq(struct wined3d_cs *cs, UINT stream_idx, UINT frequency, UINT flags)
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags)
 {
-    struct wined3d_cs_set_stream_source_freq *op;
+    struct wined3d_cs_resource_map *op;
+    void *ret;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_MAP;
+    op->resource = resource;
+    op->flags = flags;
+    op->mem = &ret;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+
+    cs->ops->finish_prio(cs);
+
+    return ret;
+}
+
+static UINT wined3d_cs_exec_resource_unmap(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_resource_unmap *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    wined3d_resource_unmap_internal(resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_resource_unmap *op;
+
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_RESOURCE_UNMAP;
+    op->resource = resource;
+
+    cs->ops->submit_prio(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_query_issue(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_query_issue *op = data;
+    struct wined3d_query *query = op->query;
+    BOOL poll;
+
+    poll = query->query_ops->query_issue(query, op->flags);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        if (poll && list_empty(&query->poll_list_entry))
+        {
+            list_add_tail(&cs->query_poll_list, &query->poll_list_entry);
+        }
+        else if (!poll && !list_empty(&query->poll_list_entry))
+        {
+            /* Can happen if occlusion queries are restarted. This discards the old
+             * result, polling it could result in a GL error */
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+        }
+        else if (op->flags & WINED3DISSUE_END)
+        {
+            /* Can happen when an occlusion query is ended without being started,
+             * in which case we don't want to poll, but still have to counter-balance
+             * the increment of the main counter (!poll && list_empty).
+             *
+             * This can also happen if an event query is re-issued before the first
+             * fence was reached (poll && !list_empty). In this case the query is
+             * already in the list and the poll function will check the new fence.
+             * We have to counter-balance the discarded increment. */
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query, DWORD flags)
+{
+    struct wined3d_cs_query_issue *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_SOURCE_FREQ;
-    op->stream_idx = stream_idx;
-    op->frequency = frequency;
+    op->opcode = WINED3D_CS_OP_QUERY_ISSUE;
+    op->query = query;
     op->flags = flags;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_stream_output(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_query_destroy(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_stream_output *op = data;
-    struct wined3d_stream_output *stream;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_query_destroy *op = data;
 
-    stream = &cs->state.stream_output[op->stream_idx];
-    prev = stream->buffer;
-    stream->buffer = op->buffer;
-    stream->offset = op->offset;
+    if (!list_empty(&op->query->poll_list_entry))
+        list_remove(&op->query->poll_list_entry);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    wined3d_query_destroy(op->query);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_stream_output(struct wined3d_cs *cs, UINT stream_idx,
-        struct wined3d_buffer *buffer, UINT offset)
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query)
 {
-    struct wined3d_cs_set_stream_output *op;
+    struct wined3d_cs_query_destroy *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_STREAM_OUTPUT;
-    op->stream_idx = stream_idx;
-    op->buffer = buffer;
-    op->offset = offset;
+    op->opcode = WINED3D_CS_OP_QUERY_DESTROY;
+    op->query = query;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_index_buffer(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_update_surface(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_index_buffer *op = data;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_update_surface *op = data;
 
-    prev = cs->state.index_buffer;
-    cs->state.index_buffer = op->buffer;
-    cs->state.index_format = op->format_id;
+    surface_upload_from_surface(op->dst, op->has_dst_point ? &op->dst_point : NULL,
+            op->src, op->has_src_rect ? &op->src_rect : NULL);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    if (op->src->container)
+        wined3d_resource_dec_fence(&op->src->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->src->resource);
 
-    device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    if (op->dst->container)
+        wined3d_resource_dec_fence(&op->dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&op->dst->resource);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_index_buffer(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
-        enum wined3d_format_id format_id)
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src, const RECT *src_rect,
+        struct wined3d_surface *dst, const POINT *dst_point)
 {
-    struct wined3d_cs_set_index_buffer *op;
+    struct wined3d_cs_update_surface *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_INDEX_BUFFER;
-    op->buffer = buffer;
-    op->format_id = format_id;
+    op->opcode = WINED3D_CS_OP_UPDATE_SURFACE;
+    op->src = src;
+    op->dst = dst;
+    op->has_src_rect = FALSE;
+    op->has_dst_point = FALSE;
+
+    if (src_rect)
+    {
+        op->has_src_rect = TRUE;
+        op->src_rect = *src_rect;
+    }
+
+    if (dst_point)
+    {
+        op->has_dst_point = TRUE;
+        op->dst_point = *dst_point;
+    }
+
+    if (src->container)
+        wined3d_resource_inc_fence(&src->container->resource);
+    else
+        wined3d_resource_inc_fence(&src->resource);
 
-    cs->ops->submit(cs);
+    if (dst->container)
+        wined3d_resource_inc_fence(&dst->container->resource);
+    else
+        wined3d_resource_inc_fence(&dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_constant_buffer(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_texture_preload(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_constant_buffer *op = data;
-    struct wined3d_buffer *prev;
+    const struct wined3d_cs_texture_preload *op = data;
+    struct wined3d_context *context;
+    struct wined3d_texture *texture = op->texture;
 
-    prev = cs->state.cb[op->type][op->cb_idx];
-    cs->state.cb[op->type][op->cb_idx] = op->buffer;
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
+    context_release(context);
 
-    if (op->buffer)
-        InterlockedIncrement(&op->buffer->resource.bind_count);
-    if (prev)
-        InterlockedDecrement(&prev->resource.bind_count);
+    wined3d_resource_dec_fence(&texture->resource);
 
-    device_invalidate_state(cs->device, STATE_CONSTANT_BUFFER(op->type));
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_constant_buffer(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT cb_idx, struct wined3d_buffer *buffer)
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture)
 {
-    struct wined3d_cs_set_constant_buffer *op;
+    struct wined3d_cs_texture_preload *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_CONSTANT_BUFFER;
-    op->type = type;
-    op->cb_idx = cb_idx;
-    op->buffer = buffer;
+    op->opcode = WINED3D_CS_OP_TEXTURE_PRELOAD;
+    op->texture = texture;
 
-    cs->ops->submit(cs);
+    wined3d_resource_inc_fence(&texture->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_texture(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_surface_preload(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_d3d_info *d3d_info = &cs->device->adapter->d3d_info;
-    const struct wined3d_cs_set_texture *op = data;
-    struct wined3d_texture *prev;
+    const struct wined3d_cs_surface_preload *op = data;
+    struct wined3d_context *context;
 
-    prev = cs->state.textures[op->stage];
-    cs->state.textures[op->stage] = op->texture;
+    context = context_acquire(cs->device, NULL);
+    wined3d_texture_preload(op->surface->container);
+    context_release(context);
 
-    if (op->texture)
+    wined3d_resource_dec_fence(&op->surface->container->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface)
+{
+    struct wined3d_cs_surface_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SURFACE_PRELOAD;
+    op->surface = surface;
+
+    wined3d_resource_inc_fence(&op->surface->container->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_update_texture(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_update_texture *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    device_exec_update_texture(context, op->src, op->dst);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->src->resource);
+    wined3d_resource_dec_fence(&op->dst->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst)
+{
+    struct wined3d_cs_update_texture *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_UPDATE_TEXTURE;
+    op->src = src;
+    op->dst = dst;
+
+    wined3d_resource_inc_fence(&op->src->resource);
+    wined3d_resource_inc_fence(&op->dst->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_evict_resource(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_evict_resource *op = data;
+    struct wined3d_resource *resource = op->resource;
+
+    resource->resource_ops->resource_unload(resource);
+
+    /* FIXME: Is this necessary? Bound buffers are preloaded anyway, and in theory
+     * PreLoad should take care of invalidating the state if the VBO changes */
+    if (resource->bind_count && resource->type == WINED3D_RTYPE_BUFFER)
     {
-        const struct wined3d_format *new_format = op->texture->resource.format;
-        const struct wined3d_format *old_format = prev ? prev->resource.format : NULL;
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
+    }
 
-        if (InterlockedIncrement(&op->texture->resource.bind_count) == 1)
-            op->texture->sampler = op->stage;
+    return sizeof(*op);
+}
 
-        if (!prev || op->texture->target != prev->target
-                || !is_same_fixup(new_format->color_fixup, old_format->color_fixup)
-                || (new_format->flags & WINED3DFMT_FLAG_SHADOW) != (old_format->flags & WINED3DFMT_FLAG_SHADOW))
-            device_invalidate_state(cs->device, STATE_SHADER(WINED3D_SHADER_TYPE_PIXEL));
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource)
+{
+    struct wined3d_cs_evict_resource *op;
 
-        if (!prev && op->stage < d3d_info->limits.ffp_blend_stages)
-        {
-            /* The source arguments for color and alpha ops have different
-             * meanings when a NULL texture is bound, so the COLOR_OP and
-             * ALPHA_OP have to be dirtified. */
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
-        }
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_EVICT_RESOURCE;
+    op->resource = resource;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_swap_mem(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_swap_mem *op = data;
+    struct wined3d_buffer *buffer = op->buffer;
+
+    buffer_swap_mem(buffer, op->mem);
+
+    if (!buffer->buffer_object && buffer->resource.bind_count)
+    {
+        device_invalidate_state(cs->device, STATE_STREAMSRC);
+        device_invalidate_state(cs->device, STATE_INDEXBUFFER);
     }
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer, BYTE *mem)
+{
+    struct wined3d_cs_buffer_swap_mem *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_SWAP_MEM;
+    op->buffer = buffer;
+    op->mem = mem;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_invalidate_bo_range(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_invalidate_bo_range *op = data;
+
+    buffer_invalidate_bo_range(op->buffer, op->offset, op->size);
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size)
+{
+    struct wined3d_cs_buffer_invalidate_bo_range *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE;
+    op->buffer = buffer;
+    op->offset = offset;
+    op->size = size;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_buffer_preload(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_buffer_preload *op = data;
+    struct wined3d_context *context;
+
+    context = context_acquire(cs->device, NULL);
+    buffer_internal_preload(op->buffer, context, NULL);
+    context_release(context);
+
+    wined3d_resource_dec_fence(&op->buffer->resource);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
+{
+    struct wined3d_cs_buffer_preload *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_BUFFER_PRELOAD;
+    op->buffer = buffer;
+
+    wined3d_resource_inc_fence(&buffer->resource);
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_view_destroy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_view_destroy *op = data;
+
+    wined3d_rendertarget_view_destroy(op->view);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_view_destroy(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view)
+{
+    struct wined3d_cs_view_destroy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_VIEW_DESTROY;
+    op->view = view;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_vertex_declaration_destroy(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_vertex_declaration_destroy *op = data;
+
+    wined3d_vertex_declaration_destroy(op->declaration);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration)
+{
+    struct wined3d_cs_vertex_declaration_destroy *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_VDECL_DESTROY;
+    op->declaration = declaration;
+
+    cs->ops->submit(cs, sizeof(*op));
+}
+
+static UINT wined3d_cs_exec_shader_cleanup(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_shader_cleanup *op = data;
+
+    shader_cleanup(op->shader);
+    HeapFree(GetProcessHeap(), 0, op->shader);
+
+    return sizeof(*op);
+}
+
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader)
+{
+    struct wined3d_cs_shader_cleanup *op;
+
+    op = cs->ops->require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_SHADER_CLEANUP;
+    op->shader = shader;
 
-    if (prev)
-    {
-        if (InterlockedDecrement(&prev->resource.bind_count) && prev->sampler == op->stage)
-        {
-            unsigned int i;
+    cs->ops->submit(cs, sizeof(*op));
+}
 
-            /* Search for other stages the texture is bound to. Shouldn't
-             * happen if applications bind textures to a single stage only. */
-            TRACE("Searching for other stages the texture is bound to.\n");
-            for (i = 0; i < MAX_COMBINED_SAMPLERS; ++i)
-            {
-                if (cs->state.textures[i] == prev)
-                {
-                    TRACE("Texture is also bound to stage %u.\n", i);
-                    prev->sampler = i;
-                    break;
-                }
-            }
-        }
+static UINT wined3d_cs_exec_create_vbo(struct wined3d_cs *cs, const void *data)
+{
+    const struct wined3d_cs_create_vbo *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
 
-        if (!op->texture && op->stage < d3d_info->limits.ffp_blend_stages)
-        {
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_COLOR_OP));
-            device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, WINED3D_TSS_ALPHA_OP));
-        }
-    }
+    buffer_create_buffer_object(op->buffer, context);
 
-    device_invalidate_state(cs->device, STATE_SAMPLER(op->stage));
+    context_release(context);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_texture(struct wined3d_cs *cs, UINT stage, struct wined3d_texture *texture)
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
 {
-    struct wined3d_cs_set_texture *op;
+    struct wined3d_cs_create_vbo *op;
 
-    op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TEXTURE;
-    op->stage = stage;
-    op->texture = texture;
+    op = cs->ops->require_space_prio(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_CREATE_VBO;
+    op->buffer = buffer;
 
-    cs->ops->submit(cs);
+    cs->ops->submit_prio(cs, sizeof(*op));
+    cs->ops->finish_prio(cs);
 }
 
-static void wined3d_cs_exec_set_shader_resource_view(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_resource_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_shader_resource_view *op = data;
+    const struct wined3d_cs_resource_cleanup *op = data;
 
-    cs->state.shader_resource_view[op->type][op->view_idx] = op->view;
+    wined3d_resource_cleanup_cs(op->resource);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_shader_resource_view(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT view_idx, struct wined3d_shader_resource_view *view)
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs, struct wined3d_resource *resource)
 {
-    struct wined3d_cs_set_shader_resource_view *op;
+    struct wined3d_cs_resource_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SHADER_RESOURCE_VIEW;
-    op->type = type;
-    op->view_idx = view_idx;
-    op->view = view;
+    op->opcode = WINED3D_CS_OP_RESOURCE_CLEANUP;
+    op->resource = resource;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_sampler(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_buffer_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_sampler *op = data;
+    const struct wined3d_cs_buffer_cleanup *op = data;
 
-    cs->state.sampler[op->type][op->sampler_idx] = op->sampler;
+    wined3d_buffer_cleanup_cs(op->buffer);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_sampler(struct wined3d_cs *cs, enum wined3d_shader_type type,
-        UINT sampler_idx, struct wined3d_sampler *sampler)
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer)
 {
-    struct wined3d_cs_set_sampler *op;
+    struct wined3d_cs_buffer_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SAMPLER;
-    op->type = type;
-    op->sampler_idx = sampler_idx;
-    op->sampler = sampler;
+    op->opcode = WINED3D_CS_OP_BUFFER_CLEANUP;
+    op->buffer = buffer;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_shader(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_volume_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_shader *op = data;
+    const struct wined3d_cs_volume_cleanup *op = data;
 
-    cs->state.shader[op->type] = op->shader;
-    device_invalidate_state(cs->device, STATE_SHADER(op->type));
+    wined3d_volume_cleanup_cs(op->volume);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_shader(struct wined3d_cs *cs, enum wined3d_shader_type type, struct wined3d_shader *shader)
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume)
 {
-    struct wined3d_cs_set_shader *op;
+    struct wined3d_cs_volume_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SHADER;
-    op->type = type;
-    op->shader = shader;
+    op->opcode = WINED3D_CS_OP_VOLUME_CLEANUP;
+    op->volume = volume;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_render_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_surface_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_render_state *op = data;
+    const struct wined3d_cs_surface_cleanup *op = data;
 
-    cs->state.render_states[op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_RENDER(op->state));
+    wined3d_surface_cleanup_cs(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_render_state(struct wined3d_cs *cs, enum wined3d_render_state state, DWORD value)
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    struct wined3d_cs_set_render_state *op;
+    struct wined3d_cs_surface_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_RENDER_STATE;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_SURFACE_CLEANUP;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_texture_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_texture_cleanup(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_texture_state *op = data;
+    const struct wined3d_cs_texture_cleanup *op = data;
 
-    cs->state.texture_states[op->stage][op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_TEXTURESTAGE(op->stage, op->state));
+    wined3d_texture_cleanup_cs(op->texture);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_texture_state(struct wined3d_cs *cs, UINT stage,
-        enum wined3d_texture_stage_state state, DWORD value)
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture)
 {
-    struct wined3d_cs_set_texture_state *op;
+    struct wined3d_cs_texture_cleanup *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TEXTURE_STATE;
-    op->stage = stage;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_TEXTURE_CLEANUP;
+    op->texture = texture;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
 }
 
-static void wined3d_cs_exec_set_sampler_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_create_dummy_textures(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_sampler_state *op = data;
+    const struct wined3d_cs_create_dummy_textures *op = data;
+    struct wined3d_context *context = context_acquire(cs->device, NULL);
 
-    cs->state.sampler_states[op->sampler_idx][op->state] = op->value;
-    device_invalidate_state(cs->device, STATE_SAMPLER(op->sampler_idx));
+    device_create_dummy_textures(cs->device, context);
+
+    context_release(context);
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_sampler_state(struct wined3d_cs *cs, UINT sampler_idx,
-        enum wined3d_sampler_state state, DWORD value)
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs)
 {
-    struct wined3d_cs_set_sampler_state *op;
+    struct wined3d_cs_create_dummy_textures *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_SAMPLER_STATE;
-    op->sampler_idx = sampler_idx;
-    op->state = state;
-    op->value = value;
+    op->opcode = WINED3D_CS_OP_CREATE_DUMMY_TEXTURES;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_set_transform(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_create_swapchain_context(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_transform *op = data;
+    const struct wined3d_cs_create_swapchain_context *op = data;
 
-    cs->state.transforms[op->state] = *op->matrix;
-    if (op->state < WINED3D_TS_WORLD_MATRIX(cs->device->adapter->gl_info.limits.blends))
-        device_invalidate_state(cs->device, STATE_TRANSFORM(op->state));
+    *op->ret = swapchain_create_context_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform_state state,
-        const struct wined3d_matrix *matrix)
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_cs_set_transform *op;
+    HRESULT ret;
+    struct wined3d_cs_create_swapchain_context *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_TRANSFORM;
-    op->state = state;
-    op->matrix = matrix;
+    op->opcode = WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT;
+    op->swapchain = swapchain;
+    op->ret = &ret;
+
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 
-    cs->ops->submit(cs);
+    return ret;
 }
 
-static void wined3d_cs_exec_set_clip_plane(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_delete_gl_contexts(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_clip_plane *op = data;
+    const struct wined3d_cs_delete_gl_contexts *op = data;
 
-    cs->state.clip_planes[op->plane_idx] = *op->plane;
-    device_invalidate_state(cs->device, STATE_CLIPPLANE(op->plane_idx));
+    device_delete_opengl_contexts_cs(cs->device, op->swapchain);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_clip_plane(struct wined3d_cs *cs, UINT plane_idx, const struct wined3d_vec4 *plane)
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_cs_set_clip_plane *op;
+    struct wined3d_cs_delete_gl_contexts *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_CLIP_PLANE;
-    op->plane_idx = plane_idx;
-    op->plane = plane;
+    op->opcode = WINED3D_CS_OP_DELETE_GL_CONTEXTS;
+    op->swapchain = swapchain;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_set_material(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_getdc(struct wined3d_cs *cs, const void *data)
 {
-    const struct wined3d_cs_set_material *op = data;
+    const struct wined3d_cs_getdc *op = data;
 
-    cs->state.material = *op->material;
-    device_invalidate_state(cs->device, STATE_MATERIAL);
+    wined3d_surface_getdc_cs(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_set_material(struct wined3d_cs *cs, const struct wined3d_material *material)
+void wined3d_cs_emit_getdc(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    struct wined3d_cs_set_material *op;
+    struct wined3d_cs_getdc *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_SET_MATERIAL;
-    op->material = material;
+    op->opcode = WINED3D_CS_OP_GETDC;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void wined3d_cs_exec_reset_state(struct wined3d_cs *cs, const void *data)
+static UINT wined3d_cs_exec_releasedc(struct wined3d_cs *cs, const void *data)
 {
-    struct wined3d_adapter *adapter = cs->device->adapter;
-    HRESULT hr;
+    const struct wined3d_cs_releasedc *op = data;
 
-    state_cleanup(&cs->state);
-    memset(&cs->state, 0, sizeof(cs->state));
-    if (FAILED(hr = state_init(&cs->state, &cs->fb, &adapter->gl_info, &adapter->d3d_info,
-            WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
-        ERR("Failed to initialize CS state, hr %#x.\n", hr);
+    wined3d_surface_releasedc_cs(op->surface);
+
+    return sizeof(*op);
 }
 
-void wined3d_cs_emit_reset_state(struct wined3d_cs *cs)
+void wined3d_cs_emit_releasedc(struct wined3d_cs *cs, struct wined3d_surface *surface)
 {
-    struct wined3d_cs_reset_state *op;
+    struct wined3d_cs_releasedc *op;
 
     op = cs->ops->require_space(cs, sizeof(*op));
-    op->opcode = WINED3D_CS_OP_RESET_STATE;
+    op->opcode = WINED3D_CS_OP_RELEASEDC;
+    op->surface = surface;
 
-    cs->ops->submit(cs);
+    cs->ops->submit(cs, sizeof(*op));
+    cs->ops->finish(cs);
 }
 
-static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
+static UINT (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void *data) =
 {
+    /* WINED3D_CS_OP_NOP                        */ wined3d_cs_exec_nop,
+    /* WINED3D_CS_OP_SKIP                       */ wined3d_cs_exec_skip,
+    /* WINED3D_CS_OP_FENCE                      */ wined3d_cs_exec_fence,
     /* WINED3D_CS_OP_PRESENT                    */ wined3d_cs_exec_present,
     /* WINED3D_CS_OP_CLEAR                      */ wined3d_cs_exec_clear,
     /* WINED3D_CS_OP_DRAW                       */ wined3d_cs_exec_draw,
@@ -935,78 +2674,390 @@ static void (* const wined3d_cs_op_handlers[])(struct wined3d_cs *cs, const void
     /* WINED3D_CS_OP_SET_CLIP_PLANE             */ wined3d_cs_exec_set_clip_plane,
     /* WINED3D_CS_OP_SET_MATERIAL               */ wined3d_cs_exec_set_material,
     /* WINED3D_CS_OP_RESET_STATE                */ wined3d_cs_exec_reset_state,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_F            */ wined3d_cs_exec_set_vs_consts_f,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_B            */ wined3d_cs_exec_set_vs_consts_b,
+    /* WINED3D_CS_OP_SET_VS_CONSTS_I            */ wined3d_cs_exec_set_vs_consts_i,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_F            */ wined3d_cs_exec_set_ps_consts_f,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_B            */ wined3d_cs_exec_set_ps_consts_b,
+    /* WINED3D_CS_OP_SET_PS_CONSTS_I            */ wined3d_cs_exec_set_ps_consts_i,
+    /* WINED3D_CS_OP_GLFINISH                   */ wined3d_cs_exec_glfinish,
+    /* WINED3D_CS_OP_SET_BASE_VERTEX_INDEX      */ wined3d_cs_exec_set_base_vertex_index,
+    /* WINED3D_CS_OP_SET_PRIMITIVE_TYPE         */ wined3d_cs_exec_set_primitive_type,
+    /* WINED3D_CS_OP_SET_LIGHT                  */ wined3d_cs_exec_set_light,
+    /* WINED3D_CS_OP_SET_LIGHT_ENABLE           */ wined3d_cs_exec_set_light_enable,
+    /* WINED3D_CS_OP_BLT                        */ wined3d_cs_exec_blt,
+    /* WINED3D_CS_OP_CLEAR_RTV                  */ wined3d_cs_exec_clear_rtv,
+    /* WINED3D_CS_OP_RESOURCE_CHANGED           */ wined3d_cs_exec_resource_changed,
+    /* WINED3D_CS_OP_RESOURCE_MAP               */ wined3d_cs_exec_resource_map,
+    /* WINED3D_CS_OP_RESOURCE_UNMAP             */ wined3d_cs_exec_resource_unmap,
+    /* WINED3D_CS_OP_BUFFER_SWAP_MEM            */ wined3d_cs_exec_buffer_swap_mem,
+    /* WINED3D_CS_OP_BUFFER_INVALIDATE_RANGE    */ wined3d_cs_exec_buffer_invalidate_bo_range,
+    /* WINED3D_CS_OP_BUFFER_PRELOAD             */ wined3d_cs_exec_buffer_preload,
+    /* WINED3D_CS_OP_QUERY_ISSUE                */ wined3d_cs_exec_query_issue,
+    /* WINED3D_CS_OP_QUERY_DESTROY              */ wined3d_cs_exec_query_destroy,
+    /* WINED3D_CS_OP_UPDATE_SURFACE             */ wined3d_cs_exec_update_surface,
+    /* WINED3D_CS_OP_TEXTURE_PRELOAD            */ wined3d_cs_exec_texture_preload,
+    /* WINED3D_CS_OP_SURFACE_PRELOAD            */ wined3d_cs_exec_surface_preload,
+    /* WINED3D_CS_OP_UPDATE_TEXTURE             */ wined3d_cs_exec_update_texture,
+    /* WINED3D_CS_OP_EVICT_RESOURCE             */ wined3d_cs_exec_evict_resource,
+    /* WINED3D_CS_OP_VIEW_DESTROY               */ wined3d_cs_exec_view_destroy,
+    /* WINED3D_CS_OP_VDECL_DESTROY              */ wined3d_cs_exec_vertex_declaration_destroy,
+    /* WINED3D_CS_OP_SHADER_CLEANUP             */ wined3d_cs_exec_shader_cleanup,
+    /* WINED3D_CS_OP_CREATE_VBO                 */ wined3d_cs_exec_create_vbo,
+    /* WINED3D_CS_OP_RESOURCE_CLEANUP           */ wined3d_cs_exec_resource_cleanup,
+    /* WINED3D_CS_OP_BUFFER_CLEANUP             */ wined3d_cs_exec_buffer_cleanup,
+    /* WINED3D_CS_OP_VOLUME_CLEANUP             */ wined3d_cs_exec_volume_cleanup,
+    /* WINED3D_CS_OP_SURFACE_CLEANUP            */ wined3d_cs_exec_surface_cleanup,
+    /* WINED3D_CS_OP_TEXTURE_CLEANUP            */ wined3d_cs_exec_texture_cleanup,
+    /* WINED3D_CS_OP_CREATE_DUMMY_TEXTURES      */ wined3d_cs_exec_create_dummy_textures,
+    /* WINED3D_CS_OP_CREATE_SWAPCHAIN_CONTEXT   */ wined3d_cs_exec_create_swapchain_context,
+    /* WINED3D_CS_OP_DELETE_GL_CONTEXTS         */ wined3d_cs_exec_delete_gl_contexts,
+    /* WINED3D_CS_OP_GETDC                      */ wined3d_cs_exec_getdc,
+    /* WINED3D_CS_OP_RELEASEDC                  */ wined3d_cs_exec_releasedc,
 };
 
-static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+static inline void *_wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size, BOOL prio)
+{
+    struct wined3d_cs_queue *queue = prio ? &cs->prio_queue : &cs->queue;
+    size_t queue_size = sizeof(queue->data) / sizeof(*queue->data);
+
+    if (queue_size - size < queue->head)
+    {
+        struct wined3d_cs_skip *skip;
+        size_t nop_size = queue_size - queue->head;
+
+        skip = _wined3d_cs_mt_require_space(cs, nop_size, prio);
+        if (nop_size < sizeof(*skip))
+        {
+            skip->opcode = WINED3D_CS_OP_NOP;
+        }
+        else
+        {
+            skip->opcode = WINED3D_CS_OP_SKIP;
+            skip->size = nop_size;
+        }
+
+        if (prio)
+            cs->ops->submit_prio(cs, nop_size);
+        else
+            cs->ops->submit(cs, nop_size);
+
+        assert(!queue->head);
+    }
+
+    while(1)
+    {
+        LONG head = queue->head;
+        LONG tail = *((volatile LONG *)&queue->tail);
+        LONG new_pos;
+        /* Empty */
+        if (head == tail)
+            break;
+        /* Head ahead of tail, take care of wrap-around */
+        new_pos = (head + size) & (WINED3D_CS_QUEUE_SIZE - 1);
+        if (head > tail && (new_pos || tail))
+            break;
+        /* Tail ahead of head, but still enough space */
+        if (new_pos < tail && new_pos)
+            break;
+
+        TRACE("Waiting for free space. Head %u, tail %u, want %u\n", head, tail,
+                (unsigned int) size);
+    }
+
+    return &queue->data[queue->head];
+}
+
+static inline void *wined3d_cs_mt_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, FALSE);
+}
+
+static inline void *wined3d_cs_mt_require_space_prio(struct wined3d_cs *cs, size_t size)
+{
+    return _wined3d_cs_mt_require_space(cs, size, TRUE);
+}
+
+/* FIXME: wined3d_device_uninit_3d() should either flush and wait, or be an
+ * OP itself. */
+static void wined3d_cs_emit_stop(struct wined3d_cs *cs)
+{
+    struct wined3d_cs_stop *op;
+
+    op = wined3d_cs_mt_require_space(cs, sizeof(*op));
+    op->opcode = WINED3D_CS_OP_STOP;
+
+    wined3d_cs_mt_submit(cs, sizeof(*op));
+}
+
+static void wined3d_cs_mt_finish(struct wined3d_cs *cs)
+{
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
+    {
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence(cs, &fence);
+
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static void wined3d_cs_mt_finish_prio(struct wined3d_cs *cs)
 {
-    if (size > cs->data_size)
+    BOOL fence;
+
+    if (cs->thread_id == GetCurrentThreadId())
     {
-        void *new_data;
+        static BOOL once;
+        if (!once)
+        {
+            FIXME("flush_and_wait called from cs thread\n");
+            once = TRUE;
+        }
+        return;
+    }
+
+    wined3d_cs_emit_fence_prio(cs, &fence);
 
-        size = max( size, cs->data_size * 2 );
-        if (!(new_data = HeapReAlloc(GetProcessHeap(), 0, cs->data, size)))
-            return NULL;
+    /* A busy wait should be fine, we're not supposed to have to wait very
+     * long. */
+    while (!InterlockedCompareExchange(&fence, TRUE, TRUE));
+}
+
+static const struct wined3d_cs_ops wined3d_cs_mt_ops =
+{
+    wined3d_cs_mt_require_space,
+    wined3d_cs_mt_require_space_prio,
+    wined3d_cs_mt_submit,
+    wined3d_cs_mt_submit_prio,
+    wined3d_cs_mt_finish,
+    wined3d_cs_mt_finish_prio,
+};
 
-        cs->data_size = size;
-        cs->data = new_data;
+static void wined3d_cs_st_submit(struct wined3d_cs *cs, size_t size)
+{
+    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)&cs->queue.data;
+
+    if (opcode >= WINED3D_CS_OP_STOP)
+    {
+        ERR("Invalid opcode %#x.\n", opcode);
+        return;
     }
 
-    return cs->data;
+    wined3d_cs_op_handlers[opcode](cs, &cs->queue.data);
 }
 
-static void wined3d_cs_st_submit(struct wined3d_cs *cs)
+static void wined3d_cs_st_finish(struct wined3d_cs *cs)
 {
-    enum wined3d_cs_op opcode = *(const enum wined3d_cs_op *)cs->data;
+}
 
-    wined3d_cs_op_handlers[opcode](cs, cs->data);
+static void *wined3d_cs_st_require_space(struct wined3d_cs *cs, size_t size)
+{
+    return cs->queue.data;
 }
 
 static const struct wined3d_cs_ops wined3d_cs_st_ops =
 {
     wined3d_cs_st_require_space,
+    wined3d_cs_st_require_space,
+    wined3d_cs_st_submit,
     wined3d_cs_st_submit,
+    wined3d_cs_st_finish,
+    wined3d_cs_st_finish,
 };
 
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs,
+        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
+{
+    if (cs->onscreen_depth_stencil)
+    {
+        surface_load_ds_location(cs->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
+
+        surface_modify_ds_location(cs->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
+                cs->onscreen_depth_stencil->ds_current_size.cx,
+                cs->onscreen_depth_stencil->ds_current_size.cy);
+        wined3d_surface_decref(cs->onscreen_depth_stencil);
+    }
+    cs->onscreen_depth_stencil = depth_stencil;
+    wined3d_surface_incref(cs->onscreen_depth_stencil);
+}
+
+static inline void poll_queries(struct wined3d_cs *cs)
+{
+    struct wined3d_query *query, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(query, cursor, &cs->query_poll_list, struct wined3d_query, poll_list_entry)
+    {
+        BOOL ret;
+
+        ret = query->query_ops->query_poll(query);
+        if (ret)
+        {
+            list_remove(&query->poll_list_entry);
+            list_init(&query->poll_list_entry);
+            InterlockedIncrement(&query->counter_retrieved);
+        }
+    }
+}
+
+static inline BOOL queue_is_empty(const struct wined3d_cs_queue *queue)
+{
+    return *((volatile LONG *)&queue->head) == queue->tail;
+}
+
+static void wined3d_cs_wait_event(struct wined3d_cs *cs)
+{
+    InterlockedExchange(&cs->waiting_for_event, TRUE);
+
+    /* The main thread might enqueue a finish command and block on it
+     * after the worker thread decided to enter wined3d_cs_wait_event
+     * and before waiting_for_event was set to TRUE. Check again if
+     * the queues are empty */
+    if (!queue_is_empty(&cs->prio_queue) || !queue_is_empty(&cs->queue))
+    {
+        /* The main thread might have signalled the event, or be in the process
+         * of doing so. Wait for the event to reset it. ResetEvent is not good
+         * because the main thread might be beween the waiting_for_event reset
+         * and SignalEvent call. */
+        if (!InterlockedCompareExchange(&cs->waiting_for_event, FALSE, FALSE))
+            WaitForSingleObject(cs->event, INFINITE);
+    }
+    else
+    {
+        WaitForSingleObject(cs->event, INFINITE);
+    }
+}
+
+static DWORD WINAPI wined3d_cs_run(void *thread_param)
+{
+    struct wined3d_cs *cs = thread_param;
+    enum wined3d_cs_op opcode;
+    LONG tail;
+    char poll = 0;
+    struct wined3d_cs_queue *queue;
+    unsigned int spin_count = 0;
+
+    TRACE("Started.\n");
+
+    list_init(&cs->query_poll_list);
+    cs->thread_id = GetCurrentThreadId();
+    for (;;)
+    {
+        if (poll == 10)
+        {
+            poll = 0;
+            poll_queries(cs);
+        }
+        else
+            poll++;
+
+        if (!queue_is_empty(&cs->prio_queue))
+        {
+            queue = &cs->prio_queue;
+        }
+        else if (!queue_is_empty(&cs->queue))
+        {
+            queue = &cs->queue;
+            if (!queue_is_empty(&cs->prio_queue))
+                queue = &cs->prio_queue;
+        }
+        else
+        {
+            spin_count++;
+            if (spin_count >= WINED3D_CS_SPIN_COUNT && list_empty(&cs->query_poll_list))
+                wined3d_cs_wait_event(cs);
+
+            continue;
+        }
+
+        spin_count = 0;
+
+        tail = queue->tail;
+        opcode = *(const enum wined3d_cs_op *)&queue->data[tail];
+
+        if (opcode >= WINED3D_CS_OP_STOP)
+        {
+            if (opcode > WINED3D_CS_OP_STOP)
+                ERR("Invalid opcode %#x.\n", opcode);
+            goto done;
+        }
+
+        tail += wined3d_cs_op_handlers[opcode](cs, &queue->data[tail]);
+        tail &= (WINED3D_CS_QUEUE_SIZE - 1);
+        InterlockedExchange(&queue->tail, tail);
+    }
+
+done:
+    TRACE("Stopped.\n");
+    return 0;
+}
+
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    struct wined3d_cs *cs;
+    struct wined3d_cs *cs = NULL;
 
     if (!(cs = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*cs))))
         return NULL;
 
-    if (!(cs->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*cs->fb.render_targets) * gl_info->limits.buffers)))
-    {
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
-    }
-
-    if (FAILED(state_init(&cs->state, &cs->fb, gl_info, &device->adapter->d3d_info,
+    if (FAILED(state_init(&cs->state, gl_info, &device->adapter->d3d_info,
             WINED3D_STATE_NO_REF | WINED3D_STATE_INIT_DEFAULT)))
     {
-        HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
+        goto err;
     }
 
     cs->ops = &wined3d_cs_st_ops;
     cs->device = device;
 
-    cs->data_size = WINED3D_INITIAL_CS_SIZE;
-    if (!(cs->data = HeapAlloc(GetProcessHeap(), 0, cs->data_size)))
+    if (wined3d_settings.cs_multithreaded)
     {
-        HeapFree(GetProcessHeap(), 0, cs);
-        return NULL;
+        cs->ops = &wined3d_cs_mt_ops;
+
+        cs->event = CreateEventW(NULL, FALSE, FALSE, NULL);
+
+        if (!(cs->thread = CreateThread(NULL, 0, wined3d_cs_run, cs, 0, NULL)))
+        {
+            ERR("Failed to create wined3d command stream thread.\n");
+            goto err;
+        }
     }
 
     return cs;
+
+err:
+    if (cs)
+        state_cleanup(&cs->state);
+    HeapFree(GetProcessHeap(), 0, cs);
+    return NULL;
 }
 
 void wined3d_cs_destroy(struct wined3d_cs *cs)
 {
+    DWORD ret;
+
     state_cleanup(&cs->state);
-    HeapFree(GetProcessHeap(), 0, cs->fb.render_targets);
-    HeapFree(GetProcessHeap(), 0, cs->data);
+
+    if (wined3d_settings.cs_multithreaded)
+    {
+        wined3d_cs_emit_stop(cs);
+
+        ret = WaitForSingleObject(cs->thread, INFINITE);
+        CloseHandle(cs->thread);
+        if (ret != WAIT_OBJECT_0)
+            ERR("Wait failed (%#x).\n", ret);
+        if (!CloseHandle(cs->event))
+            ERR("Closing event failed.\n");
+    }
+
     HeapFree(GetProcessHeap(), 0, cs);
 }
diff --git a/dlls/wined3d/device.c b/dlls/wined3d/device.c
index ee3636e..92b4d69 100644
--- a/dlls/wined3d/device.c
+++ b/dlls/wined3d/device.c
@@ -198,22 +198,6 @@ void device_context_remove(struct wined3d_device *device, struct wined3d_context
     device->contexts = new_array;
 }
 
-void device_switch_onscreen_ds(struct wined3d_device *device,
-        struct wined3d_context *context, struct wined3d_surface *depth_stencil)
-{
-    if (device->onscreen_depth_stencil)
-    {
-        surface_load_ds_location(device->onscreen_depth_stencil, context, WINED3D_LOCATION_TEXTURE_RGB);
-
-        surface_modify_ds_location(device->onscreen_depth_stencil, WINED3D_LOCATION_TEXTURE_RGB,
-                device->onscreen_depth_stencil->ds_current_size.cx,
-                device->onscreen_depth_stencil->ds_current_size.cy);
-        wined3d_surface_decref(device->onscreen_depth_stencil);
-    }
-    device->onscreen_depth_stencil = depth_stencil;
-    wined3d_surface_incref(device->onscreen_depth_stencil);
-}
-
 static BOOL is_full_clear(const struct wined3d_surface *target, const RECT *draw_rect, const RECT *clear_rect)
 {
     /* partial draw rect */
@@ -236,7 +220,7 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
 {
     RECT current_rect, r;
 
-    if (ds->locations & WINED3D_LOCATION_DISCARDED)
+    if (ds->resource.locations & WINED3D_LOCATION_DISCARDED)
     {
         /* Depth buffer was discarded, make it entirely current in its new location since
          * there is no other place where we would get data anyway. */
@@ -244,7 +228,7 @@ static void prepare_ds_clear(struct wined3d_surface *ds, struct wined3d_context
         return;
     }
 
-    if (ds->locations & location)
+    if (ds->resource.locations & location)
         SetRect(&current_rect, 0, 0,
                 ds->ds_current_size.cx,
                 ds->ds_current_size.cy);
@@ -300,6 +284,15 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     unsigned int i;
     RECT ds_rect;
 
+    context = context_acquire(device, target);
+    if (!context->valid)
+    {
+        context_release(context);
+        WARN("Invalid context, skipping clear.\n");
+        return;
+    }
+    gl_info = context->gl_info;
+
     /* When we're clearing parts of the drawable, make sure that the target surface is well up to date in the
      * drawable. After the clear we'll mark the drawable up to date, so we have to make sure that this is true
      * for the cleared parts, and the untouched parts.
@@ -314,19 +307,10 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
         {
             struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(fb->render_targets[i]);
             if (rt)
-                surface_load_location(rt, rt->container->resource.draw_binding);
+                wined3d_resource_load_location(&rt->resource, context, rt->container->resource.draw_binding);
         }
     }
 
-    context = context_acquire(device, target);
-    if (!context->valid)
-    {
-        context_release(context);
-        WARN("Invalid context, skipping clear.\n");
-        return;
-    }
-    gl_info = context->gl_info;
-
     if (target)
     {
         render_offscreen = context->render_offscreen;
@@ -343,8 +327,8 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
     {
         DWORD location = render_offscreen ? fb->depth_stencil->resource->draw_binding : WINED3D_LOCATION_DRAWABLE;
 
-        if (!render_offscreen && depth_stencil != device->onscreen_depth_stencil)
-            device_switch_onscreen_ds(device, context, depth_stencil);
+        if (!render_offscreen && depth_stencil != device->cs->onscreen_depth_stencil)
+            wined3d_cs_switch_onscreen_ds(device->cs, context, depth_stencil);
         prepare_ds_clear(depth_stencil, context, location,
                 draw_rect, rect_count, clear_rect, &ds_rect);
     }
@@ -392,8 +376,8 @@ void device_clear_render_targets(struct wined3d_device *device, UINT rt_count, c
 
             if (rt)
             {
-                surface_validate_location(rt, rt->container->resource.draw_binding);
-                surface_invalidate_location(rt, ~rt->container->resource.draw_binding);
+                wined3d_resource_validate_location(&rt->resource, rt->container->resource.draw_binding);
+                wined3d_resource_invalidate_location(&rt->resource, ~rt->container->resource.draw_binding);
             }
         }
 
@@ -624,7 +608,7 @@ out:
 }
 
 /* Context activation is done by the caller. */
-static void create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context)
 {
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     unsigned int i, j, count;
@@ -851,7 +835,7 @@ static void device_init_swapchain_state(struct wined3d_device *device, struct wi
     BOOL ds_enable = !!swapchain->desc.enable_auto_depth_stencil;
     unsigned int i;
 
-    if (device->fb.render_targets)
+    if (device->state.fb.render_targets)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -869,9 +853,7 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
         struct wined3d_swapchain_desc *swapchain_desc)
 {
     static const struct wined3d_color black = {0.0f, 0.0f, 0.0f, 0.0f};
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *swapchain = NULL;
-    struct wined3d_context *context;
     DWORD clear_flags = 0;
     HRESULT hr;
 
@@ -882,9 +864,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     if (device->wined3d->flags & WINED3D_NO3D)
         return WINED3DERR_INVALIDCALL;
 
-    device->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
-            sizeof(*device->fb.render_targets) * gl_info->limits.buffers);
-
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
             device->adapter->vertex_pipe, device->adapter->fragment_pipe)))
     {
@@ -925,10 +904,7 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     device->swapchains[0] = swapchain;
     device_init_swapchain_state(device, swapchain);
 
-    context = context_acquire(device,
-            surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0)));
-
-    create_dummy_textures(device, context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     device->contexts[0]->last_was_rhw = 0;
 
@@ -940,7 +916,7 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
 
         case ORM_BACKBUFFER:
         {
-            if (context_get_current()->aux_buffers > 0)
+            if (device->contexts[0]->aux_buffers > 0)
             {
                 TRACE("Using auxiliary buffer for offscreen rendering\n");
                 device->offscreenBuffer = GL_AUX0;
@@ -952,11 +928,10 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
             }
         }
     }
+    device->contexts[0]->offscreenBuffer = device->offscreenBuffer;
 
     TRACE("All defaults now set up, leaving 3D init.\n");
 
-    context_release(context);
-
     /* Clear the screen */
     if (swapchain->back_buffers && swapchain->back_buffers[0])
         clear_flags |= WINED3DCLEAR_TARGET;
@@ -972,7 +947,6 @@ HRESULT CDECL wined3d_device_init_3d(struct wined3d_device *device,
     return WINED3D_OK;
 
 err_out:
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
     HeapFree(GetProcessHeap(), 0, device->swapchains);
     device->swapchain_count = 0;
     if (device->back_buffer_view)
@@ -1023,8 +997,6 @@ err_out:
 HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
 {
     struct wined3d_resource *resource, *cursor;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_context *context;
     struct wined3d_surface *surface;
     UINT i;
 
@@ -1033,80 +1005,47 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     if (!device->d3d_initialized)
         return WINED3DERR_INVALIDCALL;
 
-    /* I don't think that the interface guarantees that the device is destroyed from the same thread
-     * it was created. Thus make sure a context is active for the glDelete* calls
-     */
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
+    if (wined3d_settings.cs_multithreaded)
+        device->cs->ops->finish(device->cs);
 
     if (device->logo_texture)
         wined3d_texture_decref(device->logo_texture);
-    if (device->cursor_texture)
-        wined3d_texture_decref(device->cursor_texture);
-
-    state_unbind_resources(&device->state);
-
-    /* Unload resources */
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-
-        resource->resource_ops->resource_unload(resource);
-    }
-
-    /* Destroy the depth blt resources, they will be invalid after the reset. Also free shader
-     * private data, it might contain opengl pointers
-     */
-    if (device->depth_blt_texture)
-    {
-        gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
-        device->depth_blt_texture = 0;
-    }
-
-    /* Destroy the shader backend. Note that this has to happen after all shaders are destroyed. */
-    device->blitter->free_private(device);
-    device->shader_backend->shader_free_private(device);
-    destroy_dummy_textures(device, gl_info);
 
-    /* Release the buffers (with sanity checks)*/
-    if (device->onscreen_depth_stencil)
+    /* Release the buffers (with sanity checks).
+     * FIXME: Move this move into a separate patch. I think the idea
+     * behind this is that those surfaces should be freed before unloading
+     * remaining resources below.
+     * FIXME 2: Shouldn't the cs take care of onscreen_depth_stencil? */
+    if (device->cs->onscreen_depth_stencil)
     {
-        surface = device->onscreen_depth_stencil;
-        device->onscreen_depth_stencil = NULL;
+        surface = device->cs->onscreen_depth_stencil;
+        device->cs->onscreen_depth_stencil = NULL;
         wined3d_surface_decref(surface);
     }
 
-    if (device->fb.depth_stencil)
-    {
-        struct wined3d_rendertarget_view *view = device->fb.depth_stencil;
-
-        TRACE("Releasing depth/stencil view %p.\n", view);
-
-        device->fb.depth_stencil = NULL;
-        wined3d_rendertarget_view_decref(view);
-    }
+    state_unbind_resources(&device->state);
 
     if (device->auto_depth_stencil_view)
     {
-        struct wined3d_rendertarget_view *view = device->auto_depth_stencil_view;
-
+        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
         device->auto_depth_stencil_view = NULL;
-        if (wined3d_rendertarget_view_decref(view))
-            ERR("Something's still holding the auto depth/stencil view (%p).\n", view);
     }
 
-    for (i = 0; i < gl_info->limits.buffers; ++i)
+    /* Unload resources */
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
-        wined3d_device_set_rendertarget_view(device, i, NULL, FALSE);
+        TRACE("Unloading resource %p.\n", resource);
+        wined3d_cs_emit_evict_resource(device->cs, resource);
     }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, device->swapchains[0]);
+
     if (device->back_buffer_view)
     {
         wined3d_rendertarget_view_decref(device->back_buffer_view);
         device->back_buffer_view = NULL;
     }
 
-    context_release(context);
-
     for (i = 0; i < device->swapchain_count; ++i)
     {
         TRACE("Releasing the implicit swapchain %u.\n", i);
@@ -1118,9 +1057,6 @@ HRESULT CDECL wined3d_device_uninit_3d(struct wined3d_device *device)
     device->swapchains = NULL;
     device->swapchain_count = 0;
 
-    HeapFree(GetProcessHeap(), 0, device->fb.render_targets);
-    device->fb.render_targets = NULL;
-
     device->d3d_initialized = FALSE;
 
     return WINED3D_OK;
@@ -1484,14 +1420,6 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
     TRACE("... Range(%f), Falloff(%f), Theta(%f), Phi(%f)\n",
             light->range, light->falloff, light->theta, light->phi);
 
-    /* Update the live definitions if the light is currently assigned a glIndex. */
-    if (object->glIndex != -1 && !device->recording)
-    {
-        if (object->OriginalParms.type != light->type)
-            device_invalidate_state(device, STATE_LIGHT_TYPE);
-        device_invalidate_state(device, STATE_ACTIVELIGHT(object->glIndex));
-    }
-
     /* Save away the information. */
     object->OriginalParms = *light;
 
@@ -1564,6 +1492,9 @@ HRESULT CDECL wined3d_device_set_light(struct wined3d_device *device,
             FIXME("Unrecognized light type %#x.\n", light->type);
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light(device->cs, object);
+
     return WINED3D_OK;
 }
 
@@ -1636,12 +1567,6 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
     {
         if (light_info->glIndex != -1)
         {
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(light_info->glIndex));
-            }
-
             device->update_state->lights[light_info->glIndex] = NULL;
             light_info->glIndex = -1;
         }
@@ -1683,16 +1608,12 @@ HRESULT CDECL wined3d_device_set_light_enable(struct wined3d_device *device, UIN
                 WARN("Too many concurrently active lights\n");
                 return WINED3D_OK;
             }
-
-            /* i == light_info->glIndex */
-            if (!device->recording)
-            {
-                device_invalidate_state(device, STATE_LIGHT_TYPE);
-                device_invalidate_state(device, STATE_ACTIVELIGHT(i));
-            }
         }
     }
 
+    if (!device->recording)
+        wined3d_cs_emit_set_light_enable(device->cs, light_idx, enable);
+
     return WINED3D_OK;
 }
 
@@ -1866,6 +1787,9 @@ void CDECL wined3d_device_set_base_vertex_index(struct wined3d_device *device, I
     TRACE("device %p, base_index %d.\n", device, base_index);
 
     device->update_state->base_vertex_index = base_index;
+
+    if (!device->recording)
+        wined3d_cs_emit_set_base_vertex_index(device->cs, base_index);
 }
 
 INT CDECL wined3d_device_get_base_vertex_index(const struct wined3d_device *device)
@@ -1910,7 +1834,7 @@ static void resolve_depth_buffer(struct wined3d_state *state)
             || !(texture->resource.format->flags & WINED3DFMT_FLAG_DEPTH))
         return;
     surface = surface_from_resource(texture->sub_resources[0]);
-    if (!(depth_stencil = wined3d_rendertarget_view_get_surface(state->fb->depth_stencil)))
+    if (!(depth_stencil = wined3d_rendertarget_view_get_surface(state->fb.depth_stencil)))
         return;
 
     wined3d_surface_blt(surface, NULL, depth_stencil, NULL, 0, NULL, WINED3D_TEXF_POINT);
@@ -2230,7 +2154,7 @@ struct wined3d_sampler * CDECL wined3d_device_get_vs_sampler(const struct wined3
     return device->state.sampler[WINED3D_SHADER_TYPE_VERTEX][idx];
 }
 
-static void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask)
 {
     UINT i;
 
@@ -2263,7 +2187,8 @@ HRESULT CDECL wined3d_device_set_vs_consts_b(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_B);
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_VERTEX);
     }
 
     return WINED3D_OK;
@@ -2310,7 +2235,8 @@ HRESULT CDECL wined3d_device_set_vs_consts_i(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_VS_I);
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_VERTEX);
     }
 
     return WINED3D_OK;
@@ -2361,8 +2287,8 @@ HRESULT CDECL wined3d_device_set_vs_consts_f(struct wined3d_device *device,
         memset(device->recording->changed.vertexShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.vertexShaderConstantsF) * vector4f_count);
     else
-        device->shader_backend->shader_update_float_vertex_constants(device, start_register, vector4f_count);
-
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_VERTEX);
 
     return WINED3D_OK;
 }
@@ -2497,7 +2423,8 @@ HRESULT CDECL wined3d_device_set_ps_consts_b(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_B);
+        wined3d_cs_emit_set_consts_b(device->cs, start_register, constants,
+                bool_count, WINED3D_SHADER_TYPE_PIXEL);
     }
 
     return WINED3D_OK;
@@ -2544,7 +2471,8 @@ HRESULT CDECL wined3d_device_set_ps_consts_i(struct wined3d_device *device,
     }
     else
     {
-        device_invalidate_shader_constants(device, WINED3D_SHADER_CONST_PS_I);
+        wined3d_cs_emit_set_consts_i(device->cs, start_register, constants,
+                vector4i_count, WINED3D_SHADER_TYPE_PIXEL);
     }
 
     return WINED3D_OK;
@@ -2596,7 +2524,8 @@ HRESULT CDECL wined3d_device_set_ps_consts_f(struct wined3d_device *device,
         memset(device->recording->changed.pixelShaderConstantsF + start_register, 1,
                 sizeof(*device->recording->changed.pixelShaderConstantsF) * vector4f_count);
     else
-        device->shader_backend->shader_update_float_pixel_constants(device, start_register, vector4f_count);
+        wined3d_cs_emit_set_consts_f(device->cs, start_register, constants, vector4f_count,
+                WINED3D_SHADER_TYPE_PIXEL);
 
     return WINED3D_OK;
 }
@@ -2756,6 +2685,13 @@ static HRESULT process_vertices_strided(const struct wined3d_device *device, DWO
         return hr;
     }
 
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("Waiting for cs.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        device->cs->ops->finish(device->cs);
+    }
+
     wined3d_device_get_transform(device, WINED3D_TS_VIEW, &view_mat);
     wined3d_device_get_transform(device, WINED3D_TS_PROJECTION, &proj_mat);
     wined3d_device_get_transform(device, WINED3D_TS_WORLD_MATRIX(0), &world_mat);
@@ -3257,8 +3193,6 @@ HRESULT CDECL wined3d_device_begin_scene(struct wined3d_device *device)
 
 HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
 {
-    struct wined3d_context *context;
-
     TRACE("device %p.\n", device);
 
     if (!device->inScene)
@@ -3267,13 +3201,6 @@ HRESULT CDECL wined3d_device_end_scene(struct wined3d_device *device)
         return WINED3DERR_INVALIDCALL;
     }
 
-    context = context_acquire(device, NULL);
-    /* We only have to do this if we need to read the, swapbuffers performs a flush for us */
-    context->gl_info->gl_ops.gl.p_glFlush();
-    /* No checkGLcall here to avoid locking the lock just for checking a call that hardly ever
-     * fails. */
-    context_release(context);
-
     device->inScene = FALSE;
     return WINED3D_OK;
 }
@@ -3299,6 +3226,8 @@ HRESULT CDECL wined3d_device_present(const struct wined3d_device *device, const
 HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_count,
         const RECT *rects, DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil)
 {
+    const struct wined3d_fb_state *fb = &device->state.fb;
+
     TRACE("device %p, rect_count %u, rects %p, flags %#x, color {%.8e, %.8e, %.8e, %.8e}, depth %.8e, stencil %u.\n",
             device, rect_count, rects, flags, color->r, color->g, color->b, color->a, depth, stencil);
 
@@ -3307,10 +3236,12 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         WARN("Rects is %p, but rect_count is 0, ignoring clear\n", rects);
         return WINED3D_OK;
     }
+    if (rect_count && !rects)
+        rect_count = 0;
 
     if (flags & (WINED3DCLEAR_ZBUFFER | WINED3DCLEAR_STENCIL))
     {
-        struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+        struct wined3d_rendertarget_view *ds = fb->depth_stencil;
         if (!ds)
         {
             WARN("Clearing depth and/or stencil without a depth stencil buffer attached, returning WINED3DERR_INVALIDCALL\n");
@@ -3319,8 +3250,8 @@ HRESULT CDECL wined3d_device_clear(struct wined3d_device *device, DWORD rect_cou
         }
         else if (flags & WINED3DCLEAR_TARGET)
         {
-            if (ds->width < device->fb.render_targets[0]->width
-                    || ds->height < device->fb.render_targets[0]->height)
+            if (ds->width < fb->render_targets[0]->width
+                    || ds->height < fb->render_targets[0]->height)
             {
                 WARN("Silently ignoring depth and target clear with mismatching sizes\n");
                 return WINED3D_OK;
@@ -3366,7 +3297,6 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
         enum wined3d_primitive_type primitive_type)
 {
     GLenum gl_primitive_type, prev;
-
     TRACE("device %p, primitive_type %s\n", device, debug_d3dprimitivetype(primitive_type));
 
     gl_primitive_type = gl_primitive_type_from_d3d(primitive_type);
@@ -3374,8 +3304,8 @@ void CDECL wined3d_device_set_primitive_type(struct wined3d_device *device,
     device->update_state->gl_primitive_type = gl_primitive_type;
     if (device->recording)
         device->recording->changed.primitive_type = TRUE;
-    else if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-        device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+    else if (gl_primitive_type != prev)
+        wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
 }
 
 void CDECL wined3d_device_get_primitive_type(const struct wined3d_device *device,
@@ -3398,12 +3328,6 @@ HRESULT CDECL wined3d_device_draw_primitive(struct wined3d_device *device, UINT
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (device->state.load_base_vertex_index)
-    {
-        device->state.load_base_vertex_index = 0;
-        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
-    }
-
     wined3d_cs_emit_draw(device->cs, start_vertex, vertex_count, 0, 0, FALSE);
 
     return WINED3D_OK;
@@ -3411,8 +3335,6 @@ HRESULT CDECL wined3d_device_draw_primitive(struct wined3d_device *device, UINT
 
 HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count)
 {
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-
     TRACE("device %p, start_idx %u, index_count %u.\n", device, start_idx, index_count);
 
     if (!device->state.index_buffer)
@@ -3431,13 +3353,6 @@ HRESULT CDECL wined3d_device_draw_indexed_primitive(struct wined3d_device *devic
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (!gl_info->supported[ARB_DRAW_ELEMENTS_BASE_VERTEX] &&
-        device->state.load_base_vertex_index != device->state.base_vertex_index)
-    {
-        device->state.load_base_vertex_index = device->state.base_vertex_index;
-        device_invalidate_state(device, STATE_BASEVERTEXINDEX);
-    }
-
     wined3d_cs_emit_draw(device->cs, start_idx, index_count, 0, 0, TRUE);
 
     return WINED3D_OK;
@@ -3452,16 +3367,14 @@ void CDECL wined3d_device_draw_indexed_primitive_instanced(struct wined3d_device
 }
 
 /* This is a helper function for UpdateTexture, there is no UpdateVolume method in D3D. */
-static HRESULT device_update_volume(struct wined3d_device *device,
+static HRESULT device_update_volume(struct wined3d_context *context,
         struct wined3d_volume *src_volume, struct wined3d_volume *dst_volume)
 {
-    struct wined3d_map_desc src;
     HRESULT hr;
     struct wined3d_bo_address data;
-    struct wined3d_context *context;
 
-    TRACE("device %p, src_volume %p, dst_volume %p.\n",
-            device, src_volume, dst_volume);
+    TRACE("src_volume %p, dst_volume %p.\n",
+            src_volume, dst_volume);
 
     if (src_volume->resource.format != dst_volume->resource.format)
     {
@@ -3476,74 +3389,25 @@ static HRESULT device_update_volume(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    if (FAILED(hr = wined3d_volume_map(src_volume, &src, NULL, WINED3D_MAP_READONLY)))
-        return hr;
-
-    context = context_acquire(device, NULL);
-
     /* Only a prepare, since we're uploading the entire volume. */
     wined3d_texture_prepare_texture(dst_volume->container, context, FALSE);
-
-    data.buffer_object = 0;
-    data.addr = src.data;
+    wined3d_resource_get_memory(&src_volume->resource, src_volume->resource.map_binding, &data);
     wined3d_volume_upload_data(dst_volume, context, &data);
-    wined3d_volume_invalidate_location(dst_volume, ~WINED3D_LOCATION_TEXTURE_RGB);
-
-    context_release(context);
-
-    hr = wined3d_volume_unmap(src_volume);
+    wined3d_resource_invalidate_location(&dst_volume->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 
     return hr;
 }
 
-HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
-        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+/* Context activation is done by the caller */
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture)
 {
-    enum wined3d_resource_type type;
-    unsigned int level_count, i;
-    HRESULT hr;
-    struct wined3d_context *context;
-
-    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
-
-    /* Verify that the source and destination textures are non-NULL. */
-    if (!src_texture || !dst_texture)
-    {
-        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
-    {
-        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
-    {
-        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Verify that the source and destination textures are the same type. */
-    type = src_texture->resource.type;
-    if (dst_texture->resource.type != type)
-    {
-        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    /* Check that both textures have the identical numbers of levels. */
-    level_count = wined3d_texture_get_level_count(src_texture);
-    if (wined3d_texture_get_level_count(dst_texture) != level_count)
-    {
-        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
+    enum wined3d_resource_type type = src_texture->resource.type;
+    unsigned int level_count = wined3d_texture_get_level_count(src_texture);
+    unsigned int i;
 
     /* Make sure that the destination texture is loaded. */
-    context = context_acquire(device, NULL);
     wined3d_texture_load(dst_texture, context, FALSE);
-    context_release(context);
 
     /* Update every surface level of the texture. */
     switch (type)
@@ -3557,12 +3421,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
-                hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update surface, hr %#x.\n", hr);
-                    return hr;
-                }
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
             }
             break;
         }
@@ -3576,12 +3435,7 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
             {
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, i));
                 dst_surface = surface_from_resource(wined3d_texture_get_sub_resource(dst_texture, i));
-                hr = wined3d_device_update_surface(device, src_surface, NULL, dst_surface, NULL);
-                if (FAILED(hr))
-                {
-                    WARN("Failed to update surface, hr %#x.\n", hr);
-                    return hr;
-                }
+                surface_upload_from_surface(dst_surface, NULL, src_surface, NULL);
             }
             break;
         }
@@ -3590,13 +3444,14 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
         {
             for (i = 0; i < level_count; ++i)
             {
-                hr = device_update_volume(device,
+                HRESULT hr;
+                hr = device_update_volume(context,
                         volume_from_resource(wined3d_texture_get_sub_resource(src_texture, i)),
                         volume_from_resource(wined3d_texture_get_sub_resource(dst_texture, i)));
                 if (FAILED(hr))
                 {
                     WARN("Failed to update volume, hr %#x.\n", hr);
-                    return hr;
+                    return;
                 }
             }
             break;
@@ -3604,9 +3459,54 @@ HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
 
         default:
             FIXME("Unsupported texture type %#x.\n", type);
-            return WINED3DERR_INVALIDCALL;
+            return;
+    }
+}
+
+HRESULT CDECL wined3d_device_update_texture(struct wined3d_device *device,
+        struct wined3d_texture *src_texture, struct wined3d_texture *dst_texture)
+{
+    enum wined3d_resource_type type;
+    unsigned int level_count;
+
+    TRACE("device %p, src_texture %p, dst_texture %p.\n", device, src_texture, dst_texture);
+
+    /* Verify that the source and destination textures are non-NULL. */
+    if (!src_texture || !dst_texture)
+    {
+        WARN("Source and destination textures must be non-NULL, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
     }
 
+    if (src_texture->resource.pool != WINED3D_POOL_SYSTEM_MEM)
+    {
+        WARN("Source texture not in WINED3D_POOL_SYSTEM_MEM, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+    if (dst_texture->resource.pool != WINED3D_POOL_DEFAULT)
+    {
+        WARN("Destination texture not in WINED3D_POOL_DEFAULT, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Verify that the source and destination textures are the same type. */
+    type = src_texture->resource.type;
+    if (dst_texture->resource.type != type)
+    {
+        WARN("Source and destination have different types, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    /* Check that both textures have the identical numbers of levels. */
+    level_count = wined3d_texture_get_level_count(src_texture);
+    if (wined3d_texture_get_level_count(dst_texture) != level_count)
+    {
+        WARN("Source and destination have different level counts, returning WINED3DERR_INVALIDCALL.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_texture(device->cs, src_texture, dst_texture);
+
     return WINED3D_OK;
 }
 
@@ -3668,8 +3568,8 @@ HRESULT CDECL wined3d_device_validate_device(const struct wined3d_device *device
     if (state->render_states[WINED3D_RS_ZENABLE] || state->render_states[WINED3D_RS_ZWRITEENABLE]
             || state->render_states[WINED3D_RS_STENCILENABLE])
     {
-        struct wined3d_rendertarget_view *rt = device->fb.render_targets[0];
-        struct wined3d_rendertarget_view *ds = device->fb.depth_stencil;
+        struct wined3d_rendertarget_view *rt = state->fb.render_targets[0];
+        struct wined3d_rendertarget_view *ds = state->fb.depth_stencil;
 
         if (ds && rt && (ds->width < rt->width || ds->height < rt->height))
         {
@@ -3766,6 +3666,13 @@ HRESULT CDECL wined3d_device_update_surface(struct wined3d_device *device,
         struct wined3d_surface *src_surface, const RECT *src_rect,
         struct wined3d_surface *dst_surface, const POINT *dst_point)
 {
+    const struct wined3d_format *src_format = src_surface->resource.format;
+    const struct wined3d_format *dst_format = dst_surface->resource.format;
+    UINT update_w, update_h;
+    UINT dst_w, dst_h;
+    RECT r, dst_rect;
+    POINT p;
+
     TRACE("device %p, src_surface %p, src_rect %s, dst_surface %p, dst_point %s.\n",
             device, src_surface, wine_dbgstr_rect(src_rect),
             dst_surface, wine_dbgstr_point(dst_point));
@@ -3777,7 +3684,68 @@ HRESULT CDECL wined3d_device_update_surface(struct wined3d_device *device,
         return WINED3DERR_INVALIDCALL;
     }
 
-    return surface_upload_from_surface(dst_surface, dst_point, src_surface, src_rect);
+    if (src_format->id != dst_format->id)
+    {
+        WARN("Source and destination surfaces should have the same format.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!dst_point)
+    {
+        p.x = 0;
+        p.y = 0;
+        dst_point = &p;
+    }
+    else if (dst_point->x < 0 || dst_point->y < 0)
+    {
+        WARN("Invalid destination point.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if (!src_rect)
+    {
+        r.left = 0;
+        r.top = 0;
+        r.right = src_surface->resource.width;
+        r.bottom = src_surface->resource.height;
+        src_rect = &r;
+    }
+    else if (src_rect->left < 0 || src_rect->left >= src_rect->right
+            || src_rect->top < 0 || src_rect->top >= src_rect->bottom)
+    {
+        WARN("Invalid source rectangle.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    dst_w = dst_surface->resource.width;
+    dst_h = dst_surface->resource.height;
+
+    update_w = src_rect->right - src_rect->left;
+    update_h = src_rect->bottom - src_rect->top;
+
+    if (update_w > dst_w || dst_point->x > dst_w - update_w
+            || update_h > dst_h || dst_point->y > dst_h - update_h)
+    {
+        WARN("Destination out of bounds.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    if ((src_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(src_surface, src_rect))
+    {
+        WARN("Source rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    SetRect(&dst_rect, dst_point->x, dst_point->y, dst_point->x + update_w, dst_point->y + update_h);
+    if ((dst_format->flags & WINED3DFMT_FLAG_BLOCKS) && !surface_check_block_align(dst_surface, &dst_rect))
+    {
+        WARN("Destination rectangle not block-aligned.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    wined3d_cs_emit_update_surface(device->cs, src_surface, src_rect, dst_surface, dst_point);
+
+    return WINED3D_OK;
 }
 
 void CDECL wined3d_device_copy_resource(struct wined3d_device *device,
@@ -3879,9 +3847,8 @@ HRESULT CDECL wined3d_device_clear_rendertarget_view(struct wined3d_device *devi
         rect = &r;
     }
 
-    resource = wined3d_texture_get_sub_resource(wined3d_texture_from_resource(resource), view->sub_resource_idx);
-
-    return surface_color_fill(surface_from_resource(resource), rect, color);
+    wined3d_cs_emit_clear_rtv(device->cs, view, rect, color);
+    return WINED3D_OK;
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(const struct wined3d_device *device,
@@ -3895,20 +3862,21 @@ struct wined3d_rendertarget_view * CDECL wined3d_device_get_rendertarget_view(co
         return NULL;
     }
 
-    return device->fb.render_targets[view_idx];
+    return device->state.fb.render_targets[view_idx];
 }
 
 struct wined3d_rendertarget_view * CDECL wined3d_device_get_depth_stencil_view(const struct wined3d_device *device)
 {
     TRACE("device %p.\n", device);
 
-    return device->fb.depth_stencil;
+    return device->state.fb.depth_stencil;
 }
 
 HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device,
         unsigned int view_idx, struct wined3d_rendertarget_view *view, BOOL set_viewport)
 {
     struct wined3d_rendertarget_view *prev;
+    struct wined3d_fb_state *fb = &device->state.fb;
 
     TRACE("device %p, view_idx %u, view %p, set_viewport %#x.\n",
             device, view_idx, view, set_viewport);
@@ -3948,13 +3916,13 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
     }
 
 
-    prev = device->fb.render_targets[view_idx];
+    prev = fb->render_targets[view_idx];
     if (view == prev)
         return WINED3D_OK;
 
     if (view)
         wined3d_rendertarget_view_incref(view);
-    device->fb.render_targets[view_idx] = view;
+    fb->render_targets[view_idx] = view;
     wined3d_cs_emit_set_rendertarget_view(device->cs, view_idx, view);
     /* Release after the assignment, to prevent device_resource_released()
      * from seeing the surface as still in use. */
@@ -3966,95 +3934,31 @@ HRESULT CDECL wined3d_device_set_rendertarget_view(struct wined3d_device *device
 
 void CDECL wined3d_device_set_depth_stencil_view(struct wined3d_device *device, struct wined3d_rendertarget_view *view)
 {
+    struct wined3d_fb_state *fb = &device->state.fb;
     struct wined3d_rendertarget_view *prev;
 
     TRACE("device %p, view %p.\n", device, view);
 
-    prev = device->fb.depth_stencil;
+    prev = fb->depth_stencil;
     if (prev == view)
     {
         TRACE("Trying to do a NOP SetRenderTarget operation.\n");
         return;
     }
 
-    if ((device->fb.depth_stencil = view))
+    if ((fb->depth_stencil = view))
         wined3d_rendertarget_view_incref(view);
     wined3d_cs_emit_set_depth_stencil_view(device->cs, view);
     if (prev)
         wined3d_rendertarget_view_decref(prev);
 }
 
-static struct wined3d_texture *wined3d_device_create_cursor_texture(struct wined3d_device *device,
-        struct wined3d_surface *cursor_image)
-{
-    struct wined3d_resource_desc desc;
-    struct wined3d_map_desc map_desc;
-    struct wined3d_texture *texture;
-    struct wined3d_surface *surface;
-    BYTE *src_data, *dst_data;
-    unsigned int src_pitch;
-    unsigned int i;
-
-    if (FAILED(wined3d_surface_map(cursor_image, &map_desc, NULL, WINED3D_MAP_READONLY)))
-    {
-        ERR("Failed to map source surface.\n");
-        return NULL;
-    }
-
-    src_pitch = map_desc.row_pitch;
-    src_data = map_desc.data;
-
-    desc.resource_type = WINED3D_RTYPE_TEXTURE;
-    desc.format = WINED3DFMT_B8G8R8A8_UNORM;
-    desc.multisample_type = WINED3D_MULTISAMPLE_NONE;
-    desc.multisample_quality = 0;
-    desc.usage = WINED3DUSAGE_DYNAMIC;
-    desc.pool = WINED3D_POOL_DEFAULT;
-    desc.width = cursor_image->resource.width;
-    desc.height = cursor_image->resource.height;
-    desc.depth = 1;
-    desc.size = 0;
-
-    if (FAILED(wined3d_texture_create(device, &desc, 1, WINED3D_SURFACE_MAPPABLE,
-            NULL, &wined3d_null_parent_ops, &texture)))
-    {
-        ERR("Failed to create cursor texture.\n");
-        wined3d_surface_unmap(cursor_image);
-        return NULL;
-    }
-
-    surface = surface_from_resource(wined3d_texture_get_sub_resource(texture, 0));
-    if (FAILED(wined3d_surface_map(surface, &map_desc, NULL, WINED3D_MAP_DISCARD)))
-    {
-        ERR("Failed to map destination surface.\n");
-        wined3d_texture_decref(texture);
-        wined3d_surface_unmap(cursor_image);
-        return NULL;
-    }
-
-    dst_data = map_desc.data;
-
-    for (i = 0; i < desc.height; ++i)
-        memcpy(&dst_data[map_desc.row_pitch * i], &src_data[src_pitch * i], desc.width * 4);
-
-    wined3d_surface_unmap(surface);
-    wined3d_surface_unmap(cursor_image);
-
-    return texture;
-}
-
 HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device,
         UINT x_hotspot, UINT y_hotspot, struct wined3d_surface *cursor_image)
 {
     TRACE("device %p, x_hotspot %u, y_hotspot %u, cursor_image %p.\n",
             device, x_hotspot, y_hotspot, cursor_image);
 
-    if (device->cursor_texture)
-    {
-        wined3d_texture_decref(device->cursor_texture);
-        device->cursor_texture = NULL;
-    }
-
     if (cursor_image)
     {
         struct wined3d_display_mode mode;
@@ -4089,11 +3993,8 @@ HRESULT CDECL wined3d_device_set_cursor_properties(struct wined3d_device *device
          * release it after setting the cursor image. Windows doesn't
          * addref the set surface, so we can't do this either without
          * creating circular refcount dependencies. */
-        if (!(device->cursor_texture = wined3d_device_create_cursor_texture(device, cursor_image)))
-        {
-            ERR("Failed to create cursor texture.\n");
-            return WINED3DERR_INVALIDCALL;
-        }
+        device->cursorWidth = cursor_image->resource.width;
+        device->cursorHeight = cursor_image->resource.height;
 
         device->cursorWidth = cursor_image->resource.width;
         device->cursorHeight = cursor_image->resource.height;
@@ -4193,10 +4094,6 @@ BOOL CDECL wined3d_device_show_cursor(struct wined3d_device *device, BOOL show)
         else
             SetCursor(NULL);
     }
-    else if (device->cursor_texture)
-    {
-        device->bCursorVisible = show;
-    }
 
     return oldVisible;
 }
@@ -4207,6 +4104,8 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
 
     TRACE("device %p.\n", device);
 
+    /* The resource list is manged by the main thread, iterate here and emit commands for
+     * each resource */
     LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
     {
         TRACE("Checking resource %p for eviction.\n", resource);
@@ -4214,36 +4113,25 @@ void CDECL wined3d_device_evict_managed_resources(struct wined3d_device *device)
         if (resource->pool == WINED3D_POOL_MANAGED && !resource->map_count)
         {
             TRACE("Evicting %p.\n", resource);
-            resource->resource_ops->resource_unload(resource);
+            wined3d_cs_emit_evict_resource(device->cs, resource);
         }
     }
-
-    /* Invalidate stream sources, the buffer(s) may have been evicted. */
-    device_invalidate_state(device, STATE_STREAMSRC);
 }
 
-static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+void device_delete_opengl_contexts_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_resource *resource, *cursor;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_shader *shader;
 
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
-
-    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
-    {
-        TRACE("Unloading resource %p.\n", resource);
-
-        resource->resource_ops->resource_unload(resource);
-    }
-
     LIST_FOR_EACH_ENTRY(shader, &device->shaders, struct wined3d_shader, shader_list_entry)
     {
         device->shader_backend->shader_destroy(shader);
     }
 
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
     if (device->depth_blt_texture)
     {
         gl_info->gl_ops.gl.p_glDeleteTextures(1, &device->depth_blt_texture);
@@ -4263,12 +4151,25 @@ static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d
 
     HeapFree(GetProcessHeap(), 0, swapchain->context);
     swapchain->context = NULL;
+    swapchain->num_contexts = 0;
+}
+
+static void delete_opengl_contexts(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    struct wined3d_resource *resource, *cursor;
+
+    LIST_FOR_EACH_ENTRY_SAFE(resource, cursor, &device->resources, struct wined3d_resource, resource_list_entry)
+    {
+        TRACE("Unloading resource %p.\n", resource);
+
+        wined3d_cs_emit_evict_resource(device->cs, resource);
+    }
+
+    wined3d_cs_emit_delete_opengl_contexts(device->cs, swapchain);
 }
 
 static HRESULT create_primary_opengl_context(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
 {
-    struct wined3d_context *context;
-    struct wined3d_surface *target;
     HRESULT hr;
 
     if (FAILED(hr = device->shader_backend->shader_alloc_private(device,
@@ -4285,32 +4186,16 @@ static HRESULT create_primary_opengl_context(struct wined3d_device *device, stru
         return hr;
     }
 
-    /* Recreate the primary swapchain's context */
-    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-    if (!swapchain->context)
-    {
-        ERR("Failed to allocate memory for swapchain context array.\n");
-        device->blitter->free_private(device);
-        device->shader_backend->shader_free_private(device);
-        return E_OUTOFMEMORY;
-    }
-
-    target = swapchain->back_buffers
-            ? surface_from_resource(wined3d_texture_get_sub_resource(swapchain->back_buffers[0], 0))
-            : surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0));
-    if (!(context = context_create(swapchain, target, swapchain->ds_format)))
+    hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+    if (FAILED(hr))
     {
         WARN("Failed to create context.\n");
         device->blitter->free_private(device);
         device->shader_backend->shader_free_private(device);
-        HeapFree(GetProcessHeap(), 0, swapchain->context);
-        return E_FAIL;
+        return hr;
     }
 
-    swapchain->context[0] = context;
-    swapchain->num_contexts = 1;
-    create_dummy_textures(device, context);
-    context_release(context);
+    wined3d_cs_emit_create_dummy_textures(device->cs);
 
     return WINED3D_OK;
 }
@@ -4322,7 +4207,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     struct wined3d_resource *resource, *cursor;
     struct wined3d_swapchain *swapchain;
     struct wined3d_display_mode m;
-    BOOL DisplayModeChanged = FALSE;
+    BOOL DisplayModeChanged;
     BOOL update_desc = FALSE;
     UINT backbuffer_width = swapchain_desc->backbuffer_width;
     UINT backbuffer_height = swapchain_desc->backbuffer_height;
@@ -4330,12 +4215,15 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     unsigned int i;
 
     TRACE("device %p, swapchain_desc %p, mode %p, callback %p.\n", device, swapchain_desc, mode, callback);
+    wined3d_cs_emit_glfinish(device->cs);
+    device->cs->ops->finish(device->cs);
 
     if (!(swapchain = wined3d_device_get_swapchain(device, 0)))
     {
         ERR("Failed to get the first implicit swapchain.\n");
         return WINED3DERR_INVALIDCALL;
     }
+    DisplayModeChanged = swapchain->reapply_mode;
 
     if (reset_state)
     {
@@ -4344,15 +4232,9 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
             wined3d_texture_decref(device->logo_texture);
             device->logo_texture = NULL;
         }
-        if (device->cursor_texture)
-        {
-            wined3d_texture_decref(device->cursor_texture);
-            device->cursor_texture = NULL;
-        }
-        state_unbind_resources(&device->state);
     }
 
-    if (device->fb.render_targets)
+    if (device->state.fb.render_targets)
     {
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
@@ -4361,10 +4243,15 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     wined3d_device_set_depth_stencil_view(device, NULL);
 
-    if (device->onscreen_depth_stencil)
+    if (reset_state)
+    {
+        state_unbind_resources(&device->state);
+    }
+
+    if (device->cs->onscreen_depth_stencil)
     {
-        wined3d_surface_decref(device->onscreen_depth_stencil);
-        device->onscreen_depth_stencil = NULL;
+        wined3d_surface_decref(device->cs->onscreen_depth_stencil);
+        device->cs->onscreen_depth_stencil = NULL;
     }
 
     if (reset_state)
@@ -4377,6 +4264,27 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
     }
 
+    /* Free implicit resources and wait for the command stream before modifying
+     * swapchain parameters. After modifying the swapchain parameters a new GL
+     * context may be acquired by the worker thread. This causes problems in the
+     * d3d8/9 test that passes a hidden window as the new device window.
+     * SetPixelFormat will call SetWindowPos inside the X11 driver, which sends
+     * a message to the window to query the icon. Since the worker thread is
+     * not the thread that created the window and the d3d8 test does not run
+     * an event loop this deadlocks. Set up the window first from the main thread
+     * before calling SetPixelFormat from the worker thread to avoid this. */
+    if (device->auto_depth_stencil_view)
+    {
+        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
+        device->auto_depth_stencil_view = NULL;
+    }
+    if (device->back_buffer_view)
+    {
+        wined3d_rendertarget_view_decref(device->back_buffer_view);
+        device->back_buffer_view = NULL;
+    }
+    device->cs->ops->finish(device->cs);
+
     /* Is it necessary to recreate the gl context? Actually every setting can be changed
      * on an existing gl context, so there's no real need for recreation.
      *
@@ -4512,11 +4420,6 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
     }
 
-    if (device->auto_depth_stencil_view)
-    {
-        wined3d_rendertarget_view_decref(device->auto_depth_stencil_view);
-        device->auto_depth_stencil_view = NULL;
-    }
     if (swapchain->desc.enable_auto_depth_stencil)
     {
         struct wined3d_resource_desc surface_desc;
@@ -4554,11 +4457,6 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         wined3d_device_set_depth_stencil_view(device, device->auto_depth_stencil_view);
     }
 
-    if (device->back_buffer_view)
-    {
-        wined3d_rendertarget_view_decref(device->back_buffer_view);
-        device->back_buffer_view = NULL;
-    }
     if (swapchain->desc.backbuffer_count && FAILED(hr = wined3d_rendertarget_view_create_from_surface(
             surface_from_resource(wined3d_texture_get_sub_resource(swapchain->back_buffers[0], 0)),
             NULL, &wined3d_null_parent_ops, &device->back_buffer_view)))
@@ -4602,6 +4500,7 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
                         swapchain_desc->backbuffer_height,
                         TRUE);
             }
+            swapchain->d3d_mode = m;
         }
         else if (!swapchain->desc.windowed)
         {
@@ -4638,11 +4537,12 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
         }
         wined3d_cs_emit_reset_state(device->cs);
         state_cleanup(&device->state);
+        memset(&device->state, 0, sizeof(device->state));
 
         if (device->d3d_initialized)
             delete_opengl_contexts(device, swapchain);
 
-        if (FAILED(hr = state_init(&device->state, &device->fb, &device->adapter->gl_info,
+        if (FAILED(hr = state_init(&device->state, &device->adapter->gl_info,
                 &device->adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
             ERR("Failed to initialize device state, hr %#x.\n", hr);
         device->update_state = &device->state;
@@ -4651,22 +4551,21 @@ HRESULT CDECL wined3d_device_reset(struct wined3d_device *device,
     }
     else if (device->back_buffer_view)
     {
-        struct wined3d_rendertarget_view *view = device->back_buffer_view;
         struct wined3d_state *state = &device->state;
 
-        wined3d_device_set_rendertarget_view(device, 0, view, FALSE);
+        wined3d_device_set_rendertarget_view(device, 0, device->back_buffer_view, FALSE);
 
         /* Note the min_z / max_z is not reset. */
         state->viewport.x = 0;
         state->viewport.y = 0;
-        state->viewport.width = view->width;
-        state->viewport.height = view->height;
+        state->viewport.width = swapchain->desc.backbuffer_width;
+        state->viewport.height = swapchain->desc.backbuffer_height;
         wined3d_cs_emit_set_viewport(device->cs, &state->viewport);
 
         state->scissor_rect.top = 0;
         state->scissor_rect.left = 0;
-        state->scissor_rect.right = view->width;
-        state->scissor_rect.bottom = view->height;
+        state->scissor_rect.right = swapchain->desc.backbuffer_width;
+        state->scissor_rect.bottom = swapchain->desc.backbuffer_height;
         wined3d_cs_emit_set_scissor_rect(device->cs, &state->scissor_rect);
     }
 
@@ -4745,8 +4644,6 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
     TRACE("device %p, resource %p, type %s.\n", device, resource, debug_d3dresourcetype(type));
 
-    context_resource_released(device, resource, type);
-
     switch (type)
     {
         case WINED3D_RTYPE_SURFACE:
@@ -4757,17 +4654,17 @@ void device_resource_released(struct wined3d_device *device, struct wined3d_reso
 
                 for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
                 {
-                    if (wined3d_rendertarget_view_get_surface(device->fb.render_targets[i]) == surface)
+                    if (wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[i]) == surface)
                     {
                         ERR("Surface %p is still in use as render target %u.\n", surface, i);
-                        device->fb.render_targets[i] = NULL;
+                        device->state.fb.render_targets[i] = NULL;
                     }
                 }
 
-                if (wined3d_rendertarget_view_get_surface(device->fb.depth_stencil) == surface)
+                if (wined3d_rendertarget_view_get_surface(device->state.fb.depth_stencil) == surface)
                 {
                     ERR("Surface %p is still in use as depth/stencil buffer.\n", surface);
-                    device->fb.depth_stencil = NULL;
+                    device->state.fb.depth_stencil = NULL;
                 }
             }
             break;
@@ -4908,7 +4805,7 @@ HRESULT device_init(struct wined3d_device *device, struct wined3d *wined3d,
 
     device->blitter = adapter->blitter;
 
-    if (FAILED(hr = state_init(&device->state, &device->fb, &adapter->gl_info,
+    if (FAILED(hr = state_init(&device->state, &adapter->gl_info,
             &adapter->d3d_info, WINED3D_STATE_INIT_DEFAULT)))
     {
         ERR("Failed to initialize device state, hr %#x.\n", hr);
@@ -4983,6 +4880,11 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     }
     else if (message == WM_ACTIVATEAPP)
     {
+        UINT i;
+
+        for (i = 0; i < device->swapchain_count; i++)
+            wined3d_swapchain_activate(device->swapchains[i], wparam);
+
         device->device_parent->ops->activate(device->device_parent, wparam);
     }
 
@@ -4991,3 +4893,56 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
     else
         return CallWindowProcA(proc, window, message, wparam, lparam);
 }
+
+/* Context activation is done by the caller */
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context)
+{
+    struct wined3d_gl_bo *ret;
+    const struct wined3d_gl_info *gl_info;
+
+    TRACE("device %p, size %u, gl_usage %u, type_hint %u\n", device, size, gl_usage,
+            type_hint);
+
+    ret = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY, sizeof(*ret));
+    if(!ret)
+        return NULL;
+    ret->type_hint = type_hint;
+    ret->size = size;
+    ret->usage = gl_usage;
+
+    gl_info = context->gl_info;
+
+    GL_EXTCALL(glGenBuffersARB(1, &ret->name));
+    if (type_hint == GL_ELEMENT_ARRAY_BUFFER_ARB)
+        context_invalidate_state(context, STATE_INDEXBUFFER);
+    GL_EXTCALL(glBindBufferARB(type_hint, ret->name));
+    GL_EXTCALL(glBufferDataARB(type_hint, size, NULL, gl_usage));
+    GL_EXTCALL(glBindBufferARB(type_hint, 0));
+    checkGLcall("Create buffer object");
+
+    TRACE("Successfully created and set up buffer %u\n", ret->name);
+    return ret;
+}
+
+/* Context activation is done by the caller */
+static void wined3d_device_destroy_bo(struct wined3d_device *device, const struct wined3d_context *context,
+        struct wined3d_gl_bo *bo)
+{
+    const struct wined3d_gl_info *gl_info = context->gl_info;
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    GL_EXTCALL(glDeleteBuffersARB(1, &bo->name));
+    checkGLcall("glDeleteBuffersARB");
+
+    HeapFree(GetProcessHeap(), 0, bo);
+}
+
+/* Context activation is done by the caller */
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context)
+{
+    TRACE("device %p, bo %p, GL bo %u\n", device, bo, bo->name);
+
+    wined3d_device_destroy_bo(device, context, bo);
+}
diff --git a/dlls/wined3d/directx.c b/dlls/wined3d/directx.c
index abb25a1..f7b5562 100644
--- a/dlls/wined3d/directx.c
+++ b/dlls/wined3d/directx.c
@@ -1293,6 +1293,7 @@ static const struct gpu_description gpu_description_table[] =
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GTX770,     "NVIDIA GeForce GTX 770",           DRIVER_NVIDIA_GEFORCE8,  2048},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GTX780,     "NVIDIA GeForce GTX 780",           DRIVER_NVIDIA_GEFORCE8,  3072},
     {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GTX780TI,   "NVIDIA GeForce GTX 780 Ti",        DRIVER_NVIDIA_GEFORCE8,  3072},
+    {HW_VENDOR_NVIDIA,     CARD_NVIDIA_GEFORCE_GTX970,     "NVIDIA GeForce GTX 970",           DRIVER_NVIDIA_GEFORCE8,  4096},
 
     /* AMD cards */
     {HW_VENDOR_AMD,        CARD_AMD_RAGE_128PRO,           "ATI Rage Fury",                    DRIVER_AMD_RAGE_128PRO,  16  },
@@ -1720,6 +1721,7 @@ static const struct wined3d_renderer_table
 cards_nvidia_binary[] =
 {
     /* Direct 3D 11 */
+    {"GTX 970",                     CARD_NVIDIA_GEFORCE_GTX970},    /* GeForce 900 - highend */
     {"GTX 780 Ti",                  CARD_NVIDIA_GEFORCE_GTX780TI},  /* Geforce 700 - highend */
     {"GTX 780",                     CARD_NVIDIA_GEFORCE_GTX780},    /* Geforce 700 - highend */
     {"GTX 770M",                    CARD_NVIDIA_GEFORCE_GTX770M},   /* Geforce 700 - midend high mobile */
@@ -2074,6 +2076,7 @@ cards_amd_mesa[] =
 cards_nvidia_mesa[] =
 {
     /* Maxwell */
+    {"NV124",                       CARD_NVIDIA_GEFORCE_GTX970},
     {"NV117",                       CARD_NVIDIA_GEFORCE_GTX750},
     /* Kepler */
     {"NVF1",                        CARD_NVIDIA_GEFORCE_GTX780TI},
@@ -3278,78 +3281,94 @@ HRESULT CDECL wined3d_get_adapter_display_mode(const struct wined3d *wined3d, UI
 HRESULT CDECL wined3d_set_adapter_display_mode(struct wined3d *wined3d,
         UINT adapter_idx, const struct wined3d_display_mode *mode)
 {
-    struct wined3d_display_mode current_mode;
-    const struct wined3d_format *format;
     struct wined3d_adapter *adapter;
-    DEVMODEW devmode;
+    DEVMODEW new_mode, current_mode;
     RECT clip_rc;
-    HRESULT hr;
     LONG ret;
+    enum wined3d_format_id new_format_id;
 
-    TRACE("wined3d %p, adapter_idx %u, mode %p (%ux%u@%u %s %#x).\n", wined3d, adapter_idx, mode,
-            mode->width, mode->height, mode->refresh_rate, debug_d3dformat(mode->format_id),
-            mode->scanline_ordering);
+    TRACE("wined3d %p, adapter_idx %u, mode %p.\n", wined3d, adapter_idx, mode);
 
     if (adapter_idx >= wined3d->adapter_count)
         return WINED3DERR_INVALIDCALL;
-
     adapter = &wined3d->adapters[adapter_idx];
-    format = wined3d_get_format(&adapter->gl_info, mode->format_id);
 
-    memset(&devmode, 0, sizeof(devmode));
-    devmode.dmSize = sizeof(devmode);
-    devmode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
-    devmode.dmBitsPerPel = format->byte_count * CHAR_BIT;
-    devmode.dmPelsWidth = mode->width;
-    devmode.dmPelsHeight = mode->height;
+    memset(&new_mode, 0, sizeof(new_mode));
+    new_mode.dmSize = sizeof(new_mode);
+    memset(&current_mode, 0, sizeof(current_mode));
+    current_mode.dmSize = sizeof(current_mode);
+    if (mode)
+    {
+        const struct wined3d_format *format;
+
+        TRACE("mode %ux%u@%u %s %#x.\n", mode->width, mode->height, mode->refresh_rate,
+                debug_d3dformat(mode->format_id), mode->scanline_ordering);
+
+        format = wined3d_get_format(&adapter->gl_info, mode->format_id);
+
+        new_mode.dmFields = DM_BITSPERPEL | DM_PELSWIDTH | DM_PELSHEIGHT;
+        new_mode.dmBitsPerPel = format->byte_count * CHAR_BIT;
+        new_mode.dmPelsWidth = mode->width;
+        new_mode.dmPelsHeight = mode->height;
 
-    devmode.dmDisplayFrequency = mode->refresh_rate;
-    if (mode->refresh_rate)
-        devmode.dmFields |= DM_DISPLAYFREQUENCY;
+        new_mode.dmDisplayFrequency = mode->refresh_rate;
+        if (mode->refresh_rate)
+            new_mode.dmFields |= DM_DISPLAYFREQUENCY;
 
-    if (mode->scanline_ordering != WINED3D_SCANLINE_ORDERING_UNKNOWN)
+        if (mode->scanline_ordering != WINED3D_SCANLINE_ORDERING_UNKNOWN)
+        {
+            new_mode.dmFields |= DM_DISPLAYFLAGS;
+            if (mode->scanline_ordering == WINED3D_SCANLINE_ORDERING_INTERLACED)
+                new_mode.u2.dmDisplayFlags |= DM_INTERLACED;
+        }
+        new_format_id = mode->format_id;
+    }
+    else
     {
-        devmode.dmFields |= DM_DISPLAYFLAGS;
-        if (mode->scanline_ordering == WINED3D_SCANLINE_ORDERING_INTERLACED)
-            devmode.u2.dmDisplayFlags |= DM_INTERLACED;
+        if (!EnumDisplaySettingsW(adapter->DeviceName, ENUM_REGISTRY_SETTINGS, &new_mode))
+        {
+            ERR("Failed to read mode from registry.\n");
+            return WINED3DERR_NOTAVAILABLE;
+        }
+        new_format_id = pixelformat_for_depth(new_mode.dmBitsPerPel);
     }
 
     /* Only change the mode if necessary. */
-    if (FAILED(hr = wined3d_get_adapter_display_mode(wined3d, adapter_idx, &current_mode, NULL)))
+    if (!EnumDisplaySettingsW(adapter->DeviceName, ENUM_CURRENT_SETTINGS, &current_mode))
     {
-        ERR("Failed to get current display mode, hr %#x.\n", hr);
+        ERR("Failed to get current display mode.\n");
     }
-    else if (current_mode.width == mode->width
-            && current_mode.height == mode->height
-            && current_mode.format_id == mode->format_id
-            && (current_mode.refresh_rate == mode->refresh_rate
-            || !mode->refresh_rate)
-            && (current_mode.scanline_ordering == mode->scanline_ordering
-            || mode->scanline_ordering == WINED3D_SCANLINE_ORDERING_UNKNOWN))
+    else if (current_mode.dmPelsWidth == new_mode.dmPelsWidth
+            && current_mode.dmPelsHeight == new_mode.dmPelsHeight
+            && current_mode.dmBitsPerPel == new_mode.dmBitsPerPel
+            && (current_mode.dmDisplayFrequency == new_mode.dmDisplayFrequency
+            || !(new_mode.dmFields & DM_DISPLAYFREQUENCY))
+            && (current_mode.u2.dmDisplayFlags == new_mode.u2.dmDisplayFlags
+            || !(new_mode.dmFields & DM_DISPLAYFLAGS)))
     {
         TRACE("Skipping redundant mode setting call.\n");
         return WINED3D_OK;
     }
 
-    ret = ChangeDisplaySettingsExW(adapter->DeviceName, &devmode, NULL, CDS_FULLSCREEN, NULL);
+    ret = ChangeDisplaySettingsExW(adapter->DeviceName, &new_mode, NULL, CDS_FULLSCREEN, NULL);
     if (ret != DISP_CHANGE_SUCCESSFUL)
     {
-        if (devmode.dmDisplayFrequency)
+        if (new_mode.dmFields & DM_DISPLAYFREQUENCY)
         {
             WARN("ChangeDisplaySettingsExW failed, trying without the refresh rate.\n");
-            devmode.dmFields &= ~DM_DISPLAYFREQUENCY;
-            devmode.dmDisplayFrequency = 0;
-            ret = ChangeDisplaySettingsExW(adapter->DeviceName, &devmode, NULL, CDS_FULLSCREEN, NULL);
+            new_mode.dmFields &= ~DM_DISPLAYFREQUENCY;
+            new_mode.dmDisplayFrequency = 0;
+            ret = ChangeDisplaySettingsExW(adapter->DeviceName, &new_mode, NULL, CDS_FULLSCREEN, NULL);
         }
         if (ret != DISP_CHANGE_SUCCESSFUL)
             return WINED3DERR_NOTAVAILABLE;
     }
 
     /* Store the new values. */
-    adapter->screen_format = mode->format_id;
+    adapter->screen_format = new_format_id;
 
     /* And finally clip mouse to our screen. */
-    SetRect(&clip_rc, 0, 0, mode->width, mode->height);
+    SetRect(&clip_rc, 0, 0, new_mode.dmPelsWidth, new_mode.dmPelsHeight);
     ClipCursor(&clip_rc);
 
     return WINED3D_OK;
@@ -4713,7 +4732,7 @@ static void WINE_GLAPI invalid_texcoord_func(GLenum unit, const void *data)
 }
 
 /* Helper functions for providing vertex data to opengl. The arrays are initialized based on
- * the extension detection and are used in drawStridedSlow
+ * the extension detection and are used in draw_strided_slow
  */
 static void WINE_GLAPI position_d3dcolor(const void *data)
 {
diff --git a/dlls/wined3d/drawprim.c b/dlls/wined3d/drawprim.c
index 265942c..5eb80f0 100644
--- a/dlls/wined3d/drawprim.c
+++ b/dlls/wined3d/drawprim.c
@@ -36,7 +36,7 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 #include <math.h>
 
 /* Context activation is done by the caller. */
-static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
+static void draw_strided_fast(const struct wined3d_gl_info *gl_info, GLenum primitive_type, UINT count, UINT idx_size,
         const void *idx_data, UINT start_idx, INT base_vertex_index, UINT start_instance, UINT instance_count)
 {
     if (idx_size)
@@ -92,7 +92,7 @@ static void drawStridedFast(const struct wined3d_gl_info *gl_info, GLenum primit
  */
 
 /* Context activation is done by the caller. */
-static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_context *context,
+static void draw_strided_slow(const struct wined3d_state *state, struct wined3d_context *context,
         const struct wined3d_stream_info *si, UINT NumVertexes, GLenum glPrimType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -100,7 +100,6 @@ static void drawStridedSlow(const struct wined3d_device *device, struct wined3d_
     const WORD                *pIdxBufS     = NULL;
     const DWORD               *pIdxBufL     = NULL;
     UINT vx_index;
-    const struct wined3d_state *state = &device->state;
     LONG SkipnStrides = startIdx;
     BOOL pixelShader = use_ps(state);
     BOOL specular_fog = FALSE;
@@ -450,7 +449,7 @@ static inline void send_attribute(const struct wined3d_gl_info *gl_info,
 }
 
 /* Context activation is done by the caller. */
-static void drawStridedSlowVs(struct wined3d_context *context, const struct wined3d_state *state,
+static void draw_strided_slow_vs(struct wined3d_context *context, const struct wined3d_state *state,
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx)
 {
@@ -507,7 +506,7 @@ static void drawStridedSlowVs(struct wined3d_context *context, const struct wine
 }
 
 /* Context activation is done by the caller. */
-static void drawStridedInstanced(struct wined3d_context *context, const struct wined3d_state *state,
+static void draw_strided_instanced(struct wined3d_context *context, const struct wined3d_state *state,
         const struct wined3d_stream_info *si, UINT numberOfVertices, GLenum glPrimitiveType,
         const void *idxData, UINT idxSize, UINT startIdx, UINT base_vertex_index, UINT instance_count)
 {
@@ -592,10 +591,10 @@ static void remove_vbos(struct wined3d_context *context,
 }
 
 /* Routine common to the draw primitive and draw indexed primitive routines */
-void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed)
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed)
 {
-    const struct wined3d_state *state = &device->state;
     const struct wined3d_stream_info *stream_info;
     struct wined3d_event_query *ib_query = NULL;
     struct wined3d_stream_info si_emulated;
@@ -608,47 +607,47 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
 
     if (!index_count) return;
 
+    context = context_acquire(device, wined3d_rendertarget_view_get_surface(state->fb.render_targets[0]));
+    if (!context->valid)
+    {
+        context_release(context);
+        WARN("Invalid context, skipping draw.\n");
+        return;
+    }
+    gl_info = context->gl_info;
+
     if (state->render_states[WINED3D_RS_COLORWRITEENABLE])
     {
         /* Invalidate the back buffer memory so LockRect will read it the next time */
         for (i = 0; i < device->adapter->gl_info.limits.buffers; ++i)
         {
-            struct wined3d_surface *target = wined3d_rendertarget_view_get_surface(device->fb.render_targets[i]);
+            struct wined3d_surface *target = wined3d_rendertarget_view_get_surface(state->fb.render_targets[i]);
             if (target)
             {
-                surface_load_location(target, target->container->resource.draw_binding);
-                surface_invalidate_location(target, ~target->container->resource.draw_binding);
+                wined3d_resource_load_location(&target->resource, context, target->container->resource.draw_binding);
+                wined3d_resource_invalidate_location(&target->resource, ~target->container->resource.draw_binding);
             }
         }
     }
 
-    context = context_acquire(device, wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]));
-    if (!context->valid)
-    {
-        context_release(context);
-        WARN("Invalid context, skipping draw.\n");
-        return;
-    }
-    gl_info = context->gl_info;
-
-    if (device->fb.depth_stencil)
+    if (state->fb.depth_stencil)
     {
         /* Note that this depends on the context_acquire() call above to set
          * context->render_offscreen properly. We don't currently take the
          * Z-compare function into account, but we could skip loading the
          * depthstencil for D3DCMP_NEVER and D3DCMP_ALWAYS as well. Also note
          * that we never copy the stencil data.*/
-        DWORD location = context->render_offscreen ? device->fb.depth_stencil->resource->draw_binding
+        DWORD location = context->render_offscreen ? state->fb.depth_stencil->resource->draw_binding
                 : WINED3D_LOCATION_DRAWABLE;
         if (state->render_states[WINED3D_RS_ZWRITEENABLE] || state->render_states[WINED3D_RS_ZENABLE])
         {
-            struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(device->fb.depth_stencil);
+            struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(state->fb.depth_stencil);
             RECT current_rect, draw_rect, r;
 
-            if (!context->render_offscreen && ds != device->onscreen_depth_stencil)
-                device_switch_onscreen_ds(device, context, ds);
+            if (!context->render_offscreen && ds != device->cs->onscreen_depth_stencil)
+                wined3d_cs_switch_onscreen_ds(device->cs, context, ds);
 
-            if (ds->locations & location)
+            if (ds->resource.locations & location)
                 SetRect(&current_rect, 0, 0, ds->ds_current_size.cx, ds->ds_current_size.cy);
             else
                 SetRectEmpty(&current_rect);
@@ -661,16 +660,16 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
         }
     }
 
-    if (!context_apply_draw_state(context, device))
+    if (!context_apply_draw_state(context, device, state))
     {
         context_release(context);
         WARN("Unable to apply draw state, skipping draw.\n");
         return;
     }
 
-    if (device->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
+    if (state->fb.depth_stencil && state->render_states[WINED3D_RS_ZWRITEENABLE])
     {
-        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(device->fb.depth_stencil);
+        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(state->fb.depth_stencil);
         DWORD location = context->render_offscreen ? ds->container->resource.draw_binding : WINED3D_LOCATION_DRAWABLE;
 
         surface_modify_ds_location(ds, location, ds->ds_current_size.cx, ds->ds_current_size.cy);
@@ -753,24 +752,24 @@ void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_co
             else
                 WARN_(d3d_perf)("Using immediate mode with vertex shaders for half float emulation.\n");
 
-            drawStridedSlowVs(context, state, stream_info, index_count,
+            draw_strided_slow_vs(context, state, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
         else
         {
-            drawStridedSlow(device, context, stream_info, index_count,
+            draw_strided_slow(state, context, stream_info, index_count,
                     state->gl_primitive_type, idx_data, idx_size, start_idx);
         }
     }
     else if (!gl_info->supported[ARB_INSTANCED_ARRAYS] && instance_count)
     {
         /* Instancing emulation by mixing immediate mode and arrays. */
-        drawStridedInstanced(context, state, stream_info, index_count, state->gl_primitive_type,
+        draw_strided_instanced(context, state, stream_info, index_count, state->gl_primitive_type,
                 idx_data, idx_size, start_idx, state->base_vertex_index, instance_count);
     }
     else
     {
-        drawStridedFast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
+        draw_strided_fast(gl_info, state->gl_primitive_type, index_count, idx_size, idx_data,
                 start_idx, state->base_vertex_index, start_instance, instance_count);
     }
 
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index 7379ba2..6120663 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -953,10 +953,8 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
         const struct wined3d_shader_reg_maps *reg_maps, const struct shader_glsl_ctx_priv *ctx_priv)
 {
     const struct wined3d_shader_version *version = &reg_maps->shader_version;
-    const struct wined3d_state *state = &shader->device->state;
     const struct ps_compile_args *ps_args = ctx_priv->cur_ps_args;
     const struct wined3d_gl_info *gl_info = context->gl_info;
-    const struct wined3d_fb_state *fb = &shader->device->fb;
     unsigned int i, extra_constants_needed = 0;
     const struct wined3d_shader_lconst *lconst;
     const char *prefix;
@@ -1182,7 +1180,7 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
         {
             UINT in_count = min(vec4_varyings(version->major, gl_info), shader->limits->packed_input);
 
-            if (use_vs(state))
+            if (ps_args->vp_mode == vertexshader)
                 shader_addline(buffer, "varying vec4 %s_in[%u];\n", prefix, in_count);
             else
                 /* TODO: Write a replacement shader for the fixed function
@@ -1229,21 +1227,14 @@ static void shader_generate_glsl_declarations(const struct wined3d_context *cont
             }
             else
             {
-                float ycorrection[] =
-                {
-                    context->render_offscreen ? 0.0f : fb->render_targets[0]->height,
-                    context->render_offscreen ? 1.0f : -1.0f,
-                    0.0f,
-                    0.0f,
-                };
-
                 /* This happens because we do not have proper tracking of the
                  * constant registers that are actually used, only the max
-                 * limit of the shader version. */
+                 * limit of the shader version.
+                 *
+                 * FIXME 2: This is wrong, there's no need to do this. Get rid of
+                 * it and just create the uniform.
+                 */
                 FIXME("Cannot find a free uniform for vpos correction params\n");
-                shader_addline(buffer, "const vec4 ycorrection = ");
-                shader_glsl_append_imm_vec4(buffer, ycorrection);
-                shader_addline(buffer, ";\n");
             }
             shader_addline(buffer, "vec4 vpos;\n");
         }
@@ -2348,6 +2339,7 @@ static void shader_glsl_relop(const struct wined3d_shader_instruction *ins)
             case WINED3DSIH_EQ:  op = "equal"; break;
             case WINED3DSIH_GE:  op = "greaterThanEqual"; break;
             case WINED3DSIH_IGE: op = "greaterThanEqual"; break;
+            case WINED3DSIH_UGE: op = "greaterThanEqual"; break;
             case WINED3DSIH_LT:  op = "lessThan"; break;
             default:
                 op = "<unhandled operator>";
@@ -2365,6 +2357,7 @@ static void shader_glsl_relop(const struct wined3d_shader_instruction *ins)
             case WINED3DSIH_EQ:  op = "=="; break;
             case WINED3DSIH_GE:  op = ">="; break;
             case WINED3DSIH_IGE: op = ">="; break;
+            case WINED3DSIH_UGE: op = ">="; break;
             case WINED3DSIH_LT:  op = "<"; break;
             default:
                 op = "<unhandled operator>";
@@ -3360,7 +3353,7 @@ static void shader_glsl_if(const struct wined3d_shader_instruction *ins)
     struct glsl_src_param src0_param;
 
     shader_glsl_add_src_param(ins, &ins->src[0], WINED3DSP_WRITEMASK_0, &src0_param);
-    shader_addline(ins->ctx->buffer, "if (%s) {\n", src0_param.param_str);
+    shader_addline(ins->ctx->buffer, "if (bool(%s)) {\n", src0_param.param_str);
 }
 
 static void shader_glsl_ifc(const struct wined3d_shader_instruction *ins)
@@ -6764,6 +6757,7 @@ static const SHADER_HANDLER shader_glsl_instruction_handler_table[WINED3DSIH_TAB
     /* WINED3DSIH_TEXREG2GB             */ shader_glsl_texreg2gb,
     /* WINED3DSIH_TEXREG2RGB            */ shader_glsl_texreg2rgb,
     /* WINED3DSIH_UDIV                  */ shader_glsl_udiv,
+    /* WINED3DSIH_UGE                   */ shader_glsl_relop,
     /* WINED3DSIH_USHR                  */ shader_glsl_binop,
     /* WINED3DSIH_UTOF                  */ shader_glsl_to_float,
     /* WINED3DSIH_XOR                   */ shader_glsl_binop,
diff --git a/dlls/wined3d/query.c b/dlls/wined3d/query.c
index e755764..f33b30e 100644
--- a/dlls/wined3d/query.c
+++ b/dlls/wined3d/query.c
@@ -233,6 +233,36 @@ ULONG CDECL wined3d_query_incref(struct wined3d_query *query)
     return refcount;
 }
 
+void wined3d_query_destroy(struct wined3d_query *query)
+{
+    /* Queries are specific to the GL context that created them. Not
+     * deleting the query will obviously leak it, but that's still better
+     * than potentially deleting a different query with the same id in this
+     * context, and (still) leaking the actual query. */
+    if (query->type == WINED3D_QUERY_TYPE_EVENT)
+    {
+        struct wined3d_event_query *event_query = query->extendedData;
+        if (event_query) wined3d_event_query_destroy(event_query);
+    }
+    else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
+    {
+        struct wined3d_occlusion_query *oq = query->extendedData;
+
+        if (oq->context) context_free_occlusion_query(oq);
+        HeapFree(GetProcessHeap(), 0, query->extendedData);
+    }
+    else if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP)
+    {
+        struct wined3d_timestamp_query *tq = query->extendedData;
+
+        if (tq->context)
+            context_free_timestamp_query(tq);
+        HeapFree(GetProcessHeap(), 0, query->extendedData);
+    }
+
+    HeapFree(GetProcessHeap(), 0, query);
+}
+
 ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
 {
     ULONG refcount = InterlockedDecrement(&query->ref);
@@ -240,34 +270,7 @@ ULONG CDECL wined3d_query_decref(struct wined3d_query *query)
     TRACE("%p decreasing refcount to %u.\n", query, refcount);
 
     if (!refcount)
-    {
-        /* Queries are specific to the GL context that created them. Not
-         * deleting the query will obviously leak it, but that's still better
-         * than potentially deleting a different query with the same id in this
-         * context, and (still) leaking the actual query. */
-        if (query->type == WINED3D_QUERY_TYPE_EVENT)
-        {
-            struct wined3d_event_query *event_query = query->extendedData;
-            if (event_query) wined3d_event_query_destroy(event_query);
-        }
-        else if (query->type == WINED3D_QUERY_TYPE_OCCLUSION)
-        {
-            struct wined3d_occlusion_query *oq = query->extendedData;
-
-            if (oq->context) context_free_occlusion_query(oq);
-            HeapFree(GetProcessHeap(), 0, query->extendedData);
-        }
-        else if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP)
-        {
-            struct wined3d_timestamp_query *tq = query->extendedData;
-
-            if (tq->context)
-                context_free_timestamp_query(tq);
-            HeapFree(GetProcessHeap(), 0, query->extendedData);
-        }
-
-        HeapFree(GetProcessHeap(), 0, query);
-    }
+        wined3d_cs_emit_query_destroy(query->device->cs, query);
 
     return refcount;
 }
@@ -292,7 +295,17 @@ HRESULT CDECL wined3d_query_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
-    return query->query_ops->query_issue(query, flags);
+    if (flags & WINED3DISSUE_END)
+        query->counter_main++;
+
+    wined3d_cs_emit_query_issue(query->device->cs, query, flags);
+
+    if (flags & WINED3DISSUE_BEGIN)
+        query->state = QUERY_BUILDING;
+    else
+        query->state = QUERY_SIGNALLED;
+
+    return WINED3D_OK;
 }
 
 static void fill_query_data(void *out, unsigned int out_size, const void *result, unsigned int result_size)
@@ -303,18 +316,10 @@ static void fill_query_data(void *out, unsigned int out_size, const void *result
 static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
-    struct wined3d_occlusion_query *oq = query->extendedData;
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
-    struct wined3d_context *context;
-    GLuint available;
+    struct wined3d_occlusion_query *oq = query->extendedData;
     GLuint samples;
-    HRESULT res;
-
-    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
-
-    if (!oq->context)
-        query->state = QUERY_CREATED;
 
     if (query->state == QUERY_CREATED)
     {
@@ -325,6 +330,8 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+    TRACE("(%p) : type D3DQUERY_OCCLUSION, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
     if (query->state == QUERY_BUILDING)
     {
         /* Msdn says this returns an error, but our tests show that S_FALSE is returned */
@@ -340,12 +347,37 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
         return S_OK;
     }
 
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        fill_query_data(data, size, &oq->samples, sizeof(oq->samples));
+
+    return S_OK;
+}
+
+static BOOL wined3d_occlusion_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_occlusion_query *oq = query->extendedData;
+    struct wined3d_device *device = query->device;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_context *context;
+    GLuint available;
+    GLuint samples;
+    BOOL ret;
+
     if (oq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
-        samples = 1;
-        fill_query_data(data, size, &samples, sizeof(samples));
-        return S_OK;
+        oq->samples = 1;
+        return TRUE;
     }
 
     context = context_acquire(query->device, oq->context->current_rt);
@@ -356,68 +388,78 @@ static HRESULT wined3d_occlusion_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
-        if (size)
-        {
-            GL_EXTCALL(glGetQueryObjectuivARB(oq->id, GL_QUERY_RESULT_ARB, &samples));
-            checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
-            TRACE("Returning %d samples.\n", samples);
-            fill_query_data(data, size, &samples, sizeof(samples));
-        }
-        res = S_OK;
+        GL_EXTCALL(glGetQueryObjectuivARB(oq->id, GL_QUERY_RESULT_ARB, &samples));
+        checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
+        TRACE("Returning %d samples.\n", samples);
+        oq->samples = samples;
+        ret = TRUE;
     }
     else
     {
-        res = S_FALSE;
+        ret = FALSE;
     }
 
     context_release(context);
 
-    return res;
+    return ret;
 }
 
-static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
-        void *data, DWORD size, DWORD flags)
+static BOOL wined3d_event_query_ops_poll(struct wined3d_query *query)
 {
     struct wined3d_event_query *event_query = query->extendedData;
-    BOOL signaled;
     enum wined3d_event_query_result ret;
 
-    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
-
-    if (!data || !size) return S_OK;
-    if (!event_query)
-    {
-        WARN("Event query not supported by GL, reporting GPU idle.\n");
-        signaled = TRUE;
-        fill_query_data(data, size, &signaled, sizeof(signaled));
-        return S_OK;
-    }
-
     ret = wined3d_event_query_test(event_query, query->device);
     switch(ret)
     {
         case WINED3D_EVENT_QUERY_OK:
         case WINED3D_EVENT_QUERY_NOT_STARTED:
-            signaled = TRUE;
-            fill_query_data(data, size, &signaled, sizeof(signaled));
-            break;
+            return TRUE;
 
         case WINED3D_EVENT_QUERY_WAITING:
-            signaled = FALSE;
-            fill_query_data(data, size, &signaled, sizeof(signaled));
-            break;
+            return FALSE;
 
         case WINED3D_EVENT_QUERY_WRONG_THREAD:
             FIXME("(%p) Wrong thread, reporting GPU idle.\n", query);
-            signaled = TRUE;
-            fill_query_data(data, size, &signaled, sizeof(signaled));
-            break;
+            return TRUE;
 
         case WINED3D_EVENT_QUERY_ERROR:
             ERR("The GL event query failed, returning D3DERR_INVALIDCALL\n");
-            return WINED3DERR_INVALIDCALL;
+            return TRUE;
+
+        default:
+            ERR("Unexpected wined3d_event_query_test result %u\n", ret);
+            return TRUE;
+    }
+}
+
+static HRESULT wined3d_event_query_ops_get_data(struct wined3d_query *query,
+        void *pData, DWORD dwSize, DWORD flags)
+{
+    struct wined3d_event_query *event_query = query->extendedData;
+    BOOL *data = pData;
+    enum wined3d_event_query_result ret;
+
+    TRACE("query %p, pData %p, dwSize %#x, flags %#x.\n", query, pData, dwSize, flags);
+
+    if (!pData || !dwSize) return S_OK;
+    if (!event_query)
+    {
+        WARN("Event query not supported by GL, reporting GPU idle.\n");
+        *data = TRUE;
+        return S_OK;
     }
 
+    if (!wined3d_settings.cs_multithreaded)
+        ret = query->query_ops->query_poll(query);
+    else if (query->counter_main != query->counter_retrieved)
+        ret = FALSE;
+    else
+        ret = TRUE;
+
+    if (data)
+        fill_query_data(data, dwSize, &ret, sizeof(ret));
+
     return S_OK;
 }
 
@@ -435,7 +477,7 @@ enum wined3d_query_type CDECL wined3d_query_get_type(const struct wined3d_query
     return query->type;
 }
 
-static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -445,28 +487,24 @@ static HRESULT wined3d_event_query_ops_issue(struct wined3d_query *query, DWORD
         struct wined3d_event_query *event_query = query->extendedData;
 
         /* Faked event query support */
-        if (!event_query) return WINED3D_OK;
+        if (!event_query) return FALSE;
 
         wined3d_event_query_issue(event_query, query->device);
+        return TRUE;
     }
     else if (flags & WINED3DISSUE_BEGIN)
     {
         /* Started implicitly at device creation */
         ERR("Event query issued with START flag - what to do?\n");
     }
-
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    else
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK;
+    return FALSE;
 }
 
-static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    BOOL poll = FALSE;
 
     TRACE("query %p, flags %#x.\n", query, flags);
 
@@ -478,7 +516,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         /* This is allowed according to msdn and our tests. Reset the query and restart */
         if (flags & WINED3DISSUE_BEGIN)
         {
-            if (query->state == QUERY_BUILDING)
+            if (oq->started)
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -507,6 +545,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
             checkGLcall("glBeginQuery()");
 
             context_release(context);
+            oq->started = TRUE;
         }
         if (flags & WINED3DISSUE_END)
         {
@@ -514,7 +553,7 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
              * our tests show that it returns OK. But OpenGL doesn't like it, so avoid
              * generating an error
              */
-            if (query->state == QUERY_BUILDING)
+            if (oq->started)
             {
                 if (oq->context->tid != GetCurrentThreadId())
                 {
@@ -528,8 +567,10 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
                     checkGLcall("glEndQuery()");
 
                     context_release(context);
+                    poll = TRUE;
                 }
             }
+            oq->started = FALSE;
         }
     }
     else
@@ -537,45 +578,64 @@ static HRESULT wined3d_occlusion_query_ops_issue(struct wined3d_query *query, DW
         FIXME("%p Occlusion queries not supported.\n", query);
     }
 
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    else
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK; /* can be WINED3DERR_INVALIDCALL.    */
+    return poll;
 }
 
 static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
     struct wined3d_timestamp_query *tq = query->extendedData;
+
+    TRACE("(%p) : type D3DQUERY_TIMESTAMP, data %p, size %#x, flags %#x.\n", query, data, size, flags);
+
+    if (query->state == QUERY_CREATED)
+    {
+        UINT64 zero = 0;
+        /* D3D allows GetData on a new query, OpenGL doesn't. So just invent the data ourselves */
+        TRACE("Query wasn't yet started, returning S_OK.\n");
+        if (data)
+            fill_query_data(data, size, &zero, sizeof(zero));
+        return S_OK;
+    }
+
+    if (!wined3d_settings.cs_multithreaded)
+    {
+        if (!query->query_ops->query_poll(query))
+            return S_FALSE;
+    }
+    else if (query->counter_main != query->counter_retrieved)
+    {
+        return S_FALSE;
+    }
+
+    if (data)
+        fill_query_data(data, size, &tq->timestamp, sizeof(tq->timestamp));
+
+    return S_OK;
+}
+
+static BOOL wined3d_timestamp_query_ops_poll(struct wined3d_query *query)
+{
+    struct wined3d_timestamp_query *tq = query->extendedData;
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_context *context;
     GLuint available;
     GLuint64 timestamp;
-    HRESULT res;
+    BOOL ret;
 
-    TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
-
-    if (!tq->context)
-        query->state = QUERY_CREATED;
-
-    if (query->state == QUERY_CREATED)
+    if (!gl_info->supported[ARB_TIMER_QUERY])
     {
-        /* D3D allows GetData on a new query, OpenGL doesn't. So just invent the data ourselves. */
-        TRACE("Query wasn't yet started, returning S_OK.\n");
-        timestamp = 0;
-        fill_query_data(data, size, &timestamp, sizeof(timestamp));
-        return S_OK;
+        TRACE("Faking timestamp.\n");
+        QueryPerformanceCounter((LARGE_INTEGER *)&tq->timestamp);
+        return TRUE;
     }
 
     if (tq->context->tid != GetCurrentThreadId())
     {
         FIXME("%p Wrong thread, returning 1.\n", query);
-        timestamp = 1;
-        fill_query_data(data, size, &timestamp, sizeof(timestamp));
-        return S_OK;
+        tq->timestamp = 1;
+        return TRUE;
     }
 
     context = context_acquire(query->device, tq->context->current_rt);
@@ -586,26 +646,23 @@ static HRESULT wined3d_timestamp_query_ops_get_data(struct wined3d_query *query,
 
     if (available)
     {
-        if (size)
-        {
-            GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT_ARB, &timestamp));
-            checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
-            TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
-            fill_query_data(data, size, &timestamp, sizeof(timestamp));
-        }
-        res = S_OK;
+        GL_EXTCALL(glGetQueryObjectui64v(tq->id, GL_QUERY_RESULT_ARB, &timestamp));
+        checkGLcall("glGetQueryObjectuivARB(GL_QUERY_RESULT)");
+        TRACE("Returning timestamp %s.\n", wine_dbgstr_longlong(timestamp));
+        tq->timestamp = timestamp;
+        ret = TRUE;
     }
     else
     {
-        res = S_FALSE;
+        ret = FALSE;
     }
 
     context_release(context);
 
-    return res;
+    return ret;
 }
 
-static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DWORD flags)
 {
     struct wined3d_device *device = query->device;
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
@@ -638,24 +695,22 @@ static HRESULT wined3d_timestamp_query_ops_issue(struct wined3d_query *query, DW
     }
 
     if (flags & WINED3DISSUE_END)
-        query->state = QUERY_SIGNALLED;
-
-    return WINED3D_OK;
+        return TRUE;
+    return FALSE;
 }
 
 static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_query *query,
         void *data, DWORD size, DWORD flags)
 {
     TRACE("query %p, data %p, size %#x, flags %#x.\n", query, data, size, flags);
-
     if (query->type == WINED3D_QUERY_TYPE_TIMESTAMP_DISJOINT)
     {
         static const struct wined3d_query_data_timestamp_disjoint disjoint_data = {FALSE, 1000 * 1000 * 1000};
 
         if (query->state == QUERY_BUILDING)
         {
-            TRACE("Query is building, returning S_FALSE.\n");
-            return S_FALSE;
+             TRACE("Query is building, returning S_FALSE.\n");
+             return S_FALSE;
         }
 
         fill_query_data(data, size, &disjoint_data, sizeof(disjoint_data));
@@ -669,39 +724,42 @@ static HRESULT wined3d_timestamp_disjoint_query_ops_get_data(struct wined3d_quer
     return S_OK;
 }
 
-static HRESULT wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+static BOOL wined3d_timestamp_disjoint_query_ops_poll(struct wined3d_query *query)
 {
-    TRACE("query %p, flags %#x.\n", query, flags);
-
-    if (flags & WINED3DISSUE_BEGIN)
-        query->state = QUERY_BUILDING;
-    if (flags & WINED3DISSUE_END)
-        query->state = QUERY_SIGNALLED;
+    return TRUE;
+}
 
-    return WINED3D_OK;
+static BOOL wined3d_timestamp_disjoint_query_ops_issue(struct wined3d_query *query, DWORD flags)
+{
+    TRACE("query %p, flags %#x.\n", query, flags);
+    return FALSE;
 }
 
 static const struct wined3d_query_ops event_query_ops =
 {
     wined3d_event_query_ops_get_data,
+    wined3d_event_query_ops_poll,
     wined3d_event_query_ops_issue,
 };
 
 static const struct wined3d_query_ops occlusion_query_ops =
 {
     wined3d_occlusion_query_ops_get_data,
+    wined3d_occlusion_query_ops_poll,
     wined3d_occlusion_query_ops_issue,
 };
 
 static const struct wined3d_query_ops timestamp_query_ops =
 {
     wined3d_timestamp_query_ops_get_data,
+    wined3d_timestamp_query_ops_poll,
     wined3d_timestamp_query_ops_issue,
 };
 
 static const struct wined3d_query_ops timestamp_disjoint_query_ops =
 {
     wined3d_timestamp_disjoint_query_ops_get_data,
+    wined3d_timestamp_disjoint_query_ops_poll,
     wined3d_timestamp_disjoint_query_ops_issue,
 };
 
@@ -723,13 +781,13 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
             }
             query->query_ops = &occlusion_query_ops;
             query->data_size = sizeof(DWORD);
-            query->extendedData = HeapAlloc(GetProcessHeap(), 0, sizeof(struct wined3d_occlusion_query));
+            query->extendedData = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+                    sizeof(struct wined3d_occlusion_query));
             if (!query->extendedData)
             {
                 ERR("Failed to allocate occlusion query extended data.\n");
                 return E_OUTOFMEMORY;
             }
-            ((struct wined3d_occlusion_query *)query->extendedData)->context = NULL;
             break;
 
         case WINED3D_QUERY_TYPE_EVENT:
@@ -802,6 +860,7 @@ static HRESULT query_init(struct wined3d_query *query, struct wined3d_device *de
     query->state = QUERY_CREATED;
     query->device = device;
     query->ref = 1;
+    list_init(&query->poll_list_entry);
 
     return WINED3D_OK;
 }
diff --git a/dlls/wined3d/resource.c b/dlls/wined3d/resource.c
index 0ab55dc..dc36dd5 100644
--- a/dlls/wined3d/resource.c
+++ b/dlls/wined3d/resource.c
@@ -119,6 +119,7 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
             ERR("Failed to allocate system memory.\n");
             return E_OUTOFMEMORY;
         }
+        resource->heap_memory = resource->map_heap_memory;
     }
     else
     {
@@ -142,6 +143,31 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
     return WINED3D_OK;
 }
 
+void wined3d_resource_free_bo(struct wined3d_resource *resource)
+{
+    struct wined3d_context *context = context_acquire(resource->device, NULL);
+
+    if (resource->buffer != resource->map_buffer)
+        ERR("Releasing resource buffer with buffer != map_buffer.\n");
+
+    wined3d_device_release_bo(resource->device, resource->buffer, context);
+    resource->buffer = NULL;
+    resource->map_buffer = NULL;
+
+    context_release(context);
+}
+
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource)
+{
+    context_resource_released(resource->device, resource, resource->type);
+
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
+    wined3d_resource_free_sysmem(resource);
+    resource->map_heap_memory = NULL;
+}
+
 void resource_cleanup(struct wined3d_resource *resource)
 {
     const struct wined3d *d3d = resource->device->wined3d;
@@ -154,7 +180,7 @@ void resource_cleanup(struct wined3d_resource *resource)
         adapter_adjust_memory(resource->device->adapter, (INT64)0 - resource->size);
     }
 
-    wined3d_resource_free_sysmem(resource);
+    wined3d_cs_emit_resource_cleanup(resource->device->cs, resource);
 
     device_resource_released(resource->device, resource);
 }
@@ -164,6 +190,9 @@ void resource_unload(struct wined3d_resource *resource)
     if (resource->map_count)
         ERR("Resource %p is being unloaded while mapped.\n", resource);
 
+    if (resource->buffer)
+        wined3d_resource_free_bo(resource);
+
     context_resource_unloaded(resource->device,
             resource, resource->type);
 }
@@ -226,7 +255,7 @@ BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource)
     p = (void **)(((ULONG_PTR)mem + align) & ~(RESOURCE_ALIGNMENT - 1)) - 1;
     *p = mem;
 
-    resource->heap_memory = ++p;
+    resource->map_heap_memory = ++p;
 
     return TRUE;
 }
@@ -292,7 +321,7 @@ GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags)
     return ret;
 }
 
-GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
+static GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags)
 {
     if (d3d_flags & WINED3D_MAP_READONLY)
         return GL_READ_ONLY_ARB;
@@ -331,3 +360,580 @@ void wined3d_resource_update_draw_binding(struct wined3d_resource *resource)
     else
         resource->draw_binding = WINED3D_LOCATION_TEXTURE_RGB;
 }
+
+void wined3d_resource_validate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations |= location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+}
+
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource, DWORD location)
+{
+    TRACE("Resource %p, setting %s.\n", resource, wined3d_debug_location(location));
+    resource->locations &= ~location;
+    TRACE("new location flags are %s.\n", wined3d_debug_location(resource->locations));
+
+    resource->resource_ops->resource_location_invalidated(resource, location);
+}
+
+DWORD wined3d_resource_access_from_location(DWORD location)
+{
+    switch (location)
+    {
+        case WINED3D_LOCATION_DISCARDED:
+            return 0;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_USER_MEMORY:
+        case WINED3D_LOCATION_DIB:
+            return WINED3D_RESOURCE_ACCESS_CPU;
+
+        case WINED3D_LOCATION_BUFFER:
+        case WINED3D_LOCATION_TEXTURE_RGB:
+        case WINED3D_LOCATION_TEXTURE_SRGB:
+        case WINED3D_LOCATION_DRAWABLE:
+        case WINED3D_LOCATION_RB_MULTISAMPLE:
+        case WINED3D_LOCATION_RB_RESOLVED:
+            return WINED3D_RESOURCE_ACCESS_GPU;
+
+        default:
+            FIXME("Unhandled location %#x.\n", location);
+            return 0;
+    }
+}
+
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data)
+{
+    if (location & WINED3D_LOCATION_BUFFER)
+    {
+        data->buffer_object = resource->buffer->name;
+        data->addr = NULL;
+        return;
+    }
+    if (location & WINED3D_LOCATION_USER_MEMORY)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->user_memory;
+        return;
+    }
+    if (location & WINED3D_LOCATION_DIB)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->bitmap_data;
+        return;
+    }
+    if (location & WINED3D_LOCATION_SYSMEM)
+    {
+        data->buffer_object = 0;
+        data->addr = resource->heap_memory;
+        return;
+    }
+    ERR("Unexpected location %s.\n", wined3d_debug_location(location));
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+static void wined3d_resource_copy_simple_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    const struct wined3d_gl_info *gl_info;
+    struct wined3d_bo_address dst, src;
+    UINT size = resource->size;
+
+    wined3d_resource_get_memory(resource, location, &dst);
+    wined3d_resource_get_memory(resource, resource->locations, &src);
+
+    if (dst.buffer_object)
+    {
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, dst.buffer_object));
+        GL_EXTCALL(glBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0, size, src.addr));
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+        checkGLcall("Upload PBO");
+        return;
+    }
+    if (src.buffer_object)
+    {
+        gl_info = context->gl_info;
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, src.buffer_object));
+        GL_EXTCALL(glGetBufferSubDataARB(GL_PIXEL_PACK_BUFFER_ARB, 0, size, dst.addr));
+        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
+        checkGLcall("Download PBO");
+        return;
+    }
+    memcpy(dst.addr, src.addr, size);
+}
+
+/* Context activation is optionally by the caller. Context may be NULL. */
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    DWORD required_access = wined3d_resource_access_from_location(location);
+    DWORD simple_locations = WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if ((resource->locations & location) == location)
+    {
+        TRACE("Location(s) already up to date.\n");
+        return;
+    }
+
+    /* Keep this a WARN for now until surfaces are cleaned up. */
+    if ((resource->access_flags & required_access) != required_access)
+        WARN("Operation requires %#x access, but resource only has %#x.\n",
+                required_access, resource->access_flags);
+
+    if (location & simple_locations)
+    {
+        if (resource->locations & WINED3D_LOCATION_DISCARDED)
+        {
+            TRACE("Resource was discarded, nothing to do.\n");
+            resource->locations |= location;
+            return;
+        }
+        if (resource->locations & simple_locations)
+        {
+            wined3d_resource_copy_simple_location(resource, context, location);
+            resource->locations |= location;
+            return;
+        }
+    }
+
+    /* Context is NULL in ddraw-only operation without OpenGL. */
+    if (!context)
+        ERR("A context is required for non-sysmem operation.\n");
+
+    resource->resource_ops->resource_load_location(resource, context, location);
+}
+
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags)
+{
+    const struct wined3d_gl_info *gl_info;
+    BYTE *ptr;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->map_buffer->name));
+
+            if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
+            {
+                GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
+                mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
+                ptr = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB,
+                        0, resource->size, mapflags));
+            }
+            else
+            {
+                GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
+                ptr = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, access));
+            }
+
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            checkGLcall("Map GL buffer");
+            return ptr;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return resource->map_heap_memory;
+
+        case WINED3D_LOCATION_DIB:
+            return resource->bitmap_data;
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            return resource->user_memory;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return NULL;
+    }
+}
+
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context)
+{
+    const struct wined3d_gl_info *gl_info;
+
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            gl_info = context->gl_info;
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, resource->map_buffer->name));
+            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
+            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
+            checkGLcall("Unmap GL buffer");
+            return;
+
+        case WINED3D_LOCATION_SYSMEM:
+        case WINED3D_LOCATION_DIB:
+        case WINED3D_LOCATION_USER_MEMORY:
+            return;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return;
+    }
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_resource_prepare_bo(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    if (resource->buffer)
+        return;
+
+    resource->buffer = wined3d_device_get_bo(resource->device, resource->size,
+            GL_STREAM_DRAW_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, context);
+    resource->map_buffer = resource->buffer;
+    TRACE("Created GL buffer %u for resource %p.\n", resource->buffer->name, resource);
+    resource->map_heap_memory = NULL;
+}
+
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource)
+{
+    if (resource->heap_memory)
+        return TRUE;
+
+    if (!wined3d_resource_allocate_sysmem(resource))
+    {
+        ERR("Failed to allocate system memory.\n");
+        return FALSE;
+    }
+    resource->heap_memory = resource->map_heap_memory;
+    return TRUE;
+}
+
+/* Context activation is done by the caller. */
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource, struct wined3d_context *context)
+{
+    switch (resource->map_binding)
+    {
+        case WINED3D_LOCATION_BUFFER:
+            wined3d_resource_prepare_bo(resource, context);
+            return TRUE;
+
+        case WINED3D_LOCATION_SYSMEM:
+            return wined3d_resource_prepare_system_memory(resource);
+
+        case WINED3D_LOCATION_USER_MEMORY:
+            if (!resource->user_memory)
+                ERR("Map binding is set to WINED3D_LOCATION_USER_MEMORY but resource->user_memory is NULL.\n");
+            return TRUE;
+
+        case WINED3D_LOCATION_DIB:
+            if (!resource->bitmap_data)
+                ERR("Map binding is set to WINED3D_LOCATION_DIB but resource->bitmap_data is NULL.\n");
+            return TRUE;
+
+        default:
+            ERR("Unexpected map binding %s.\n", wined3d_debug_location(resource->map_binding));
+            return FALSE;
+    }
+}
+
+void CDECL wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch)
+{
+    unsigned int alignment;
+    const struct wined3d_format *format = resource->format;
+
+    if (resource->custom_row_pitch)
+    {
+        *row_pitch = resource->custom_row_pitch;
+        *slice_pitch = resource->custom_slice_pitch;
+        return;
+    }
+
+    alignment = resource->device->surface_alignment;
+    *row_pitch = wined3d_format_calculate_pitch(resource->format, resource->width);
+    *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
+    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
+    {
+        /* Since compressed formats are block based, pitch means the amount of
+         * bytes to the next row of block rather than the next row of pixels. */
+        UINT slice_block_count = (resource->height + format->block_height - 1) / format->block_height;
+        *slice_pitch = *row_pitch * slice_block_count;
+    }
+    else
+    {
+        *slice_pitch = *row_pitch * resource->height;
+    }
+
+    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
+}
+
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box)
+{
+    UINT width_mask, height_mask;
+    const struct wined3d_format *format = resource->format;
+
+    if (!box)
+        return TRUE;
+
+    /* This assumes power of two block sizes, but NPOT block sizes would be
+     * silly anyway.
+     *
+     * This also assumes that the format's block depth is 1. */
+    width_mask = format->block_width - 1;
+    height_mask = format->block_height - 1;
+
+    if (box->left & width_mask)
+        return FALSE;
+    if (box->top & height_mask)
+        return FALSE;
+    if (box->right & width_mask && box->right != resource->width)
+        return FALSE;
+    if (box->bottom & height_mask && box->bottom != resource->height)
+        return FALSE;
+
+    return TRUE;
+}
+
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+    void *mem;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(resource, context))
+    {
+        WARN("Out of memory.\n");
+        context_release(context);
+        return NULL;
+    }
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+                resource->map_buffer = wined3d_device_get_bo(device, resource->size,
+                        GL_STREAM_DRAW_ARB, GL_PIXEL_UNPACK_BUFFER_ARB, context);
+                break;
+
+            case WINED3D_LOCATION_SYSMEM:
+                wined3d_resource_allocate_sysmem(resource);
+                break;
+
+            default:
+                if (resource->access_fence)
+                    ERR("Location %s does not support DISCARD maps.\n",
+                            wined3d_debug_location(resource->map_binding));
+                if (resource->pool != WINED3D_POOL_DEFAULT)
+                    FIXME("Discard used on %s pool resource.\n", debug_d3dpool(resource->pool));
+        }
+        wined3d_resource_validate_location(resource, resource->map_binding);
+    }
+    else
+    {
+        wined3d_resource_load_location(resource, context, resource->map_binding);
+    }
+
+    mem = wined3d_resource_get_map_ptr(resource, context, flags);
+
+    if (context)
+        context_release(context);
+
+    return mem;
+}
+
+static void wined3d_resource_sync(struct wined3d_resource *resource)
+{
+    struct wined3d_resource *real_res = resource;
+    struct wined3d_surface *surface;
+    struct wined3d_volume *volume;
+
+    switch (resource->type)
+    {
+        case WINED3D_RTYPE_SURFACE:
+            surface = surface_from_resource(resource);
+            if (surface->container)
+                real_res = &surface->container->resource;
+            break;
+
+        case WINED3D_RTYPE_VOLUME:
+            volume = volume_from_resource(resource);
+            real_res = &volume->container->resource;
+            break;
+
+        default:
+            break;
+    }
+    wined3d_resource_wait_fence(real_res);
+}
+
+HRESULT wined3d_resource_map(struct wined3d_resource *resource,
+        struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
+{
+    struct wined3d_device *device = resource->device;
+    BYTE *base_memory;
+    const struct wined3d_format *format = resource->format;
+
+    TRACE("resource %p, map_desc %p, box %p, flags %#x.\n",
+            resource, map_desc, box, flags);
+
+    if (resource->usage & WINED3DUSAGE_RENDERTARGET && wined3d_settings.ignore_rt_map)
+    {
+        WARN("Ignoring render target map, only finishing CS.\n");
+        wined3d_cs_emit_glfinish(device->cs);
+        map_desc->row_pitch = 0;
+        map_desc->slice_pitch = 0;
+        map_desc->data = NULL;
+        device->cs->ops->finish(device->cs);
+        return WINED3D_OK;
+    }
+
+    if (resource->map_count)
+    {
+        WARN("Volume is already mapped.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    flags = wined3d_resource_sanitize_map_flags(resource, flags);
+
+    if (flags & WINED3D_MAP_NOOVERWRITE)
+        FIXME("WINED3D_MAP_NOOVERWRITE are not implemented yet.\n");
+
+    if (flags & WINED3D_MAP_DISCARD)
+    {
+        switch (resource->map_binding)
+        {
+            case WINED3D_LOCATION_BUFFER:
+            case WINED3D_LOCATION_SYSMEM:
+                break;
+
+            default:
+                FIXME("Implement discard maps with %s map binding.\n",
+                        wined3d_debug_location(resource->map_binding));
+                wined3d_resource_sync(resource);
+        }
+    }
+    else
+        wined3d_resource_sync(resource);
+
+    base_memory = wined3d_cs_emit_resource_map(device->cs, resource, flags);
+    if (!base_memory)
+    {
+        WARN("Map failed.\n");
+        return WINED3DERR_INVALIDCALL;
+    }
+
+    TRACE("Base memory pointer %p.\n", base_memory);
+
+    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
+    {
+        map_desc->row_pitch = resource->width * format->byte_count;
+        map_desc->slice_pitch = map_desc->row_pitch * resource->height;
+    }
+    else
+    {
+        wined3d_resource_get_pitch(resource, &map_desc->row_pitch, &map_desc->slice_pitch);
+    }
+
+    if (!box)
+    {
+        TRACE("No box supplied - all is ok\n");
+        map_desc->data = base_memory;
+    }
+    else
+    {
+        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
+                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
+
+        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
+        {
+            /* Compressed textures are block based, so calculate the offset of
+             * the block that contains the top-left pixel of the locked rectangle. */
+            map_desc->data = base_memory
+                    + (box->front * map_desc->slice_pitch)
+                    + ((box->top / format->block_height) * map_desc->row_pitch)
+                    + ((box->left / format->block_width) * format->block_byte_count);
+        }
+        else
+        {
+            map_desc->data = base_memory
+                    + (map_desc->slice_pitch * box->front)
+                    + (map_desc->row_pitch * box->top)
+                    + (box->left * format->byte_count);
+        }
+    }
+
+    if (!(flags & WINED3D_MAP_READONLY))
+        resource->unmap_dirtify = TRUE;
+
+    resource->map_count++;
+
+    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
+            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    struct wined3d_context *context = NULL;
+
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+    wined3d_resource_release_map_ptr(resource, context);
+    if (context)
+        context_release(context);
+}
+
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource)
+{
+    struct wined3d_device *device = resource->device;
+    TRACE("resource %p.\n", resource);
+
+    if (resource->usage & WINED3DUSAGE_RENDERTARGET && wined3d_settings.ignore_rt_map)
+    {
+        WARN("Ignoring render target unmap.\n");
+        return WINED3D_OK;
+    }
+
+    if (!resource->map_count)
+    {
+        WARN("Trying to unlock an unlocked resource %p.\n", resource);
+        return WINEDDERR_NOTLOCKED;
+    }
+
+    wined3d_cs_emit_resource_unmap(device->cs, resource);
+
+    if (resource->unmap_dirtify)
+    {
+        wined3d_cs_emit_resource_changed(device->cs, resource,
+                resource->map_buffer, resource->map_heap_memory);
+    }
+    resource->unmap_dirtify = FALSE;
+
+    resource->map_count--;
+
+    return WINED3D_OK;
+}
+
+void wined3d_resource_changed(struct wined3d_resource *resource, struct wined3d_gl_bo *swap_buffer,
+        void *swap_heap_memory)
+{
+    struct wined3d_device *device = resource->device;
+
+    if (swap_buffer && swap_buffer != resource->buffer)
+    {
+        struct wined3d_context *context = context_acquire(device, NULL);
+        wined3d_device_release_bo(device, resource->buffer, context);
+        context_release(context);
+        resource->buffer = swap_buffer;
+    }
+    if (swap_heap_memory && swap_heap_memory != resource->heap_memory)
+    {
+        wined3d_resource_free_sysmem(resource);
+        resource->heap_memory = swap_heap_memory;
+    }
+
+    wined3d_resource_invalidate_location(resource, ~resource->map_binding);
+}
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index 7a98dd8..844f049 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -150,6 +150,7 @@ static const char * const shader_opcode_names[] =
     /* WINED3DSIH_TEXREG2GB             */ "texreg2gb",
     /* WINED3DSIH_TEXREG2RGB            */ "texreg2rgb",
     /* WINED3DSIH_UDIV                  */ "udiv",
+    /* WINED3DSIH_UGE                   */ "uge",
     /* WINED3DSIH_USHR                  */ "ushr",
     /* WINED3DSIH_UTOF                  */ "utof",
     /* WINED3DSIH_XOR                   */ "xor",
@@ -1601,7 +1602,7 @@ static void shader_trace_init(const struct wined3d_shader_frontend *fe, void *fe
     }
 }
 
-static void shader_cleanup(struct wined3d_shader *shader)
+void shader_cleanup(struct wined3d_shader *shader)
 {
     HeapFree(GetProcessHeap(), 0, shader->signature_strings);
     shader->device->shader_backend->shader_destroy(shader);
@@ -1856,9 +1857,10 @@ ULONG CDECL wined3d_shader_decref(struct wined3d_shader *shader)
 
     if (!refcount)
     {
-        shader_cleanup(shader);
+        const struct wined3d_device *device = shader->device;
+
         shader->parent_ops->wined3d_object_destroyed(shader->parent);
-        HeapFree(GetProcessHeap(), 0, shader);
+        wined3d_cs_emit_shader_cleanup(device->cs, shader);
     }
 
     return refcount;
@@ -2083,7 +2085,7 @@ void find_ps_compile_args(const struct wined3d_state *state, const struct wined3
     memset(args, 0, sizeof(*args)); /* FIXME: Make sure all bits are set. */
     if (!gl_info->supported[ARB_FRAMEBUFFER_SRGB] && state->render_states[WINED3D_RS_SRGBWRITEENABLE])
     {
-        const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+        const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
         if (rt_format->flags & WINED3DFMT_FLAG_SRGB_WRITE)
         {
             static unsigned int warned = 0;
diff --git a/dlls/wined3d/shader_sm4.c b/dlls/wined3d/shader_sm4.c
index cba55ad..ac0fab5 100644
--- a/dlls/wined3d/shader_sm4.c
+++ b/dlls/wined3d/shader_sm4.c
@@ -117,6 +117,7 @@ enum wined3d_sm4_opcode
     WINED3D_SM4_OP_SQRT                 = 0x4b,
     WINED3D_SM4_OP_SINCOS               = 0x4d,
     WINED3D_SM4_OP_UDIV                 = 0x4e,
+    WINED3D_SM4_OP_UGE                  = 0x50,
     WINED3D_SM4_OP_USHR                 = 0x55,
     WINED3D_SM4_OP_UTOF                 = 0x56,
     WINED3D_SM4_OP_XOR                  = 0x57,
@@ -259,6 +260,7 @@ static const struct wined3d_sm4_opcode_info opcode_table[] =
     {WINED3D_SM4_OP_SQRT,                   WINED3DSIH_SQRT,                "F",    "F"},
     {WINED3D_SM4_OP_SINCOS,                 WINED3DSIH_SINCOS,              "FF",   "F"},
     {WINED3D_SM4_OP_UDIV,                   WINED3DSIH_UDIV,                "UU",   "UU"},
+    {WINED3D_SM4_OP_UGE,                    WINED3DSIH_UGE,                 "U",    "UU"},
     {WINED3D_SM4_OP_USHR,                   WINED3DSIH_USHR,                "U",    "UU"},
     {WINED3D_SM4_OP_UTOF,                   WINED3DSIH_UTOF,                "F",    "U"},
     {WINED3D_SM4_OP_XOR,                    WINED3DSIH_XOR,                 "U",    "UU"},
diff --git a/dlls/wined3d/state.c b/dlls/wined3d/state.c
index 700db84..ba5c127 100644
--- a/dlls/wined3d/state.c
+++ b/dlls/wined3d/state.c
@@ -106,7 +106,7 @@ static void state_zenable(struct wined3d_context *context, const struct wined3d_
     static UINT once;
 
     /* No z test without depth stencil buffers */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         TRACE("No Z buffer - disabling depth test\n");
         zenable = WINED3D_ZB_FALSE;
@@ -381,7 +381,7 @@ static GLenum gl_blend_factor(enum wined3d_blend factor, const struct wined3d_fo
 
 static void state_blend(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+    const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
     const struct wined3d_gl_info *gl_info = context->gl_info;
     GLenum srcBlend, dstBlend;
     enum wined3d_blend d3d_blend;
@@ -826,7 +826,7 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
     GLint depthFail_ccw;
 
     /* No stencil test without a stencil buffer. */
-    if (!state->fb->depth_stencil)
+    if (!state->fb.depth_stencil)
     {
         gl_info->gl_ops.gl.p_glDisable(GL_STENCIL_TEST);
         checkGLcall("glDisable GL_STENCIL_TEST");
@@ -912,7 +912,7 @@ static void state_stencil(struct wined3d_context *context, const struct wined3d_
 
 static void state_stencilwrite2s(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     GL_EXTCALL(glActiveStencilFaceEXT(GL_BACK));
@@ -926,7 +926,7 @@ static void state_stencilwrite2s(struct wined3d_context *context, const struct w
 
 static void state_stencilwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    DWORD mask = state->fb->depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
+    DWORD mask = state->fb.depth_stencil ? state->render_states[WINED3D_RS_STENCILWRITEMASK] : 0;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     gl_info->gl_ops.gl.p_glStencilMask(mask);
@@ -1168,7 +1168,7 @@ void state_fog_fragpart(struct wined3d_context *context, const struct wined3d_st
 
                 case WINED3D_FOG_NONE:
                     /* Both are none? According to msdn the alpha channel of the specular
-                     * color contains a fog factor. Set it in drawStridedSlow.
+                     * color contains a fog factor. Set it in draw_strided_slow.
                      * Same happens with Vertexfog on transformed vertices
                      */
                     new_source = FOGSOURCE_COORD;
@@ -1765,7 +1765,7 @@ static void state_depthbias(struct wined3d_context *context, const struct wined3
     if (state->render_states[WINED3D_RS_SLOPESCALEDEPTHBIAS]
             || state->render_states[WINED3D_RS_DEPTHBIAS])
     {
-        const struct wined3d_rendertarget_view *depth = state->fb->depth_stencil;
+        const struct wined3d_rendertarget_view *depth = state->fb.depth_stencil;
         float scale;
 
         union
@@ -4296,7 +4296,7 @@ static void load_vertex_data(struct wined3d_context *context,
                 }
             }
         } else {
-            /* TODO: support blends in drawStridedSlow
+            /* TODO: support blends in draw_strided_slow
              * No need to write a FIXME here, this is done after the general vertex decl decoding
              */
             WARN("unsupported blending in openGl\n");
@@ -4653,7 +4653,7 @@ void vertexdeclaration(struct wined3d_context *context, const struct wined3d_sta
 
 static void viewport_miscpart(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+    const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
     const struct wined3d_gl_info *gl_info = context->gl_info;
     struct wined3d_viewport vp = state->viewport;
 
@@ -4833,7 +4833,7 @@ static void scissorrect(struct wined3d_context *context, const struct wined3d_st
     }
     else
     {
-        const struct wined3d_rendertarget_view *target = state->fb->render_targets[0];
+        const struct wined3d_rendertarget_view *target = state->fb.render_targets[0];
         UINT height;
         UINT width;
 
@@ -4900,7 +4900,7 @@ static void psorigin(struct wined3d_context *context, const struct wined3d_state
 
 void state_srgbwrite(struct wined3d_context *context, const struct wined3d_state *state, DWORD state_id)
 {
-    const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+    const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
     const struct wined3d_gl_info *gl_info = context->gl_info;
 
     TRACE("context %p, state %p, state_id %#x.\n", context, state, state_id);
diff --git a/dlls/wined3d/stateblock.c b/dlls/wined3d/stateblock.c
index 7e8c782..705251d 100644
--- a/dlls/wined3d/stateblock.c
+++ b/dlls/wined3d/stateblock.c
@@ -463,6 +463,7 @@ void state_unbind_resources(struct wined3d_state *state)
     struct wined3d_texture *texture;
     struct wined3d_buffer *buffer;
     struct wined3d_shader *shader;
+    struct wined3d_rendertarget_view *view;
     unsigned int i, j;
 
     if ((decl = state->vertex_declaration))
@@ -530,6 +531,31 @@ void state_unbind_resources(struct wined3d_state *state)
             }
         }
     }
+
+    if (state->fb.depth_stencil)
+    {
+        view = state->fb.depth_stencil;
+
+        TRACE("Releasing depth/stencil buffer %p.\n", view);
+
+        state->fb.depth_stencil = NULL;
+        wined3d_rendertarget_view_decref(view);
+    }
+
+    if (state->fb.render_targets)
+    {
+        for (i = 0; i < state->fb.rt_size; i++)
+        {
+            view = state->fb.render_targets[i];
+            TRACE("Setting rendertarget %u to NULL\n", i);
+            state->fb.render_targets[i] = NULL;
+            if (view)
+            {
+                TRACE("Releasing the rendertarget view at %p\n", view);
+                wined3d_rendertarget_view_decref(view);
+            }
+        }
+    }
 }
 
 void state_cleanup(struct wined3d_state *state)
@@ -557,6 +583,7 @@ void state_cleanup(struct wined3d_state *state)
 
     HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
     HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+    HeapFree(GetProcessHeap(), 0, state->fb.render_targets);
 }
 
 ULONG CDECL wined3d_stateblock_decref(struct wined3d_stateblock *stateblock)
@@ -1038,8 +1065,8 @@ void CDECL wined3d_stateblock_apply(const struct wined3d_stateblock *stateblock)
         gl_primitive_type = stateblock->state.gl_primitive_type;
         prev = device->update_state->gl_primitive_type;
         device->update_state->gl_primitive_type = gl_primitive_type;
-        if (gl_primitive_type != prev && (gl_primitive_type == GL_POINTS || prev == GL_POINTS))
-            device_invalidate_state(device, STATE_POINT_SIZE_ENABLE);
+        if (gl_primitive_type != prev)
+            wined3d_cs_emit_set_primitive_type(device->cs, gl_primitive_type);
     }
 
     if (stateblock->changed.indices)
@@ -1302,17 +1329,23 @@ static void state_init_default(struct wined3d_state *state, const struct wined3d
         state->sampler_states[i][WINED3D_SAMP_ELEMENT_INDEX] = 0;
         /* TODO: Vertex offset in the presampled displacement map. */
         state->sampler_states[i][WINED3D_SAMP_DMAP_OFFSET] = 0;
+        state->textures[i] = NULL;
     }
+
+    state->index_buffer = NULL;
+    for (i = 0; i < sizeof(state->streams) / sizeof(*state->streams); i++)
+        memset(&state->streams[i], 0, sizeof(state->streams[i]));
+
+    state->shader[WINED3D_SHADER_TYPE_VERTEX] = NULL;
+    state->shader[WINED3D_SHADER_TYPE_PIXEL] = NULL;
 }
 
-HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
-        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
-        DWORD flags)
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags)
 {
     unsigned int i;
 
     state->flags = flags;
-    state->fb = fb;
 
     for (i = 0; i < LIGHTMAP_SIZE; i++)
     {
@@ -1330,6 +1363,15 @@ HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
         return E_OUTOFMEMORY;
     }
 
+    if (!(state->fb.render_targets = HeapAlloc(GetProcessHeap(), HEAP_ZERO_MEMORY,
+            sizeof(*state->fb.render_targets) * gl_info->limits.buffers)))
+    {
+        HeapFree(GetProcessHeap(), 0, state->ps_consts_f);
+        HeapFree(GetProcessHeap(), 0, state->vs_consts_f);
+        return E_OUTOFMEMORY;
+    }
+    state->fb.rt_size = gl_info->limits.buffers;
+
     if (flags & WINED3D_STATE_INIT_DEFAULT)
         state_init_default(state, gl_info);
 
@@ -1340,12 +1382,13 @@ static HRESULT stateblock_init(struct wined3d_stateblock *stateblock,
         struct wined3d_device *device, enum wined3d_stateblock_type type)
 {
     HRESULT hr;
+    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     const struct wined3d_d3d_info *d3d_info = &device->adapter->d3d_info;
 
     stateblock->ref = 1;
     stateblock->device = device;
 
-    if (FAILED(hr = state_init(&stateblock->state, NULL, &device->adapter->gl_info, d3d_info, 0)))
+    if (FAILED(hr = state_init(&stateblock->state, gl_info, d3d_info, 0)))
         return hr;
 
     if (FAILED(hr = stateblock_allocate_shader_constants(stateblock)))
diff --git a/dlls/wined3d/surface.c b/dlls/wined3d/surface.c
index 092cbe6..9ab0738 100644
--- a/dlls/wined3d/surface.c
+++ b/dlls/wined3d/surface.c
@@ -36,18 +36,14 @@ WINE_DECLARE_DEBUG_CHANNEL(d3d);
 
 #define MAXLOCKCOUNT 50 /* After this amount of locks do not free the sysmem copy. */
 
-static const DWORD surface_simple_locations =
-        WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
-        | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
 
-static void surface_cleanup(struct wined3d_surface *surface)
-{
-    struct wined3d_surface *overlay, *cur;
-
-    TRACE("surface %p.\n", surface);
+static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter);
 
-    if (surface->pbo || surface->rb_multisample
-            || surface->rb_resolved || !list_empty(&surface->renderbuffers))
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface)
+{
+    if (surface->rb_multisample || surface->rb_resolved || !list_empty(&surface->renderbuffers))
     {
         struct wined3d_renderbuffer_entry *entry, *entry2;
         const struct wined3d_gl_info *gl_info;
@@ -56,12 +52,6 @@ static void surface_cleanup(struct wined3d_surface *surface)
         context = context_acquire(surface->resource.device, NULL);
         gl_info = context->gl_info;
 
-        if (surface->pbo)
-        {
-            TRACE("Deleting PBO %u.\n", surface->pbo);
-            GL_EXTCALL(glDeleteBuffersARB(1, &surface->pbo));
-        }
-
         if (surface->rb_multisample)
         {
             TRACE("Deleting multisample renderbuffer %u.\n", surface->rb_multisample);
@@ -88,9 +78,21 @@ static void surface_cleanup(struct wined3d_surface *surface)
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
-        surface->dib.bitmap_data = NULL;
+        surface->resource.bitmap_data = NULL;
     }
 
+    TRACE("Destroyed surface %p.\n", surface);
+    HeapFree(GetProcessHeap(), 0, surface);
+}
+
+static void surface_cleanup(struct wined3d_surface *surface)
+{
+    struct wined3d_surface *overlay, *cur;
+    struct wined3d_cs *cs = surface->resource.device->cs;
+    BOOL user_mem = surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY;
+
+    TRACE("surface %p.\n", surface);
+
     if (surface->overlay_dest)
         list_remove(&surface->overlay_entry);
 
@@ -101,15 +103,21 @@ static void surface_cleanup(struct wined3d_surface *surface)
     }
 
     resource_cleanup(&surface->resource);
+    wined3d_cs_emit_surface_cleanup(cs, surface);
+
+    /* Wait for the CS to finish operations on this surface when user memory was in use.
+     * The application is allowed to free the memory after texture / surface destruction
+     * returns. */
+    if (user_mem)
+        wined3d_resource_wait_fence(&surface->container->resource);
 }
 
 void wined3d_surface_destroy(struct wined3d_surface *surface)
 {
     TRACE("surface %p.\n", surface);
 
-    surface_cleanup(surface);
     surface->resource.parent_ops->wined3d_object_destroyed(surface->resource.parent);
-    HeapFree(GetProcessHeap(), 0, surface);
+    surface_cleanup(surface);
 }
 
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
@@ -364,6 +372,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     BITMAPINFO *b_info;
     int extraline = 0;
     DWORD *masks;
+    UINT row_pitch, slice_pitch;
 
     TRACE("surface %p.\n", surface);
 
@@ -409,10 +418,11 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
 
     b_info->bmiHeader.biSize = sizeof(BITMAPINFOHEADER);
     /* TODO: Is there a nicer way to force a specific alignment? (8 byte for ddraw) */
-    b_info->bmiHeader.biWidth = wined3d_surface_get_pitch(surface) / format->byte_count;
+    wined3d_resource_get_pitch(&surface->resource, &row_pitch, &slice_pitch);
+    b_info->bmiHeader.biWidth = row_pitch / format->byte_count;
     b_info->bmiHeader.biHeight = 0 - surface->resource.height - extraline;
     b_info->bmiHeader.biSizeImage = (surface->resource.height + extraline)
-            * wined3d_surface_get_pitch(surface);
+            * row_pitch;
     b_info->bmiHeader.biPlanes = 1;
     b_info->bmiHeader.biBitCount = format->byte_count * 8;
 
@@ -454,7 +464,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     TRACE("Creating a DIB section with size %dx%dx%d, size=%d.\n",
             b_info->bmiHeader.biWidth, b_info->bmiHeader.biHeight,
             b_info->bmiHeader.biBitCount, b_info->bmiHeader.biSizeImage);
-    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->dib.bitmap_data, 0, 0);
+    surface->dib.DIBsection = CreateDIBSection(0, b_info, DIB_RGB_COLORS, &surface->resource.bitmap_data, 0, 0);
 
     if (!surface->dib.DIBsection)
     {
@@ -463,7 +473,7 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
         return HRESULT_FROM_WIN32(GetLastError());
     }
 
-    TRACE("DIBSection at %p.\n", surface->dib.bitmap_data);
+    TRACE("DIBSection at %p.\n", surface->resource.bitmap_data);
     surface->dib.bitmap_size = b_info->bmiHeader.biSizeImage;
 
     HeapFree(GetProcessHeap(), 0, b_info);
@@ -477,114 +487,6 @@ static HRESULT surface_create_dib_section(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
-static void surface_get_memory(const struct wined3d_surface *surface, struct wined3d_bo_address *data,
-        DWORD location)
-{
-    if (location & WINED3D_LOCATION_BUFFER)
-    {
-        data->addr = NULL;
-        data->buffer_object = surface->pbo;
-        return;
-    }
-    if (location & WINED3D_LOCATION_USER_MEMORY)
-    {
-        data->addr = surface->user_memory;
-        data->buffer_object = 0;
-        return;
-    }
-    if (location & WINED3D_LOCATION_DIB)
-    {
-        data->addr = surface->dib.bitmap_data;
-        data->buffer_object = 0;
-        return;
-    }
-    if (location & WINED3D_LOCATION_SYSMEM)
-    {
-        data->addr = surface->resource.heap_memory;
-        data->buffer_object = 0;
-        return;
-    }
-
-    ERR("Unexpected locations %s.\n", wined3d_debug_location(location));
-    data->addr = NULL;
-    data->buffer_object = 0;
-}
-
-static void surface_prepare_buffer(struct wined3d_surface *surface)
-{
-    struct wined3d_context *context;
-    GLenum error;
-    const struct wined3d_gl_info *gl_info;
-
-    if (surface->pbo)
-        return;
-
-    context = context_acquire(surface->resource.device, NULL);
-    gl_info = context->gl_info;
-
-    GL_EXTCALL(glGenBuffersARB(1, &surface->pbo));
-    error = gl_info->gl_ops.gl.p_glGetError();
-    if (!surface->pbo || error != GL_NO_ERROR)
-        ERR("Failed to create a PBO with error %s (%#x).\n", debug_glerror(error), error);
-
-    TRACE("Binding PBO %u.\n", surface->pbo);
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-    checkGLcall("glBindBufferARB");
-
-    GL_EXTCALL(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->resource.size + 4,
-            NULL, GL_STREAM_DRAW_ARB));
-    checkGLcall("glBufferDataARB");
-
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-    checkGLcall("glBindBufferARB");
-
-    context_release(context);
-}
-
-static void surface_prepare_system_memory(struct wined3d_surface *surface)
-{
-    TRACE("surface %p.\n", surface);
-
-    if (surface->resource.heap_memory)
-        return;
-
-    /* Whatever surface we have, make sure that there is memory allocated
-     * for the downloaded copy, or a PBO to map. */
-    if (!wined3d_resource_allocate_sysmem(&surface->resource))
-        ERR("Failed to allocate system memory.\n");
-
-    if (surface->locations & WINED3D_LOCATION_SYSMEM)
-        ERR("Surface without system memory has WINED3D_LOCATION_SYSMEM set.\n");
-}
-
-void surface_prepare_map_memory(struct wined3d_surface *surface)
-{
-    switch (surface->resource.map_binding)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-            surface_prepare_system_memory(surface);
-            break;
-
-        case WINED3D_LOCATION_USER_MEMORY:
-            if (!surface->user_memory)
-                ERR("Map binding is set to WINED3D_LOCATION_USER_MEMORY but surface->user_memory is NULL.\n");
-            break;
-
-        case WINED3D_LOCATION_DIB:
-            if (!surface->dib.bitmap_data)
-                ERR("Map binding is set to WINED3D_LOCATION_DIB but surface->dib.bitmap_data is NULL.\n");
-            break;
-
-        case WINED3D_LOCATION_BUFFER:
-            surface_prepare_buffer(surface);
-            break;
-
-        default:
-            ERR("Unexpected map binding %s.\n", wined3d_debug_location(surface->resource.map_binding));
-    }
-}
-
 static void surface_evict_sysmem(struct wined3d_surface *surface)
 {
     /* In some conditions the surface memory must not be freed:
@@ -597,29 +499,8 @@ static void surface_evict_sysmem(struct wined3d_surface *surface)
         return;
 
     wined3d_resource_free_sysmem(&surface->resource);
-    surface_invalidate_location(surface, WINED3D_LOCATION_SYSMEM);
-}
-
-static void surface_release_client_storage(struct wined3d_surface *surface)
-{
-    struct wined3d_context *context = context_acquire(surface->resource.device, NULL);
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (surface->container->texture_rgb.name)
-    {
-        wined3d_texture_bind_and_dirtify(surface->container, context, FALSE);
-        gl_info->gl_ops.gl.p_glTexImage2D(surface->texture_target, surface->texture_level,
-                GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
-    }
-    if (surface->container->texture_srgb.name)
-    {
-        wined3d_texture_bind_and_dirtify(surface->container, context, TRUE);
-        gl_info->gl_ops.gl.p_glTexImage2D(surface->texture_target, surface->texture_level,
-                GL_RGB, 1, 1, 0, GL_RGB, GL_UNSIGNED_BYTE, NULL);
-    }
-    wined3d_texture_force_reload(surface->container);
-
-    context_release(context);
+    surface->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
 }
 
 static BOOL surface_use_pbo(const struct wined3d_surface *surface)
@@ -704,7 +585,7 @@ static HRESULT surface_private_setup(struct wined3d_surface *surface)
     }
 
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
-        surface->locations = WINED3D_LOCATION_DISCARDED;
+        surface->resource.locations = WINED3D_LOCATION_DISCARDED;
 
     if (surface_use_pbo(surface))
         surface->resource.map_binding = WINED3D_LOCATION_BUFFER;
@@ -712,48 +593,22 @@ static HRESULT surface_private_setup(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
-static void surface_unmap(struct wined3d_surface *surface)
+static void surface_frontbuffer_updated(struct wined3d_surface *surface)
 {
+    struct wined3d_context *context = NULL;
     struct wined3d_device *device = surface->resource.device;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_context *context;
-
-    TRACE("surface %p.\n", surface);
-
-    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
-
-    switch (surface->resource.map_binding)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-        case WINED3D_LOCATION_USER_MEMORY:
-        case WINED3D_LOCATION_DIB:
-            break;
-
-        case WINED3D_LOCATION_BUFFER:
-            context = context_acquire(device, NULL);
-            gl_info = context->gl_info;
-
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-            GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-            checkGLcall("glUnmapBufferARB");
-            context_release(context);
-            break;
-
-        default:
-            ERR("Unexpected map binding %s.\n", wined3d_debug_location(surface->resource.map_binding));
-    }
 
-    if (surface->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_TEXTURE_RGB))
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
     {
         TRACE("Not dirtified, nothing to do.\n");
         return;
     }
 
-    if (surface->container->swapchain && surface->container->swapchain->front_buffer == surface->container)
-        surface_load_location(surface, surface->container->resource.draw_binding);
-    else if (surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL))
-        FIXME("Depth / stencil buffer locking is not implemented.\n");
+    if (device->d3d_initialized)
+        context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_load_location(&surface->resource, context, surface->container->resource.draw_binding);
+    if (context)
+        context_release(context);
 }
 
 static BOOL surface_is_full_rect(const struct wined3d_surface *surface, const RECT *r)
@@ -804,12 +659,6 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
     if (src_mask & WINED3DFMT_FLAG_STENCIL)
         gl_mask |= GL_STENCIL_BUFFER_BIT;
 
-    /* Make sure the locations are up-to-date. Loading the destination
-     * surface isn't required if the entire surface is overwritten. */
-    surface_load_location(src_surface, src_location);
-    if (!surface_is_full_rect(dst_surface, dst_rect))
-        surface_load_location(dst_surface, dst_location);
-
     context = context_acquire(device, NULL);
     if (!context->valid)
     {
@@ -818,6 +667,12 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
         return;
     }
 
+    /* Make sure the locations are up-to-date. Loading the destination
+     * surface isn't required if the entire surface is overwritten. */
+    wined3d_resource_load_location(&src_surface->resource, context, src_location);
+    if (!surface_is_full_rect(dst_surface, dst_rect))
+        wined3d_resource_load_location(&dst_surface->resource, context, dst_location);
+
     gl_info = context->gl_info;
 
     context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, NULL, src_surface, src_location);
@@ -858,13 +713,15 @@ static void surface_depth_blt_fbo(const struct wined3d_device *device,
 }
 
 /* Blit between surface locations. Onscreen on different swapchains is not supported.
- * Depth / stencil is not supported. */
-static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_texture_filter_type filter,
+ * Depth / stencil is not supported. Context activation is done by the caller. */
+static void surface_blt_fbo(const struct wined3d_device *device,
+        struct wined3d_context *old_ctx, enum wined3d_texture_filter_type filter,
         struct wined3d_surface *src_surface, DWORD src_location, const RECT *src_rect_in,
         struct wined3d_surface *dst_surface, DWORD dst_location, const RECT *dst_rect_in)
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    struct wined3d_surface *required_rt, *restore_rt;
     RECT src_rect, dst_rect;
     GLenum gl_filter;
     GLenum buffer;
@@ -903,13 +760,24 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
      * surface isn't required if the entire surface is overwritten. (And is
      * in fact harmful if we're being called by surface_load_location() with
      * the purpose of loading the destination surface.) */
-    surface_load_location(src_surface, src_location);
+    wined3d_resource_load_location(&src_surface->resource, old_ctx, src_location);
     if (!surface_is_full_rect(dst_surface, &dst_rect))
-        surface_load_location(dst_surface, dst_location);
+        wined3d_resource_load_location(&dst_surface->resource, old_ctx, dst_location);
 
-    if (src_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, src_surface);
-    else if (dst_location == WINED3D_LOCATION_DRAWABLE) context = context_acquire(device, dst_surface);
-    else context = context_acquire(device, NULL);
+    if (src_location == WINED3D_LOCATION_DRAWABLE) required_rt = src_surface;
+    else if (dst_location == WINED3D_LOCATION_DRAWABLE) required_rt = dst_surface;
+    else required_rt = NULL;
+
+    if (required_rt && required_rt != old_ctx->current_rt)
+    {
+        restore_rt = context->current_rt;
+        context = context_acquire(device, required_rt);
+    }
+    else
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
 
     if (!context->valid)
     {
@@ -972,7 +840,12 @@ static void surface_blt_fbo(const struct wined3d_device *device, enum wined3d_te
             && dst_surface->container->swapchain->front_buffer == dst_surface->container))
         gl_info->gl_ops.gl.p_glFlush();
 
-    context_release(context);
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
 }
 
 static BOOL fbo_blit_supported(const struct wined3d_gl_info *gl_info, enum wined3d_blit_op blit_op,
@@ -1149,16 +1022,6 @@ HRESULT CDECL wined3d_surface_get_render_target_data(struct wined3d_surface *sur
     return wined3d_surface_blt(surface, NULL, render_target, NULL, 0, NULL, WINED3D_TEXF_POINT);
 }
 
-/* Context activation is done by the caller. */
-static void surface_remove_pbo(struct wined3d_surface *surface, const struct wined3d_gl_info *gl_info)
-{
-    GL_EXTCALL(glDeleteBuffersARB(1, &surface->pbo));
-    checkGLcall("glDeleteBuffersARB(1, &surface->pbo)");
-
-    surface->pbo = 0;
-    surface_invalidate_location(surface, WINED3D_LOCATION_BUFFER);
-}
-
 static ULONG surface_resource_incref(struct wined3d_resource *resource)
 {
     return wined3d_surface_incref(surface_from_resource(resource));
@@ -1179,21 +1042,17 @@ static void surface_unload(struct wined3d_resource *resource)
 
     TRACE("surface %p.\n", surface);
 
+    context = context_acquire(device, NULL);
+    gl_info = context->gl_info;
+
     if (resource->pool == WINED3D_POOL_DEFAULT)
     {
         /* Default pool resources are supposed to be destroyed before Reset is called.
          * Implicit resources stay however. So this means we have an implicit render target
          * or depth stencil. The content may be destroyed, but we still have to tear down
-         * opengl resources, so we cannot leave early.
-         *
-         * Put the surfaces into sysmem, and reset the content. The D3D content is undefined,
-         * but we can't set the sysmem INDRAWABLE because when we're rendering the swapchain
-         * or the depth stencil into an FBO the texture or render buffer will be removed
-         * and all flags get lost */
-        surface_prepare_system_memory(surface);
-        memset(surface->resource.heap_memory, 0, surface->resource.size);
-        surface_validate_location(surface, WINED3D_LOCATION_SYSMEM);
-        surface_invalidate_location(surface, ~WINED3D_LOCATION_SYSMEM);
+         * opengl resources, so we cannot leave early. */
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DISCARDED);
 
         /* We also get here when the ddraw swapchain is destroyed, for example
          * for a mode switch. In this case this surface won't necessarily be
@@ -1203,18 +1062,11 @@ static void surface_unload(struct wined3d_resource *resource)
     }
     else
     {
-        surface_prepare_map_memory(surface);
-        surface_load_location(surface, surface->resource.map_binding);
-        surface_invalidate_location(surface, ~surface->resource.map_binding);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
     }
 
-    context = context_acquire(device, NULL);
-    gl_info = context->gl_info;
-
-    /* Destroy PBOs, but load them into real sysmem before */
-    if (surface->pbo)
-        surface_remove_pbo(surface, gl_info);
-
     /* Destroy fbo render buffers. This is needed for implicit render targets, for
      * all application-created targets the application has to release the surface
      * before calling _Reset
@@ -1244,17 +1096,21 @@ static void surface_unload(struct wined3d_resource *resource)
     resource_unload(resource);
 }
 
-static const struct wined3d_resource_ops surface_resource_ops =
+static void wined3d_surface_location_invalidated(struct wined3d_resource *resource, DWORD location)
 {
-    surface_resource_incref,
-    surface_resource_decref,
-    surface_unload,
-};
+    struct wined3d_surface *surface = surface_from_resource(resource);
+
+    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+        wined3d_texture_set_dirty(surface->container);
+
+    if (surface->container->swapchain && surface->container == surface->container->swapchain->front_buffer)
+        surface->surface_ops->surface_frontbuffer_updated(surface);
+}
 
 static const struct wined3d_surface_ops surface_ops =
 {
     surface_private_setup,
-    surface_unmap,
+    surface_frontbuffer_updated,
 };
 
 /*****************************************************************************
@@ -1298,21 +1154,15 @@ static HRESULT gdi_surface_private_setup(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
-static void gdi_surface_unmap(struct wined3d_surface *surface)
+static void gdi_surface_frontbuffer_updated(struct wined3d_surface *surface)
 {
-    TRACE("surface %p.\n", surface);
-
-    /* Tell the swapchain to update the screen. */
-    if (surface->container->swapchain && surface->container == surface->container->swapchain->front_buffer)
-        x11_copy_to_screen(surface->container->swapchain, &surface->lockedRect);
-
-    memset(&surface->lockedRect, 0, sizeof(RECT));
+    x11_copy_to_screen(surface->container->swapchain, &surface->lockedRect);
 }
 
 static const struct wined3d_surface_ops gdi_surface_ops =
 {
     gdi_surface_private_setup,
-    gdi_surface_unmap,
+    gdi_surface_frontbuffer_updated,
 };
 
 /* This call just downloads data, the caller is responsible for binding the
@@ -1331,7 +1181,7 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         return;
     }
 
-    surface_get_memory(surface, &data, dst_location);
+    wined3d_resource_get_memory(&surface->resource, dst_location, &data);
 
     if (format->flags & WINED3DFMT_FLAG_COMPRESSED)
     {
@@ -1359,14 +1209,14 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
         void *mem;
         GLenum gl_format = format->glFormat;
         GLenum gl_type = format->glType;
-        int src_pitch = 0;
-        int dst_pitch = 0;
+        UINT src_pitch = 0;
+        UINT dst_row_pitch, dst_slice_pitch;
 
         if (surface->flags & SFLAG_NONPOW2)
         {
             unsigned char alignment = surface->resource.device->surface_alignment;
             src_pitch = format->byte_count * surface->pow2Width;
-            dst_pitch = wined3d_surface_get_pitch(surface);
+            wined3d_resource_get_pitch(&surface->resource, &dst_row_pitch, &dst_slice_pitch);
             src_pitch = (src_pitch + alignment - 1) & ~(alignment - 1);
             mem = HeapAlloc(GetProcessHeap(), 0, src_pitch * surface->pow2Height);
         }
@@ -1453,12 +1303,12 @@ static void surface_download_data(struct wined3d_surface *surface, const struct
              * won't be released, and doesn't have to be re-read. */
             src_data = mem;
             dst_data = data.addr;
-            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_pitch);
+            TRACE("(%p) : Repacking the surface data from pitch %d to pitch %d\n", surface, src_pitch, dst_row_pitch);
             for (y = 0; y < surface->resource.height; ++y)
             {
-                memcpy(dst_data, src_data, dst_pitch);
+                memcpy(dst_data, src_data, dst_row_pitch);
                 src_data += src_pitch;
-                dst_data += dst_pitch;
+                dst_data += dst_row_pitch;
             }
 
             HeapFree(GetProcessHeap(), 0, mem);
@@ -1580,25 +1430,20 @@ static void surface_upload_data(struct wined3d_surface *surface, const struct wi
     }
 }
 
-static BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect)
 {
-    UINT width_mask, height_mask;
-
-    if (!rect->left && !rect->top
-            && rect->right == surface->resource.width
-            && rect->bottom == surface->resource.height)
-        return TRUE;
-
-    /* This assumes power of two block sizes, but NPOT block sizes would be
-     * silly anyway. */
-    width_mask = surface->resource.format->block_width - 1;
-    height_mask = surface->resource.format->block_height - 1;
-
-    if (!(rect->left & width_mask) && !(rect->top & height_mask)
-            && !(rect->right & width_mask) && !(rect->bottom & height_mask))
-        return TRUE;
+    struct wined3d_box box;
 
-    return FALSE;
+    if (!rect)
+        return wined3d_resource_check_block_align(&surface->resource, NULL);
+
+    box.left = rect->left;
+    box.top = rect->top;
+    box.front = 0;
+    box.right = rect->right;
+    box.bottom = rect->bottom;
+    box.back = 1;
+    return wined3d_resource_check_block_align(&surface->resource, &box);
 }
 
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
@@ -1612,7 +1457,7 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     UINT update_w, update_h;
     UINT dst_w, dst_h;
     RECT r, dst_rect;
-    UINT src_pitch;
+    UINT src_row_pitch, src_slice_pitch;
     POINT p;
 
     TRACE("dst_surface %p, dst_point %s, src_surface %p, src_rect %s.\n",
@@ -1681,9 +1526,11 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
         return WINED3DERR_INVALIDCALL;
     }
 
-    /* Use wined3d_surface_blt() instead of uploading directly if we need conversion. */
+    /* Use surface_cpu_blt() instead of uploading directly if we need
+     * conversion. Avoid calling wined3d_surface_blt() since that goes
+     * through the CS. */
     if (dst_format->convert || wined3d_format_get_color_key_conversion(dst_surface->container, FALSE))
-        return wined3d_surface_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
+        return surface_cpu_blt(dst_surface, &dst_rect, src_surface, src_rect, 0, NULL, WINED3D_TEXF_POINT);
 
     context = context_acquire(dst_surface->resource.device, NULL);
     gl_info = context->gl_info;
@@ -1694,20 +1541,20 @@ HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const P
     if (update_w == dst_w && update_h == dst_h)
         wined3d_texture_prepare_texture(dst_surface->container, context, FALSE);
     else
-        surface_load_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_load_location(&dst_surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
     wined3d_texture_bind(dst_surface->container, context, FALSE);
 
-    surface_get_memory(src_surface, &data, src_surface->locations);
-    src_pitch = wined3d_surface_get_pitch(src_surface);
+    wined3d_resource_get_memory(&src_surface->resource, src_surface->resource.locations, &data);
+    wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
 
-    surface_upload_data(dst_surface, gl_info, src_format, src_rect, src_pitch, dst_point, FALSE, &data);
+    surface_upload_data(dst_surface, gl_info, src_format, src_rect, src_row_pitch, dst_point, FALSE, &data);
 
     context_invalidate_active_texture(context);
 
     context_release(context);
 
-    surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 
     return WINED3D_OK;
 }
@@ -1811,7 +1658,8 @@ GLenum surface_get_gl_buffer(const struct wined3d_surface *surface)
     return GL_BACK;
 }
 
-void surface_load(struct wined3d_surface *surface, BOOL srgb)
+/* Context activation is done by the caller. */
+void surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb)
 {
     DWORD location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
     BOOL ck_changed;
@@ -1835,14 +1683,14 @@ void surface_load(struct wined3d_surface *surface, BOOL srgb)
         /* To perform the color key conversion we need a sysmem copy of
          * the surface. Make sure we have it. */
 
-        surface_prepare_map_memory(surface);
-        surface_load_location(surface, surface->resource.map_binding);
-        surface_invalidate_location(surface, ~surface->resource.map_binding);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
         /* Switching color keying on / off may change the internal format. */
         if (ck_changed)
             wined3d_texture_force_reload(surface->container);
     }
-    else if (!(surface->locations & location))
+    else if (!(surface->resource.locations & location))
     {
         TRACE("Reloading because surface is dirty.\n");
     }
@@ -1852,7 +1700,7 @@ void surface_load(struct wined3d_surface *surface, BOOL srgb)
         return;
     }
 
-    surface_load_location(surface, location);
+    wined3d_resource_load_location(&surface->resource, context, location);
     surface_evict_sysmem(surface);
 }
 
@@ -1935,15 +1783,16 @@ ULONG CDECL wined3d_surface_decref(struct wined3d_surface *surface)
 
 void CDECL wined3d_surface_preload(struct wined3d_surface *surface)
 {
+    const struct wined3d_device *device = surface->resource.device;
     TRACE("surface %p.\n", surface);
 
-    if (!surface->resource.device->d3d_initialized)
+    if (!device->d3d_initialized)
     {
         ERR("D3D not initialized.\n");
         return;
     }
 
-    wined3d_texture_preload(surface->container);
+    wined3d_cs_emit_surface_preload(device->cs, surface);
 }
 
 void * CDECL wined3d_surface_get_parent(const struct wined3d_surface *surface)
@@ -2008,25 +1857,6 @@ HRESULT CDECL wined3d_surface_restore(struct wined3d_surface *surface)
     return WINED3D_OK;
 }
 
-DWORD CDECL wined3d_surface_get_pitch(const struct wined3d_surface *surface)
-{
-    unsigned int alignment;
-    DWORD pitch;
-
-    TRACE("surface %p.\n", surface);
-
-    if (surface->pitch)
-        return surface->pitch;
-
-    alignment = surface->resource.device->surface_alignment;
-    pitch = wined3d_format_calculate_pitch(surface->resource.format, surface->resource.width);
-    pitch = (pitch + alignment - 1) & ~(alignment - 1);
-
-    TRACE("Returning %u.\n", pitch);
-
-    return pitch;
-}
-
 HRESULT CDECL wined3d_surface_set_overlay_position(struct wined3d_surface *surface, LONG x, LONG y)
 {
     LONG w, h;
@@ -2170,13 +2000,14 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
     {
         DeleteDC(surface->hDC);
         DeleteObject(surface->dib.DIBsection);
-        surface->dib.bitmap_data = NULL;
+        surface->resource.bitmap_data = NULL;
         surface->flags &= ~SFLAG_DIBSECTION;
         create_dib = TRUE;
     }
 
-    surface->locations = 0;
+    surface->resource.locations = 0;
     wined3d_resource_free_sysmem(&surface->resource);
+    surface->resource.map_heap_memory = NULL;
 
     width = texture_resource->width;
     height = texture_resource->height;
@@ -2202,17 +2033,18 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
     else
         surface->flags &= ~SFLAG_NONPOW2;
 
-    if ((surface->user_memory = mem))
+    if ((surface->resource.user_memory = mem))
     {
         surface->resource.map_binding = WINED3D_LOCATION_USER_MEMORY;
         valid_location = WINED3D_LOCATION_USER_MEMORY;
     }
-    surface->pitch = pitch;
+    surface->resource.custom_row_pitch = pitch;
+    surface->resource.custom_slice_pitch = pitch * surface->resource.height;
     surface->resource.format = texture_resource->format;
     surface->resource.multisample_type = texture_resource->multisample_type;
     surface->resource.multisample_quality = texture_resource->multisample_quality;
-    if (surface->pitch)
-        surface->resource.size = height * surface->pitch;
+    if (surface->resource.custom_row_pitch)
+        surface->resource.size = height * surface->resource.custom_row_pitch;
     else
         surface->resource.size = wined3d_format_calculate_size(texture_resource->format,
                 texture_resource->device->surface_alignment, width, height, 1);
@@ -2237,11 +2069,11 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
 
     if (!valid_location)
     {
-        surface_prepare_system_memory(surface);
+        wined3d_resource_prepare_system_memory(&surface->resource);
         valid_location = WINED3D_LOCATION_SYSMEM;
     }
 
-    surface_validate_location(surface, valid_location);
+    wined3d_resource_validate_location(&surface->resource, valid_location);
 
     return WINED3D_OK;
 }
@@ -2447,11 +2279,14 @@ static inline const struct d3dfmt_converter_desc *find_converter(enum wined3d_fo
 
 static struct wined3d_texture *surface_convert_format(struct wined3d_surface *source, enum wined3d_format_id to_fmt)
 {
-    struct wined3d_map_desc src_map, dst_map;
+    void *dst_data = NULL, *src_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const struct d3dfmt_converter_desc *conv;
     struct wined3d_texture *ret = NULL;
     struct wined3d_resource_desc desc;
     struct wined3d_surface *dst;
+    struct wined3d_context *context = NULL;
+    struct wined3d_device *device = source->resource.device;
 
     conv = find_converter(source->resource.format->id, to_fmt);
     if (!conv)
@@ -2475,30 +2310,46 @@ static struct wined3d_texture *surface_convert_format(struct wined3d_surface *so
     }
     dst = surface_from_resource(wined3d_texture_get_sub_resource(ret, 0));
 
-    memset(&src_map, 0, sizeof(src_map));
-    memset(&dst_map, 0, sizeof(dst_map));
+    wined3d_resource_get_pitch(&source->resource, &src_row_pitch, &src_slice_pitch);
+    wined3d_resource_get_pitch(&ret->resource, &dst_row_pitch, &dst_slice_pitch);
 
-    if (FAILED(wined3d_surface_map(source, &src_map, NULL, WINED3D_MAP_READONLY)))
-    {
-        ERR("Failed to lock the source surface.\n");
-        wined3d_texture_decref(ret);
-        return NULL;
-    }
-    if (FAILED(wined3d_surface_map(dst, &dst_map, NULL, 0)))
-    {
-        ERR("Failed to lock the destination surface.\n");
-        wined3d_surface_unmap(source);
-        wined3d_texture_decref(ret);
-        return NULL;
-    }
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    wined3d_resource_load_location(&source->resource, context, source->resource.map_binding);
+    src_data = wined3d_resource_get_map_ptr(&source->resource, context, WINED3D_MAP_READONLY);
+    if (!src_data)
+        goto error;
 
-    conv->convert(src_map.data, dst_map.data, src_map.row_pitch, dst_map.row_pitch,
+    if (!wined3d_resource_prepare_map_memory(&dst->resource, context))
+        goto error;
+    dst_data = wined3d_resource_get_map_ptr(&dst->resource, context, 0);
+    if (!dst_data)
+        goto error;
+
+    conv->convert(src_data, dst_data, src_row_pitch, dst_row_pitch,
             source->resource.width, source->resource.height);
 
-    wined3d_surface_unmap(dst);
-    wined3d_surface_unmap(source);
+    wined3d_resource_release_map_ptr(&dst->resource, context);
+    wined3d_resource_release_map_ptr(&source->resource, context);
+
+    if (context)
+        context_release(context);
 
     return ret;
+
+error:
+    ERR("Surface conversion failed.\n");
+
+    if (src_data)
+        wined3d_resource_release_map_ptr(&source->resource, context);
+    if (dst_data)
+        wined3d_resource_release_map_ptr(&ret->resource, context);
+    if (ret)
+        wined3d_texture_decref(ret);
+    if (context)
+        context_release(context);
+    return NULL;
 }
 
 static HRESULT _Blt_ColorFill(BYTE *buf, unsigned int width, unsigned int height,
@@ -2566,37 +2417,23 @@ struct wined3d_surface * CDECL wined3d_surface_from_resource(struct wined3d_reso
 
 HRESULT CDECL wined3d_surface_unmap(struct wined3d_surface *surface)
 {
+    HRESULT hr;
     TRACE("surface %p.\n", surface);
 
-    if (!surface->resource.map_count)
-    {
-        WARN("Trying to unmap unmapped surface.\n");
-        return WINEDDERR_NOTLOCKED;
-    }
-    --surface->resource.map_count;
+    hr = wined3d_resource_unmap(&surface->resource);
+    if (FAILED(hr))
+        return hr;
 
-    surface->surface_ops->surface_unmap(surface);
+    memset(&surface->lockedRect, 0, sizeof(surface->lockedRect));
 
-    return WINED3D_OK;
+    return hr;
 }
 
 HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         struct wined3d_map_desc *map_desc, const RECT *rect, DWORD flags)
 {
+    struct wined3d_box box;
     const struct wined3d_format *format = surface->resource.format;
-    struct wined3d_device *device = surface->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    BYTE *base_memory;
-
-    TRACE("surface %p, map_desc %p, rect %s, flags %#x.\n",
-            surface, map_desc, wine_dbgstr_rect(rect), flags);
-
-    if (surface->resource.map_count)
-    {
-        WARN("Surface is already mapped.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
 
     if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && rect
             && !surface_check_block_align(surface, rect))
@@ -2608,11 +2445,6 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
             return WINED3DERR_INVALIDCALL;
     }
 
-    ++surface->resource.map_count;
-
-    if (!(surface->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
-        WARN("Trying to lock unlockable surface.\n");
-
     /* Performance optimization: Count how often a surface is mapped, if it is
      * mapped regularly do not throw away the system memory copy. This avoids
      * the need to download the surface from OpenGL all the time. The surface
@@ -2628,103 +2460,71 @@ HRESULT CDECL wined3d_surface_map(struct wined3d_surface *surface,
         }
     }
 
-    surface_prepare_map_memory(surface);
-    if (flags & WINED3D_MAP_DISCARD)
+    if (rect)
     {
-        TRACE("WINED3D_MAP_DISCARD flag passed, marking %s as up to date.\n",
-                wined3d_debug_location(surface->resource.map_binding));
-        surface_validate_location(surface, surface->resource.map_binding);
+        surface->lockedRect = *rect;
+
+        box.left = rect->left;
+        box.top = rect->top;
+        box.front = 0;
+        box.right = rect->right;
+        box.bottom = rect->bottom;
+        box.back = 1;
     }
     else
     {
-        if (surface->resource.usage & WINED3DUSAGE_DYNAMIC)
-            WARN_(d3d_perf)("Mapping a dynamic surface without WINED3D_MAP_DISCARD.\n");
-
-        surface_load_location(surface, surface->resource.map_binding);
+        surface->lockedRect.left = 0;
+        surface->lockedRect.top = 0;
+        surface->lockedRect.right = surface->resource.width;
+        surface->lockedRect.bottom = surface->resource.height;
     }
 
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-        surface_invalidate_location(surface, ~surface->resource.map_binding);
+    return wined3d_resource_map(&surface->resource, map_desc, rect ? &box : NULL, flags);
+}
+
+void wined3d_surface_getdc_cs(struct wined3d_surface *surface)
+{
+    struct wined3d_device *device = surface->resource.device;
+    struct wined3d_context *context = NULL;
+
+    if (device->d3d_initialized)
+        context = context_acquire(surface->resource.device, NULL);
 
-    switch (surface->resource.map_binding)
+    /* Create a DIB section if there isn't a dc yet. */
+    if (!surface->hDC)
     {
-        case WINED3D_LOCATION_SYSMEM:
-            base_memory = surface->resource.heap_memory;
-            break;
+        HRESULT hr = surface_create_dib_section(surface);
+        if (FAILED(hr))
+        {
+            if (context)
+                context_release(context);
+            return;
+        }
+        if (!(surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY
+                || surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
+                || surface->resource.buffer))
+            surface->resource.map_binding = WINED3D_LOCATION_DIB;
+    }
 
-        case WINED3D_LOCATION_USER_MEMORY:
-            base_memory = surface->user_memory;
-            break;
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_DIB);
+    wined3d_resource_invalidate_location(&surface->resource, ~WINED3D_LOCATION_DIB);
 
-        case WINED3D_LOCATION_DIB:
-            base_memory = surface->dib.bitmap_data;
-            break;
+    if (context)
+        context_release(context);
+}
 
-        case WINED3D_LOCATION_BUFFER:
-            context = context_acquire(device, NULL);
-            gl_info = context->gl_info;
+HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
+{
+    struct wined3d_device *device = surface->resource.device;
 
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, surface->pbo));
-            base_memory = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, GL_READ_WRITE_ARB));
-            GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-            checkGLcall("map PBO");
+    TRACE("surface %p, dc %p.\n", surface, dc);
 
-            context_release(context);
-            break;
-
-        default:
-            ERR("Unexpected map binding %s.\n", wined3d_debug_location(surface->resource.map_binding));
-            base_memory = NULL;
-    }
-
-    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
-        map_desc->row_pitch = surface->resource.width * format->byte_count;
-    else
-        map_desc->row_pitch = wined3d_surface_get_pitch(surface);
-    map_desc->slice_pitch = 0;
-
-    if (!rect)
-    {
-        map_desc->data = base_memory;
-        surface->lockedRect.left = 0;
-        surface->lockedRect.top = 0;
-        surface->lockedRect.right = surface->resource.width;
-        surface->lockedRect.bottom = surface->resource.height;
-    }
-    else
+    if (!(surface->resource.format->flags & WINED3DFMT_FLAG_GETDC))
     {
-        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
-        {
-            /* Compressed textures are block based, so calculate the offset of
-             * the block that contains the top-left pixel of the locked rectangle. */
-            map_desc->data = base_memory
-                    + ((rect->top / format->block_height) * map_desc->row_pitch)
-                    + ((rect->left / format->block_width) * format->block_byte_count);
-        }
-        else
-        {
-            map_desc->data = base_memory
-                    + (map_desc->row_pitch * rect->top)
-                    + (rect->left * format->byte_count);
-        }
-        surface->lockedRect.left = rect->left;
-        surface->lockedRect.top = rect->top;
-        surface->lockedRect.right = rect->right;
-        surface->lockedRect.bottom = rect->bottom;
+        WARN("Cannot use GetDC on a %s surface.\n", debug_d3dformat(surface->resource.format->id));
+        return WINED3DERR_INVALIDCALL;
     }
 
-    TRACE("Locked rect %s.\n", wine_dbgstr_rect(&surface->lockedRect));
-    TRACE("Returning memory %p, pitch %u.\n", map_desc->data, map_desc->row_pitch);
-
-    return WINED3D_OK;
-}
-
-HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
-{
-    HRESULT hr;
-
-    TRACE("surface %p, dc %p.\n", surface, dc);
-
     /* Give more detailed info for ddraw. */
     if (surface->flags & SFLAG_DCINUSE)
         return WINEDDERR_DCALREADYCREATED;
@@ -2733,33 +2533,38 @@ HRESULT CDECL wined3d_surface_getdc(struct wined3d_surface *surface, HDC *dc)
     if (surface->resource.map_count)
         return WINED3DERR_INVALIDCALL;
 
-    /* Create a DIB section if there isn't a dc yet. */
-    if (!surface->hDC)
-    {
-        if (surface->flags & SFLAG_CLIENT)
-        {
-            surface_load_location(surface, WINED3D_LOCATION_SYSMEM);
-            surface_release_client_storage(surface);
-        }
-        hr = surface_create_dib_section(surface);
-        if (FAILED(hr))
-            return WINED3DERR_INVALIDCALL;
-        if (!(surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY
-                || surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
-                || surface->pbo))
-            surface->resource.map_binding = WINED3D_LOCATION_DIB;
-    }
-
-    surface_load_location(surface, WINED3D_LOCATION_DIB);
-    surface_invalidate_location(surface, ~WINED3D_LOCATION_DIB);
-
     surface->flags |= SFLAG_DCINUSE;
     surface->resource.map_count++;
-
+    wined3d_cs_emit_getdc(device->cs, surface);
     *dc = surface->hDC;
     TRACE("Returning dc %p.\n", *dc);
 
-    return WINED3D_OK;
+    return *dc ? WINED3D_OK : WINED3DERR_INVALIDCALL;
+}
+
+void wined3d_surface_releasedc_cs(struct wined3d_surface *surface)
+{
+    if (surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY || (surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
+            && surface->resource.map_binding != WINED3D_LOCATION_DIB))
+    {
+        /* The game Salammbo modifies the surface contents without mapping the surface between
+         * a GetDC/ReleaseDC operation and flipping the surface. If the DIB remains the active
+         * copy and is copied to the screen, this update, which draws the mouse pointer, is lost.
+         * Do not only copy the DIB to the map location, but also make sure the map location is
+         * copied back to the DIB in the next getdc call.
+         *
+         * The same consideration applies to user memory surfaces. */
+        struct wined3d_device *device = surface->resource.device;
+        struct wined3d_context *context = NULL;
+
+        if (device->d3d_initialized)
+            context = context_acquire(device, NULL);
+
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_DIB);
+        if (context)
+            context_release(context);
+    }
 }
 
 HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
@@ -2779,38 +2584,41 @@ HRESULT CDECL wined3d_surface_releasedc(struct wined3d_surface *surface, HDC dc)
     surface->resource.map_count--;
     surface->flags &= ~SFLAG_DCINUSE;
 
-    if (surface->resource.map_binding == WINED3D_LOCATION_USER_MEMORY
-            || (surface->container->flags & WINED3D_TEXTURE_PIN_SYSMEM
-            && surface->resource.map_binding != WINED3D_LOCATION_DIB))
-    {
-        /* The game Salammbo modifies the surface contents without mapping the surface between
-         * a GetDC/ReleaseDC operation and flipping the surface. If the DIB remains the active
-         * copy and is copied to the screen, this update, which draws the mouse pointer, is lost.
-         * Do not only copy the DIB to the map location, but also make sure the map location is
-         * copied back to the DIB in the next getdc call.
-         *
-         * The same consideration applies to user memory surfaces. */
-        surface_load_location(surface, surface->resource.map_binding);
-        surface_invalidate_location(surface, WINED3D_LOCATION_DIB);
-    }
+    wined3d_cs_emit_releasedc(surface->resource.device->cs, surface);
 
     return WINED3D_OK;
 }
 
-static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_location)
+static void read_from_framebuffer(struct wined3d_surface *surface,
+        struct wined3d_context *old_ctx, DWORD dst_location)
 {
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    struct wined3d_surface *restore_rt;
     BYTE *mem;
     BYTE *row, *top, *bottom;
     int i;
     BOOL srcIsUpsideDown;
     struct wined3d_bo_address data;
 
-    surface_get_memory(surface, &data, dst_location);
+    wined3d_resource_get_memory(&surface->resource, dst_location, &data);
+
+    /* Context_release does not restore the original context in case of
+     * nested context_acquire calls. Only read_from_framebuffer and
+     * surface_blt_to_drawable use nested context_acquire calls. Manually
+     * restore the original context at the end of the function if needed. */
+    if (old_ctx->current_rt == surface)
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+    else
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, surface);
+    }
 
-    context = context_acquire(device, surface);
     context_apply_blit_state(context, device);
     gl_info = context->gl_info;
 
@@ -2860,7 +2668,9 @@ static void read_from_framebuffer(struct wined3d_surface *surface, DWORD dst_loc
     {
         /* glReadPixels returns the image upside down, and there is no way to prevent this.
          * Flip the lines in software. */
-        UINT pitch = wined3d_surface_get_pitch(surface);
+        UINT pitch, slice_pitch;
+
+        wined3d_resource_get_pitch(&surface->resource, &pitch, &slice_pitch);
 
         if (!(row = HeapAlloc(GetProcessHeap(), 0, pitch)))
             goto error;
@@ -2896,7 +2706,12 @@ error:
         checkGLcall("glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0)");
     }
 
-    context_release(context);
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
 }
 
 /* Read the framebuffer contents into a texture. Note that this function
@@ -2956,83 +2771,6 @@ void surface_prepare_rb(struct wined3d_surface *surface, const struct wined3d_gl
     }
 }
 
-void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back)
-{
-    if (front->container->level_count != 1 || front->container->layer_count != 1
-            || back->container->level_count != 1 || back->container->layer_count != 1)
-        ERR("Flip between surfaces %p and %p not supported.\n", front, back);
-
-    /* Flip the surface contents */
-    /* Flip the DC */
-    {
-        HDC tmp;
-        tmp = front->hDC;
-        front->hDC = back->hDC;
-        back->hDC = tmp;
-    }
-
-    /* Flip the DIBsection */
-    {
-        HBITMAP tmp = front->dib.DIBsection;
-        front->dib.DIBsection = back->dib.DIBsection;
-        back->dib.DIBsection = tmp;
-    }
-
-    /* Flip the surface data */
-    {
-        void* tmp;
-
-        tmp = front->dib.bitmap_data;
-        front->dib.bitmap_data = back->dib.bitmap_data;
-        back->dib.bitmap_data = tmp;
-
-        tmp = front->resource.heap_memory;
-        front->resource.heap_memory = back->resource.heap_memory;
-        back->resource.heap_memory = tmp;
-    }
-
-    /* Flip the PBO */
-    {
-        GLuint tmp_pbo = front->pbo;
-        front->pbo = back->pbo;
-        back->pbo = tmp_pbo;
-    }
-
-    /* Flip the opengl texture */
-    {
-        GLuint tmp;
-
-        tmp = back->container->texture_rgb.name;
-        back->container->texture_rgb.name = front->container->texture_rgb.name;
-        front->container->texture_rgb.name = tmp;
-
-        tmp = back->container->texture_srgb.name;
-        back->container->texture_srgb.name = front->container->texture_srgb.name;
-        front->container->texture_srgb.name = tmp;
-
-        tmp = back->rb_multisample;
-        back->rb_multisample = front->rb_multisample;
-        front->rb_multisample = tmp;
-
-        tmp = back->rb_resolved;
-        back->rb_resolved = front->rb_resolved;
-        front->rb_resolved = tmp;
-
-        resource_unload(&back->resource);
-        resource_unload(&front->resource);
-    }
-
-    {
-        DWORD tmp_flags = back->flags;
-        back->flags = front->flags;
-        front->flags = tmp_flags;
-
-        tmp_flags = back->locations;
-        back->locations = front->locations;
-        front->locations = tmp_flags;
-    }
-}
-
 /* Does a direct frame buffer -> texture copy. Stretching is done with single
  * pixel copy calls. */
 static void fb_copy_to_texture_direct(struct wined3d_surface *dst_surface, struct wined3d_surface *src_surface,
@@ -3139,8 +2877,8 @@ static void fb_copy_to_texture_direct(struct wined3d_surface *dst_surface, struc
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
-    surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
 /* Uses the hardware to stretch and flip the image */
@@ -3208,7 +2946,7 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glEnable(texture_target)");
 
         /* For now invalidate the texture copy of the back buffer. Drawable and sysmem copy are untouched */
-        src_surface->locations &= ~WINED3D_LOCATION_TEXTURE_RGB;
+        wined3d_resource_invalidate_location(&src_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
     }
 
     /* Make sure that the top pixel is always above the bottom pixel, and keep a separate upside down flag
@@ -3406,15 +3144,17 @@ static void fb_copy_to_texture_hwstretch(struct wined3d_surface *dst_surface, st
         checkGLcall("glDeleteTextures(1, &backup)");
     }
 
-    if (wined3d_settings.strict_draw_ordering)
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering)
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
     context_release(context);
 
     /* The texture is now most up to date - If the surface is a render target
      * and has a drawable, this path is never entered. */
-    surface_validate_location(dst_surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_invalidate_location(dst_surface, ~WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_validate_location(&dst_surface->resource, WINED3D_LOCATION_TEXTURE_RGB);
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~WINED3D_LOCATION_TEXTURE_RGB);
 }
 
 /* Front buffer coordinates are always full screen coordinates, but our GL
@@ -3445,24 +3185,40 @@ void surface_translate_drawable_coords(const struct wined3d_surface *surface, HW
     rect->bottom = drawable_height - rect->bottom;
 }
 
+/* Context activation is done by the caller. */
 static void surface_blt_to_drawable(const struct wined3d_device *device,
+        struct wined3d_context *old_ctx,
         enum wined3d_texture_filter_type filter, BOOL alpha_test,
         struct wined3d_surface *src_surface, const RECT *src_rect_in,
         struct wined3d_surface *dst_surface, const RECT *dst_rect_in)
 {
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
+    struct wined3d_surface *restore_rt;
     RECT src_rect, dst_rect;
 
     src_rect = *src_rect_in;
     dst_rect = *dst_rect_in;
 
-    context = context_acquire(device, dst_surface);
+    /* Context_release does not restore the original context in case of
+     * nested context_acquire calls. Only read_from_framebuffer and
+     * surface_blt_to_drawable use nested context_acquire calls. Manually
+     * restore the original context at the end of the function if needed. */
+    if (old_ctx->current_rt == dst_surface)
+    {
+        restore_rt = NULL;
+        context = old_ctx;
+    }
+    else
+    {
+        restore_rt = old_ctx->current_rt;
+        context = context_acquire(device, dst_surface);
+    }
     gl_info = context->gl_info;
 
     /* Make sure the surface is up-to-date. This should probably use
-     * surface_load_location() and worry about the destination surface too,
-     * unless we're overwriting it completely. */
+     * wined3d_resource_load_location() and worry about the destination
+     * surface too, unless we're overwriting it completely. */
     wined3d_texture_load(src_surface->container, context, FALSE);
 
     /* Activate the destination context, set it up for blitting */
@@ -3505,12 +3261,19 @@ static void surface_blt_to_drawable(const struct wined3d_device *device,
     /* Leave the opengl state valid for blitting */
     device->blitter->unset_shader(context->gl_info);
 
-    if (wined3d_settings.strict_draw_ordering
+    if (wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFinish();
+    else if (wined3d_settings.strict_draw_ordering
             || (dst_surface->container->swapchain
             && dst_surface->container->swapchain->front_buffer == dst_surface->container))
         gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
 
-    context_release(context);
+    if (restore_rt)
+    {
+        context_release(context);
+        context = context_acquire(device, restore_rt);
+        context_release(context);
+    }
 }
 
 HRESULT surface_color_fill(struct wined3d_surface *s, const RECT *rect, const struct wined3d_color *color)
@@ -3534,9 +3297,9 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
         enum wined3d_texture_filter_type filter)
 {
     struct wined3d_device *device = dst_surface->resource.device;
-    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->fb.render_targets[0]);
     const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
+    const struct wined3d_surface *rt = wined3d_rendertarget_view_get_surface(device->state.fb.render_targets[0]);
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, blt_fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
@@ -3661,6 +3424,7 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
         /* Blit from offscreen surface to render target */
         struct wined3d_color_key old_blt_key = src_surface->container->src_blt_color_key;
         DWORD old_color_key_flags = src_surface->container->color_key_flags;
+        struct wined3d_context *context;
 
         TRACE("Blt from surface %p to rendertarget %p\n", src_surface, dst_surface);
 
@@ -3694,16 +3458,18 @@ static HRESULT surface_blt_special(struct wined3d_surface *dst_surface, const RE
             wined3d_texture_set_color_key(src_surface->container, WINEDDSD_CKSRCBLT, NULL);
         }
 
-        surface_blt_to_drawable(device, filter,
+        context = context_acquire(device, dst_surface);
+        surface_blt_to_drawable(device, context, filter,
                 flags & (WINEDDBLT_KEYSRC | WINEDDBLT_KEYSRCOVERRIDE | WINEDDBLT_ALPHATEST),
                 src_surface, src_rect, dst_surface, dst_rect);
+        context_release(context);
 
         /* Restore the color key parameters */
         wined3d_texture_set_color_key(src_surface->container, WINEDDSD_CKSRCBLT,
                 (old_color_key_flags & WINEDDSD_CKSRCBLT) ? &old_blt_key : NULL);
 
-        surface_validate_location(dst_surface, dst_surface->container->resource.draw_binding);
-        surface_invalidate_location(dst_surface, ~dst_surface->container->resource.draw_binding);
+        wined3d_resource_validate_location(&dst_surface->resource, dst_surface->container->resource.draw_binding);
+        wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->container->resource.draw_binding);
 
         return WINED3D_OK;
     }
@@ -3778,13 +3544,14 @@ void surface_modify_ds_location(struct wined3d_surface *surface,
 {
     TRACE("surface %p, new location %#x, w %u, h %u.\n", surface, location, w, h);
 
-    if (((surface->locations & WINED3D_LOCATION_TEXTURE_RGB) && !(location & WINED3D_LOCATION_TEXTURE_RGB))
-            || (!(surface->locations & WINED3D_LOCATION_TEXTURE_RGB) && (location & WINED3D_LOCATION_TEXTURE_RGB)))
+    if (((surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB) && !(location & WINED3D_LOCATION_TEXTURE_RGB))
+            || (!(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
+            && (location & WINED3D_LOCATION_TEXTURE_RGB)))
         wined3d_texture_set_dirty(surface->container);
 
     surface->ds_current_size.cx = w;
     surface->ds_current_size.cy = h;
-    surface->locations = location;
+    surface->resource.locations = location;
 }
 
 /* Context activation is done by the caller. */
@@ -3799,7 +3566,7 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
     /* TODO: Make this work for modes other than FBO */
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO) return;
 
-    if (!(surface->locations & location))
+    if (!(surface->resource.locations & location))
     {
         w = surface->ds_current_size.cx;
         h = surface->ds_current_size.cy;
@@ -3825,7 +3592,7 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         return;
     }
 
-    if (surface->locations & WINED3D_LOCATION_DISCARDED)
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
     {
         TRACE("Surface was discarded, no need copy data.\n");
         switch (location)
@@ -3842,17 +3609,17 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
             default:
                 FIXME("Unhandled location %#x\n", location);
         }
-        surface->locations &= ~WINED3D_LOCATION_DISCARDED;
-        surface->locations |= location;
+        surface->resource.locations &= ~WINED3D_LOCATION_DISCARDED;
+        surface->resource.locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
     }
 
-    if (!surface->locations)
+    if (!surface->resource.locations)
     {
         FIXME("No up to date depth stencil location.\n");
-        surface->locations |= location;
+        surface->resource.locations |= location;
         surface->ds_current_size.cx = surface->resource.width;
         surface->ds_current_size.cy = surface->resource.height;
         return;
@@ -3917,7 +3684,9 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else if (location == WINED3D_LOCATION_DRAWABLE)
@@ -3933,7 +3702,9 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
 
         context_invalidate_state(context, STATE_FRAMEBUFFER);
 
-        if (wined3d_settings.strict_draw_ordering)
+        if (wined3d_settings.cs_multithreaded)
+            gl_info->gl_ops.gl.p_glFinish();
+        else if (wined3d_settings.strict_draw_ordering)
             gl_info->gl_ops.gl.p_glFlush(); /* Flush to ensure ordering across contexts. */
     }
     else
@@ -3941,134 +3712,52 @@ void surface_load_ds_location(struct wined3d_surface *surface, struct wined3d_co
         ERR("Invalid location (%#x) specified.\n", location);
     }
 
-    surface->locations |= location;
+    surface->resource.locations |= location;
     surface->ds_current_size.cx = surface->resource.width;
     surface->ds_current_size.cy = surface->resource.height;
 }
 
-void surface_validate_location(struct wined3d_surface *surface, DWORD location)
-{
-    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
-
-    surface->locations |= location;
-}
-
-void surface_invalidate_location(struct wined3d_surface *surface, DWORD location)
-{
-    TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
-
-    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
-        wined3d_texture_set_dirty(surface->container);
-    surface->locations &= ~location;
-
-    if (!surface->locations)
-        ERR("Surface %p does not have any up to date location.\n", surface);
-}
-
-static DWORD resource_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_SYSMEM:
-        case WINED3D_LOCATION_USER_MEMORY:
-        case WINED3D_LOCATION_DIB:
-        case WINED3D_LOCATION_BUFFER:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_DRAWABLE:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_RB_MULTISAMPLE:
-        case WINED3D_LOCATION_RB_RESOLVED:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
-}
-
-static void surface_copy_simple_location(struct wined3d_surface *surface, DWORD location)
-{
-    struct wined3d_device *device = surface->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    struct wined3d_bo_address dst, src;
-    UINT size = surface->resource.size;
-
-    surface_get_memory(surface, &dst, location);
-    surface_get_memory(surface, &src, surface->locations);
-
-    if (dst.buffer_object)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, dst.buffer_object));
-        GL_EXTCALL(glBufferSubDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0, size, src.addr));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Upload PBO");
-        context_release(context);
-        return;
-    }
-    if (src.buffer_object)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, src.buffer_object));
-        GL_EXTCALL(glGetBufferSubDataARB(GL_PIXEL_PACK_BUFFER_ARB, 0, size, dst.addr));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_PACK_BUFFER_ARB, 0));
-        checkGLcall("Download PBO");
-        context_release(context);
-        return;
-    }
-    memcpy(dst.addr, src.addr, size);
-}
-
+/* Context activation is done by the caller. */
 static void surface_load_sysmem(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, DWORD dst_location)
+        struct wined3d_context *context, DWORD dst_location)
 {
-    if (surface->locations & surface_simple_locations)
-    {
-        surface_copy_simple_location(surface, dst_location);
-        return;
-    }
+    const struct wined3d_gl_info *gl_info = context->gl_info;
 
-    if (surface->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
-        surface_load_location(surface, WINED3D_LOCATION_TEXTURE_RGB);
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED))
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
 
     /* Download the surface to system memory. */
-    if (surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
     {
-        struct wined3d_device *device = surface->resource.device;
-        struct wined3d_context *context;
-
-        /* TODO: Use already acquired context when possible. */
-        context = context_acquire(device, NULL);
-
         wined3d_texture_bind_and_dirtify(surface->container, context,
-                !(surface->locations & WINED3D_LOCATION_TEXTURE_RGB));
+                !(surface->resource.locations & WINED3D_LOCATION_TEXTURE_RGB));
         surface_download_data(surface, gl_info, dst_location);
 
-        context_release(context);
-
         return;
     }
 
-    if (surface->locations & WINED3D_LOCATION_DRAWABLE)
+    if (surface->resource.locations & WINED3D_LOCATION_DRAWABLE)
     {
-        read_from_framebuffer(surface, dst_location);
+        read_from_framebuffer(surface, context, dst_location);
         return;
     }
 
     FIXME("Can't load surface %p with location flags %s into sysmem.\n",
-            surface, wined3d_debug_location(surface->locations));
+            surface, wined3d_debug_location(surface->resource.locations));
 }
 
+/* Context activation is done by the caller. */
 static HRESULT surface_load_drawable(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info)
+        struct wined3d_context *context)
 {
     RECT r;
 
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        return WINED3D_OK;
+    }
+
     if (wined3d_settings.offscreen_rendering_mode == ORM_FBO
             && wined3d_resource_is_offscreen(&surface->container->resource))
     {
@@ -4077,64 +3766,74 @@ static HRESULT surface_load_drawable(struct wined3d_surface *surface,
     }
 
     surface_get_rect(surface, NULL, &r);
-    surface_load_location(surface, WINED3D_LOCATION_TEXTURE_RGB);
-    surface_blt_to_drawable(surface->resource.device,
+    wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+    surface_blt_to_drawable(surface->resource.device, context,
             WINED3D_TEXF_POINT, FALSE, surface, &r, surface, &r);
 
     return WINED3D_OK;
 }
 
 static HRESULT surface_load_texture(struct wined3d_surface *surface,
-        const struct wined3d_gl_info *gl_info, BOOL srgb)
+        struct wined3d_context *context, BOOL srgb)
 {
+    const struct wined3d_gl_info *gl_info = context->gl_info;
     RECT src_rect = {0, 0, surface->resource.width, surface->resource.height};
     struct wined3d_device *device = surface->resource.device;
     const struct wined3d_color_key_conversion *conversion;
     struct wined3d_texture *texture = surface->container;
-    struct wined3d_context *context;
-    UINT width, src_pitch, dst_pitch;
+    UINT width, src_row_pitch, src_slice_pitch, dst_pitch;
     struct wined3d_bo_address data;
     struct wined3d_format format;
     POINT dst_point = {0, 0};
     BYTE *mem = NULL;
+    const DWORD simple_locations =
+            WINED3D_LOCATION_SYSMEM | WINED3D_LOCATION_USER_MEMORY
+            | WINED3D_LOCATION_DIB | WINED3D_LOCATION_BUFFER;
+
+    if (surface->resource.locations & WINED3D_LOCATION_DISCARDED)
+    {
+        TRACE("Surface was discarded, nothing to do.\n");
+        wined3d_texture_prepare_texture(texture, context, srgb);
+        return WINED3D_OK;
+    }
 
     if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
             && wined3d_resource_is_offscreen(&texture->resource)
-            && (surface->locations & WINED3D_LOCATION_DRAWABLE))
+            && (surface->resource.locations & WINED3D_LOCATION_DRAWABLE))
     {
         surface_load_fb_texture(surface, srgb);
 
         return WINED3D_OK;
     }
 
-    if (surface->locations & (WINED3D_LOCATION_TEXTURE_SRGB | WINED3D_LOCATION_TEXTURE_RGB)
+    if (surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB | WINED3D_LOCATION_TEXTURE_RGB)
             && (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB)
             && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
     {
         if (srgb)
-            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_RGB,
+            surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_RGB,
                     &src_rect, surface, WINED3D_LOCATION_TEXTURE_SRGB, &src_rect);
         else
-            surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_SRGB,
+            surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, WINED3D_LOCATION_TEXTURE_SRGB,
                     &src_rect, surface, WINED3D_LOCATION_TEXTURE_RGB, &src_rect);
 
         return WINED3D_OK;
     }
 
-    if (surface->locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED)
+    if (surface->resource.locations & (WINED3D_LOCATION_RB_MULTISAMPLE | WINED3D_LOCATION_RB_RESOLVED)
             && (!srgb || (surface->resource.format->flags & WINED3DFMT_FLAG_FBO_ATTACHABLE_SRGB))
             && fbo_blit_supported(gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format,
                 NULL, surface->resource.usage, surface->resource.pool, surface->resource.format))
     {
-        DWORD src_location = surface->locations & WINED3D_LOCATION_RB_RESOLVED ?
+        DWORD src_location = surface->resource.locations & WINED3D_LOCATION_RB_RESOLVED ?
                 WINED3D_LOCATION_RB_RESOLVED : WINED3D_LOCATION_RB_MULTISAMPLE;
         DWORD dst_location = srgb ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB;
         RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
-        surface_blt_fbo(device, WINED3D_TEXF_POINT, surface, src_location,
+        surface_blt_fbo(device, context, WINED3D_TEXF_POINT, surface, src_location,
                 &rect, surface, dst_location, &rect);
 
         return WINED3D_OK;
@@ -4144,38 +3843,35 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
 
     if (srgb)
     {
-        if ((surface->locations & (WINED3D_LOCATION_TEXTURE_RGB | surface->resource.map_binding))
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | surface->resource.map_binding))
                 == WINED3D_LOCATION_TEXTURE_RGB)
         {
             /* Performance warning... */
             FIXME("Downloading RGB surface %p to reload it as sRGB.\n", surface);
-            surface_prepare_map_memory(surface);
-            surface_load_location(surface, surface->resource.map_binding);
+            wined3d_resource_prepare_map_memory(&surface->resource, context);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
     else
     {
-        if ((surface->locations & (WINED3D_LOCATION_TEXTURE_SRGB | surface->resource.map_binding))
+        if ((surface->resource.locations & (WINED3D_LOCATION_TEXTURE_SRGB | surface->resource.map_binding))
                 == WINED3D_LOCATION_TEXTURE_SRGB)
         {
             /* Performance warning... */
             FIXME("Downloading sRGB surface %p to reload it as RGB.\n", surface);
-            surface_prepare_map_memory(surface);
-            surface_load_location(surface, surface->resource.map_binding);
+            wined3d_resource_prepare_map_memory(&surface->resource, context);
+            wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
         }
     }
 
-    if (!(surface->locations & surface_simple_locations))
+    if (!(surface->resource.locations & simple_locations))
     {
         WARN("Trying to load a texture from sysmem, but no simple location is valid.\n");
         /* Lets hope we get it from somewhere... */
-        surface_prepare_system_memory(surface);
-        surface_load_location(surface, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_prepare_system_memory(&surface->resource);
+        wined3d_resource_load_location(&surface->resource, context, WINED3D_LOCATION_SYSMEM);
     }
 
-    /* TODO: Use already acquired context when possible. */
-    context = context_acquire(device, NULL);
-
     wined3d_texture_prepare_texture(texture, context, srgb);
     wined3d_texture_bind_and_dirtify(texture, context, srgb);
 
@@ -4187,7 +3883,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     else surface->flags &= ~SFLAG_GLCKEY;
 
     width = surface->resource.width;
-    src_pitch = wined3d_surface_get_pitch(surface);
+    wined3d_resource_get_pitch(&surface->resource, &src_row_pitch, &src_slice_pitch);
 
     format = *texture->resource.format;
     if ((conversion = wined3d_format_get_color_key_conversion(texture, TRUE)))
@@ -4196,7 +3892,7 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
     /* Don't use PBOs for converted surfaces. During PBO conversion we look at
      * WINED3D_TEXTURE_CONVERTED but it isn't set (yet) in all cases it is
      * getting called. */
-    if ((format.convert || conversion) && surface->pbo)
+    if ((format.convert || conversion) && surface->resource.buffer)
     {
         TRACE("Removing the pbo attached to surface %p.\n", surface);
 
@@ -4205,12 +3901,13 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         else
             surface->resource.map_binding = WINED3D_LOCATION_SYSMEM;
 
-        surface_prepare_map_memory(surface);
-        surface_load_location(surface, surface->resource.map_binding);
-        surface_remove_pbo(surface, gl_info);
+        wined3d_resource_prepare_map_memory(&surface->resource, context);
+        wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+        wined3d_resource_free_bo(&surface->resource);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_BUFFER);
     }
 
-    surface_get_memory(surface, &data, surface->locations);
+    wined3d_resource_get_memory(&surface->resource, surface->resource.locations, &data);
     if (format.convert)
     {
         /* This code is entered for texture formats which need a fixup. */
@@ -4226,9 +3923,9 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
             context_release(context);
             return E_OUTOFMEMORY;
         }
-        format.convert(data.addr, mem, src_pitch, src_pitch * height,
+        format.convert(data.addr, mem, src_row_pitch, src_row_pitch * height,
                 dst_pitch, dst_pitch * height, width, height, 1);
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
     else if (conversion)
@@ -4248,37 +3945,37 @@ static HRESULT surface_load_texture(struct wined3d_surface *surface,
         }
         if (texture->swapchain && texture->swapchain->palette)
             palette = texture->swapchain->palette;
-        conversion->convert(data.addr, src_pitch, mem, dst_pitch,
+        conversion->convert(data.addr, src_row_pitch, mem, dst_pitch,
                 width, height, palette, &texture->src_blt_color_key);
-        src_pitch = dst_pitch;
+        src_row_pitch = dst_pitch;
         data.addr = mem;
     }
 
-    surface_upload_data(surface, gl_info, &format, &src_rect, src_pitch, &dst_point, srgb, &data);
-
-    context_release(context);
+    surface_upload_data(surface, gl_info, &format, &src_rect, src_row_pitch, &dst_point, srgb, &data);
 
     HeapFree(GetProcessHeap(), 0, mem);
 
     return WINED3D_OK;
 }
 
-static void surface_multisample_resolve(struct wined3d_surface *surface)
+/* Context activation is done by the caller. */
+static void surface_multisample_resolve(struct wined3d_surface *surface, struct wined3d_context *context)
 {
     RECT rect = {0, 0, surface->resource.width, surface->resource.height};
 
-    if (!(surface->locations & WINED3D_LOCATION_RB_MULTISAMPLE))
+    if (!(surface->resource.locations & WINED3D_LOCATION_RB_MULTISAMPLE))
         ERR("Trying to resolve multisampled surface %p, but location WINED3D_LOCATION_RB_MULTISAMPLE not current.\n",
                 surface);
 
-    surface_blt_fbo(surface->resource.device, WINED3D_TEXF_POINT,
+    surface_blt_fbo(surface->resource.device, context, WINED3D_TEXF_POINT,
             surface, WINED3D_LOCATION_RB_MULTISAMPLE, &rect, surface, WINED3D_LOCATION_RB_RESOLVED, &rect);
 }
 
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
+/* Context activation is done by the caller. */
+static void wined3d_surface_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
 {
-    struct wined3d_device *device = surface->resource.device;
-    const struct wined3d_gl_info *gl_info = &device->adapter->gl_info;
+    struct wined3d_surface *surface = surface_from_resource(resource);
     HRESULT hr;
 
     TRACE("surface %p, location %s.\n", surface, wined3d_debug_location(location));
@@ -4286,46 +3983,30 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
     if (surface->resource.usage & WINED3DUSAGE_DEPTHSTENCIL)
     {
         if (location == WINED3D_LOCATION_TEXTURE_RGB
-                && surface->locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
+                && surface->resource.locations & (WINED3D_LOCATION_DRAWABLE | WINED3D_LOCATION_DISCARDED))
         {
-            struct wined3d_context *context = context_acquire(device, NULL);
             surface_load_ds_location(surface, context, location);
-            context_release(context);
-            return WINED3D_OK;
+            return;
         }
-        else if (location & surface->locations
+        else if (location & surface->resource.locations
                 && surface->container->resource.draw_binding != WINED3D_LOCATION_DRAWABLE)
         {
             /* Already up to date, nothing to do. */
-            return WINED3D_OK;
+            return;
         }
         else
         {
             FIXME("Unimplemented copy from %s to %s for depth/stencil buffers.\n",
-                    wined3d_debug_location(surface->locations), wined3d_debug_location(location));
-            return WINED3DERR_INVALIDCALL;
+                    wined3d_debug_location(surface->resource.locations), wined3d_debug_location(location));
+            return;
         }
     }
 
-    if (surface->locations & location)
-    {
-        TRACE("Location already up to date.\n");
-        return WINED3D_OK;
-    }
-
-    if (WARN_ON(d3d_surface))
-    {
-        DWORD required_access = resource_access_from_location(location);
-        if ((surface->resource.access_flags & required_access) != required_access)
-            WARN("Operation requires %#x access, but surface only has %#x.\n",
-                    required_access, surface->resource.access_flags);
-    }
-
-    if (!surface->locations)
+    if (!surface->resource.locations)
     {
         ERR("Surface %p does not have any up to date location.\n", surface);
         surface->flags |= SFLAG_LOST;
-        return WINED3DERR_DEVICELOST;
+        return;
     }
 
     switch (location)
@@ -4334,22 +4015,23 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
         case WINED3D_LOCATION_USER_MEMORY:
         case WINED3D_LOCATION_SYSMEM:
         case WINED3D_LOCATION_BUFFER:
-            surface_load_sysmem(surface, gl_info, location);
+            surface_load_sysmem(surface, context, location);
             break;
 
         case WINED3D_LOCATION_DRAWABLE:
-            if (FAILED(hr = surface_load_drawable(surface, gl_info)))
-                return hr;
+            if (FAILED(hr = surface_load_drawable(surface, context)))
+                return;
             break;
 
         case WINED3D_LOCATION_RB_RESOLVED:
-            surface_multisample_resolve(surface);
+            surface_multisample_resolve(surface, context);
             break;
 
         case WINED3D_LOCATION_TEXTURE_RGB:
         case WINED3D_LOCATION_TEXTURE_SRGB:
-            if (FAILED(hr = surface_load_texture(surface, gl_info, location == WINED3D_LOCATION_TEXTURE_SRGB)))
-                return hr;
+            if (FAILED(hr = surface_load_texture(surface, context,
+                    location == WINED3D_LOCATION_TEXTURE_SRGB)))
+                return;
             break;
 
         default:
@@ -4357,12 +4039,12 @@ HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location)
             break;
     }
 
-    surface_validate_location(surface, location);
+    wined3d_resource_validate_location(&surface->resource, location);
 
-    if (location != WINED3D_LOCATION_SYSMEM && (surface->locations & WINED3D_LOCATION_SYSMEM))
+    if (location != WINED3D_LOCATION_SYSMEM && (surface->resource.locations & WINED3D_LOCATION_SYSMEM))
         surface_evict_sysmem(surface);
 
-    return WINED3D_OK;
+    return;
 }
 
 static HRESULT ffp_blit_alloc(struct wined3d_device *device) { return WINED3D_OK; }
@@ -4456,19 +4138,26 @@ static HRESULT ffp_blit_color_fill(struct wined3d_device *device, struct wined3d
         const RECT *dst_rect, const struct wined3d_color *color)
 {
     const RECT draw_rect = {0, 0, dst_surface->resource.width, dst_surface->resource.height};
-    struct wined3d_rendertarget_view *view;
-    struct wined3d_fb_state fb = {&view, NULL};
-    HRESULT hr;
-
-    if (FAILED(hr = wined3d_rendertarget_view_create_from_surface(dst_surface,
-            NULL, &wined3d_null_parent_ops, &view)))
-    {
-        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
-        return hr;
-    }
+    struct wined3d_rendertarget_view view, *view_ptr = &view;
+    struct wined3d_fb_state fb = {&view_ptr, NULL, 1};
+    struct wined3d_texture *texture = dst_surface->container;
+
+    /* Can't incref / decref the resource here. This is executed inside the worker
+     * thread. Playing with the refcount here makes the worker thread visible to
+     * the client lib. Problems occur when the worker thread happens to hold the
+     * last reference and the resource destruction callbacks are called from the
+     * wrong thread. */
+    view.resource = &texture->resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = dst_surface->resource.format;
+    view.buffer_offset = 0;
+    view.width = dst_surface->resource.width;
+    view.height = dst_surface->resource.height;
+    view.depth = 1;
+    view.sub_resource_idx = dst_surface->texture_layer * texture->level_count + dst_surface->texture_level;
 
     device_clear_render_targets(device, 1, &fb, 1, dst_rect, &draw_rect, WINED3DCLEAR_TARGET, color, 0.0f, 0);
-    wined3d_rendertarget_view_decref(view);
 
     return WINED3D_OK;
 }
@@ -4477,18 +4166,21 @@ static HRESULT ffp_blit_depth_fill(struct wined3d_device *device, struct wined3d
         const RECT *dst_rect, float depth)
 {
     const RECT draw_rect = {0, 0, dst_surface->resource.width, dst_surface->resource.height};
-    struct wined3d_fb_state fb = {NULL, NULL};
-    HRESULT hr;
-
-    if (FAILED(hr = wined3d_rendertarget_view_create_from_surface(dst_surface,
-            NULL, &wined3d_null_parent_ops, &fb.depth_stencil)))
-    {
-        ERR("Failed to create rendertarget view, hr %#x.\n", hr);
-        return hr;
-    }
+    struct wined3d_rendertarget_view view;
+    struct wined3d_fb_state fb = {NULL, &view};
+    struct wined3d_texture *texture = dst_surface->container;
+
+    view.resource = &dst_surface->container->resource;
+    view.parent = NULL;
+    view.parent_ops = &wined3d_null_parent_ops;
+    view.format = dst_surface->resource.format;
+    view.buffer_offset = 0;
+    view.width = dst_surface->resource.width;
+    view.height = dst_surface->resource.height;
+    view.depth = 1;
+    view.sub_resource_idx = dst_surface->texture_layer * texture->level_count + dst_surface->texture_level;
 
     device_clear_render_targets(device, 0, &fb, 1, dst_rect, &draw_rect, WINED3DCLEAR_ZBUFFER, 0, depth, 0);
-    wined3d_rendertarget_view_decref(fb.depth_stencil);
 
     return WINED3D_OK;
 }
@@ -4646,21 +4338,36 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     int bpp, srcheight, srcwidth, dstheight, dstwidth, width;
     const struct wined3d_format *src_format, *dst_format;
     struct wined3d_texture *src_texture = NULL;
-    struct wined3d_map_desc dst_map, src_map;
+    void *src_data = NULL, *dst_data = NULL;
+    UINT src_row_pitch, src_slice_pitch, dst_row_pitch, dst_slice_pitch;
     const BYTE *sbase = NULL;
     HRESULT hr = WINED3D_OK;
     const BYTE *sbuf;
     BYTE *dbuf;
     int x, y;
+    struct wined3d_device *device = dst_surface->resource.device;
+    struct wined3d_context *context = NULL;
 
     TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
             dst_surface, wine_dbgstr_rect(dst_rect), src_surface, wine_dbgstr_rect(src_rect),
             flags, fx, debug_d3dtexturefiltertype(filter));
 
+    if (device->d3d_initialized)
+        context = context_acquire(device, NULL);
+
+    if (!wined3d_resource_prepare_map_memory(&dst_surface->resource, context))
+    {
+        hr = E_OUTOFMEMORY;
+        goto error;
+    }
+    wined3d_resource_load_location(&dst_surface->resource, context, dst_surface->resource.map_binding);
+
     if (src_surface == dst_surface)
     {
-        wined3d_surface_map(dst_surface, &dst_map, NULL, 0);
-        src_map = dst_map;
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        src_data = dst_data;
+        src_row_pitch = dst_row_pitch;
         src_format = dst_surface->resource.format;
         dst_format = src_format;
     }
@@ -4669,6 +4376,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         dst_format = dst_surface->resource.format;
         if (src_surface)
         {
+            if (!wined3d_resource_prepare_map_memory(&src_surface->resource, context))
+            {
+                hr = E_OUTOFMEMORY;
+                goto error;
+            }
+
             if (dst_surface->resource.format->id != src_surface->resource.format->id)
             {
                 if (!(src_texture = surface_convert_format(src_surface, dst_format->id)))
@@ -4679,7 +4392,9 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                 }
                 src_surface = surface_from_resource(wined3d_texture_get_sub_resource(src_texture, 0));
             }
-            wined3d_surface_map(src_surface, &src_map, NULL, WINED3D_MAP_READONLY);
+            wined3d_resource_load_location(&src_surface->resource, context, src_surface->resource.map_binding);
+            wined3d_resource_get_pitch(&src_surface->resource, &src_row_pitch, &src_slice_pitch);
+            src_data = wined3d_resource_get_map_ptr(&src_surface->resource, context, 0);
             src_format = src_surface->resource.format;
         }
         else
@@ -4687,7 +4402,8 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
             src_format = dst_format;
         }
 
-        wined3d_surface_map(dst_surface, &dst_map, dst_rect, 0);
+        wined3d_resource_get_pitch(&dst_surface->resource, &dst_row_pitch, &dst_slice_pitch);
+        dst_data = wined3d_resource_get_map_ptr(&dst_surface->resource, context, 0);
     }
 
     bpp = dst_surface->resource.format->byte_count;
@@ -4698,15 +4414,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     width = (dst_rect->right - dst_rect->left) * bpp;
 
     if (src_surface)
-        sbase = (BYTE *)src_map.data
-                + ((src_rect->top / src_format->block_height) * src_map.row_pitch)
+        sbase = (BYTE *)src_data
+                + ((src_rect->top / src_format->block_height) * src_row_pitch)
                 + ((src_rect->left / src_format->block_width) * src_format->block_byte_count);
-    if (src_surface != dst_surface)
-        dbuf = dst_map.data;
-    else
-        dbuf = (BYTE *)dst_map.data
-                + ((dst_rect->top / dst_format->block_height) * dst_map.row_pitch)
-                + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
+    dbuf = (BYTE *)dst_data
+            + ((dst_rect->top / dst_format->block_height) * dst_row_pitch)
+            + ((dst_rect->left / dst_format->block_width) * dst_format->block_byte_count);
 
     if (src_format->flags & dst_format->flags & WINED3DFMT_FLAG_BLOCKS)
     {
@@ -4741,7 +4454,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         }
 
         hr = surface_cpu_blt_compressed(sbase, dbuf,
-                src_map.row_pitch, dst_map.row_pitch, dstwidth, dstheight,
+                src_row_pitch, dst_row_pitch, dstwidth, dstheight,
                 src_format, flags, fx);
         goto release;
     }
@@ -4749,7 +4462,7 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
     /* First, all the 'source-less' blits */
     if (flags & WINEDDBLT_COLORFILL)
     {
-        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, fx->u5.dwFillColor);
+        hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, fx->u5.dwFillColor);
         flags &= ~WINEDDBLT_COLORFILL;
     }
 
@@ -4763,12 +4476,12 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
         switch (fx->dwROP)
         {
             case BLACKNESS:
-                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, 0);
+                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, 0);
                 break;
             case 0xaa0029: /* No-op */
                 break;
             case WHITENESS:
-                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_map.row_pitch, ~0U);
+                hr = _Blt_ColorFill(dbuf, dstwidth, dstheight, bpp, dst_row_pitch, ~0U);
                 break;
             case SRCCOPY: /* Well, we do that below? */
                 break;
@@ -4819,19 +4532,19 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         for (y = 0; y < dstheight; ++y)
                         {
                             memcpy(dbuf, sbuf, width);
-                            sbuf += src_map.row_pitch;
-                            dbuf += dst_map.row_pitch;
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
                         }
                     }
                     else if (dst_rect->top > src_rect->top)
                     {
                         /* Copy from bottom upwards. */
-                        sbuf += src_map.row_pitch * dstheight;
-                        dbuf += dst_map.row_pitch * dstheight;
+                        sbuf += src_row_pitch * dstheight;
+                        dbuf += dst_row_pitch * dstheight;
                         for (y = 0; y < dstheight; ++y)
                         {
-                            sbuf -= src_map.row_pitch;
-                            dbuf -= dst_map.row_pitch;
+                            sbuf -= src_row_pitch;
+                            dbuf -= dst_row_pitch;
                             memcpy(dbuf, sbuf, width);
                         }
                     }
@@ -4841,8 +4554,8 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                         for (y = 0; y < dstheight; ++y)
                         {
                             memmove(dbuf, sbuf, width);
-                            sbuf += src_map.row_pitch;
-                            dbuf += dst_map.row_pitch;
+                            sbuf += src_row_pitch;
+                            dbuf += dst_row_pitch;
                         }
                     }
                 }
@@ -4851,9 +4564,9 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                     /* Stretching in y direction only. */
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
-                        sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
                         memcpy(dbuf, sbuf, width);
-                        dbuf += dst_map.row_pitch;
+                        dbuf += dst_row_pitch;
                     }
                 }
             }
@@ -4863,13 +4576,13 @@ static HRESULT surface_cpu_blt(struct wined3d_surface *dst_surface, const RECT *
                 int last_sy = -1;
                 for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                 {
-                    sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                    sbuf = sbase + (sy >> 16) * src_row_pitch;
 
                     if ((sy >> 16) == (last_sy >> 16))
                     {
                         /* This source row is the same as last source row -
                          * Copy the already stretched row. */
-                        memcpy(dbuf, dbuf - dst_map.row_pitch, width);
+                        memcpy(dbuf, dbuf - dst_row_pitch, width);
                     }
                     else
                     {
@@ -4916,14 +4629,14 @@ do { \
                         }
 #undef STRETCH_ROW
                     }
-                    dbuf += dst_map.row_pitch;
+                    dbuf += dst_row_pitch;
                     last_sy = sy;
                 }
             }
         }
         else
         {
-            LONG dstyinc = dst_map.row_pitch, dstxinc = bpp;
+            LONG dstyinc = dst_row_pitch, dstxinc = bpp;
             DWORD keylow = 0xffffffff, keyhigh = 0, keymask = 0xffffffff;
             DWORD destkeylow = 0x0, destkeyhigh = 0xffffffff, destkeymask = 0xffffffff;
             if (flags & (WINEDDBLT_KEYSRC | WINEDDBLT_KEYDEST | WINEDDBLT_KEYSRCOVERRIDE | WINEDDBLT_KEYDESTOVERRIDE))
@@ -4973,7 +4686,7 @@ do { \
                 LONG tmpxy;
                 dTopLeft     = dbuf;
                 dTopRight    = dbuf + ((dstwidth - 1) * bpp);
-                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_map.row_pitch);
+                dBottomLeft  = dTopLeft + ((dstheight - 1) * dst_row_pitch);
                 dBottomRight = dBottomLeft + ((dstwidth - 1) * bpp);
 
                 if (fx->dwDDFX & WINEDDBLTFX_ARITHSTRETCHY)
@@ -5056,7 +4769,7 @@ do { \
     type *d = (type *)dbuf, *dx, tmp; \
     for (y = sy = 0; y < dstheight; ++y, sy += yinc) \
     { \
-        s = (const type *)(sbase + (sy >> 16) * src_map.row_pitch); \
+        s = (const type *)(sbase + (sy >> 16) * src_row_pitch); \
         dx = d; \
         for (x = sx = 0; x < dstwidth; ++x, sx += xinc) \
         { \
@@ -5089,7 +4802,7 @@ do { \
                     BYTE *d = dbuf, *dx;
                     for (y = sy = 0; y < dstheight; ++y, sy += yinc)
                     {
-                        sbuf = sbase + (sy >> 16) * src_map.row_pitch;
+                        sbuf = sbase + (sy >> 16) * src_row_pitch;
                         dx = d;
                         for (x = sx = 0; x < dstwidth; ++x, sx+= xinc)
                         {
@@ -5120,6 +4833,10 @@ do { \
         }
     }
 
+    wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->resource.map_binding);
+    if (dst_surface->container)
+        wined3d_texture_set_dirty(dst_surface->container);
+
 error:
     if (flags && FIXME_ON(d3d_surface))
     {
@@ -5127,12 +4844,24 @@ error:
     }
 
 release:
-    wined3d_surface_unmap(dst_surface);
-    if (src_surface && src_surface != dst_surface)
-        wined3d_surface_unmap(src_surface);
+    if (dst_data)
+    {
+        wined3d_resource_release_map_ptr(&dst_surface->resource, context);
+
+        if (dst_surface->container->swapchain
+                && dst_surface->container == dst_surface->container->swapchain->front_buffer)
+        {
+            dst_surface->lockedRect = *dst_rect;
+            dst_surface->surface_ops->surface_frontbuffer_updated(dst_surface);
+        }
+    }
+    if (src_surface && src_surface != dst_surface && src_data)
+        wined3d_resource_release_map_ptr(&src_surface->resource, context);
     /* Release the converted surface, if any. */
     if (src_texture)
         wined3d_texture_decref(src_texture);
+    if (context)
+        context_release(context);
 
     return hr;
 }
@@ -5167,14 +4896,13 @@ const struct blit_shader cpu_blit =  {
     cpu_blit_depth_fill,
 };
 
-HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
-        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect,
+        struct wined3d_surface *src_surface, const RECT *src_rect, DWORD flags,
         const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
 {
     struct wined3d_swapchain *src_swapchain, *dst_swapchain;
     struct wined3d_device *device = dst_surface->resource.device;
     DWORD src_ds_flags, dst_ds_flags;
-    RECT src_rect, dst_rect;
     BOOL scale, convert;
 
     static const DWORD simple_blit = WINEDDBLT_ASYNC
@@ -5183,104 +4911,6 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             | WINEDDBLT_DEPTHFILL
             | WINEDDBLT_DONOTWAIT;
 
-    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
-            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
-            flags, fx, debug_d3dtexturefiltertype(filter));
-    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
-
-    if (fx)
-    {
-        TRACE("dwSize %#x.\n", fx->dwSize);
-        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
-        TRACE("dwROP %#x.\n", fx->dwROP);
-        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
-        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
-        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
-        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
-        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
-        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
-        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
-        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
-        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
-        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
-        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
-        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
-        TRACE("dwReserved %#x.\n", fx->dwReserved);
-        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
-        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
-        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
-        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
-        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
-        TRACE("ddckDestColorkey {%#x, %#x}.\n",
-                fx->ddckDestColorkey.color_space_low_value,
-                fx->ddckDestColorkey.color_space_high_value);
-        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
-                fx->ddckSrcColorkey.color_space_low_value,
-                fx->ddckSrcColorkey.color_space_high_value);
-    }
-
-    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
-    {
-        WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
-        return WINEDDERR_SURFACEBUSY;
-    }
-
-    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
-
-    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
-            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
-            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
-            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
-            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
-    {
-        WARN("The application gave us a bad destination rectangle.\n");
-        return WINEDDERR_INVALIDRECT;
-    }
-
-    if (src_surface)
-    {
-        surface_get_rect(src_surface, src_rect_in, &src_rect);
-
-        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
-                || src_rect.left > src_surface->resource.width || src_rect.left < 0
-                || src_rect.top > src_surface->resource.height || src_rect.top < 0
-                || src_rect.right > src_surface->resource.width || src_rect.right < 0
-                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
-        {
-            WARN("Application gave us bad source rectangle for Blt.\n");
-            return WINEDDERR_INVALIDRECT;
-        }
-    }
-    else
-    {
-        memset(&src_rect, 0, sizeof(src_rect));
-    }
-
-    if (!fx || !(fx->dwDDFX))
-        flags &= ~WINEDDBLT_DDFX;
-
-    if (flags & WINEDDBLT_WAIT)
-        flags &= ~WINEDDBLT_WAIT;
-
-    if (flags & WINEDDBLT_ASYNC)
-    {
-        static unsigned int once;
-
-        if (!once++)
-            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
-        flags &= ~WINEDDBLT_ASYNC;
-    }
-
-    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
-    if (flags & WINEDDBLT_DONOTWAIT)
-    {
-        static unsigned int once;
-
-        if (!once++)
-            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
-        flags &= ~WINEDDBLT_DONOTWAIT;
-    }
-
     if (!device->d3d_initialized)
     {
         WARN("D3D not initialized, using fallback.\n");
@@ -5323,8 +4953,8 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
     }
 
     scale = src_surface
-            && (src_rect.right - src_rect.left != dst_rect.right - dst_rect.left
-            || src_rect.bottom - src_rect.top != dst_rect.bottom - dst_rect.top);
+            && (src_rect->right - src_rect->left != dst_rect->right - dst_rect->left
+            || src_rect->bottom - src_rect->top != dst_rect->bottom - dst_rect->top);
     convert = src_surface && src_surface->resource.format->id != dst_surface->resource.format->id;
 
     dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
@@ -5342,30 +4972,24 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             TRACE("Depth fill.\n");
 
             if (!surface_convert_depth_to_float(dst_surface, fx->u5.dwFillDepth, &depth))
-                return WINED3DERR_INVALIDCALL;
+                return;
 
-            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, &dst_rect, depth)))
-                return WINED3D_OK;
+            if (SUCCEEDED(wined3d_surface_depth_fill(dst_surface, dst_rect, depth)))
+                return;
         }
         else
         {
-            if (src_ds_flags != dst_ds_flags)
-            {
-                WARN("Rejecting depth / stencil blit between incompatible formats.\n");
-                return WINED3DERR_INVALIDCALL;
-            }
-
             if (SUCCEEDED(wined3d_surface_depth_blt(src_surface, src_surface->container->resource.draw_binding,
-                    &src_rect, dst_surface, dst_surface->container->resource.draw_binding, &dst_rect)))
-                return WINED3D_OK;
+                    src_rect, dst_surface, dst_surface->container->resource.draw_binding, dst_rect)))
+                return;
         }
     }
     else
     {
         /* In principle this would apply to depth blits as well, but we don't
          * implement those in the CPU blitter at the moment. */
-        if ((dst_surface->locations & dst_surface->resource.map_binding)
-                && (!src_surface || (src_surface->locations & src_surface->resource.map_binding)))
+        if ((dst_surface->resource.locations & dst_surface->resource.map_binding)
+                && (!src_surface || (src_surface->resource.locations & src_surface->resource.map_binding)))
         {
             if (scale)
                 TRACE("Not doing sysmem blit because of scaling.\n");
@@ -5384,16 +5008,16 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
             if (!surface_convert_color_to_float(dst_surface, fx->u5.dwFillColor, &color))
                 goto fallback;
 
-            if (SUCCEEDED(surface_color_fill(dst_surface, &dst_rect, &color)))
-                return WINED3D_OK;
+            if (SUCCEEDED(surface_color_fill(dst_surface, dst_rect, &color)))
+                return;
         }
         else
         {
             TRACE("Color blit.\n");
 
             /* Upload */
-            if ((src_surface->locations & WINED3D_LOCATION_SYSMEM)
-                    && !(dst_surface->locations & WINED3D_LOCATION_SYSMEM))
+            if ((src_surface->resource.locations & WINED3D_LOCATION_SYSMEM)
+                    && !(dst_surface->resource.locations & WINED3D_LOCATION_SYSMEM))
             {
                 if (scale)
                     TRACE("Not doing upload because of scaling.\n");
@@ -5401,13 +5025,18 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                     TRACE("Not doing upload because of format conversion.\n");
                 else
                 {
-                    POINT dst_point = {dst_rect.left, dst_rect.top};
+                    POINT dst_point = {dst_rect->left, dst_rect->top};
 
-                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, &src_rect)))
+                    if (SUCCEEDED(surface_upload_from_surface(dst_surface, &dst_point, src_surface, src_rect)))
                     {
                         if (!wined3d_resource_is_offscreen(&dst_surface->container->resource))
-                            surface_load_location(dst_surface, dst_surface->container->resource.draw_binding);
-                        return WINED3D_OK;
+                        {
+                            struct wined3d_context *context = context_acquire(device, dst_surface);
+                            wined3d_resource_load_location(&dst_surface->resource, context,
+                                    dst_surface->container->resource.draw_binding);
+                            context_release(context);
+                        }
+                        return;
                     }
                 }
             }
@@ -5432,49 +5061,203 @@ HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const REC
                 wined3d_swapchain_present(dst_swapchain, NULL, NULL, dst_swapchain->win_handle, NULL, 0);
                 dst_swapchain->desc.swap_effect = swap_effect;
 
-                return WINED3D_OK;
+                return;
             }
 
             if (fbo_blit_supported(&device->adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
-                    &src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
-                    &dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
             {
+                struct wined3d_context *context;
                 TRACE("Using FBO blit.\n");
 
-                surface_blt_fbo(device, filter,
-                        src_surface, src_surface->container->resource.draw_binding, &src_rect,
-                        dst_surface, dst_surface->container->resource.draw_binding, &dst_rect);
-                surface_validate_location(dst_surface, dst_surface->container->resource.draw_binding);
-                surface_invalidate_location(dst_surface, ~dst_surface->container->resource.draw_binding);
+                context = context_acquire(device, NULL);
+                surface_blt_fbo(device, context, filter,
+                        src_surface, src_surface->container->resource.draw_binding, src_rect,
+                        dst_surface, dst_surface->container->resource.draw_binding, dst_rect);
+                context_release(context);
 
-                return WINED3D_OK;
+                wined3d_resource_validate_location(&dst_surface->resource, dst_surface->container->resource.draw_binding);
+                wined3d_resource_invalidate_location(&dst_surface->resource, ~dst_surface->container->resource.draw_binding);
+
+                return;
             }
 
             if (arbfp_blit.blit_supported(&device->adapter->gl_info, WINED3D_BLIT_OP_COLOR_BLIT,
-                    &src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
-                    &dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
+                    src_rect, src_surface->resource.usage, src_surface->resource.pool, src_surface->resource.format,
+                    dst_rect, dst_surface->resource.usage, dst_surface->resource.pool, dst_surface->resource.format))
             {
                 TRACE("Using arbfp blit.\n");
 
-                if (SUCCEEDED(arbfp_blit_surface(device, filter, src_surface, &src_rect, dst_surface, &dst_rect)))
-                    return WINED3D_OK;
+                if (SUCCEEDED(arbfp_blit_surface(device, filter, src_surface, src_rect, dst_surface, dst_rect)))
+                    return;
             }
         }
     }
 
 fallback:
     /* Special cases for render targets. */
-    if (SUCCEEDED(surface_blt_special(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter)))
-        return WINED3D_OK;
+    if ((dst_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)
+            || (src_surface && (src_surface->resource.usage & WINED3DUSAGE_RENDERTARGET)))
+    {
+        if (SUCCEEDED(surface_blt_special(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter)))
+            return;
+    }
 
 cpu:
 
     /* For the rest call the X11 surface implementation. For render targets
      * this should be implemented OpenGL accelerated in surface_blt_special(),
      * other blits are rather rare. */
-    return surface_cpu_blt(dst_surface, &dst_rect, src_surface, &src_rect, flags, fx, filter);
+    surface_cpu_blt(dst_surface, dst_rect, src_surface, src_rect, flags, fx, filter);
+    return;
 }
 
+HRESULT CDECL wined3d_surface_blt(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter)
+{
+    struct wined3d_device *device = dst_surface->resource.device;
+    RECT src_rect, dst_rect;
+
+    TRACE("dst_surface %p, dst_rect %s, src_surface %p, src_rect %s, flags %#x, fx %p, filter %s.\n",
+            dst_surface, wine_dbgstr_rect(dst_rect_in), src_surface, wine_dbgstr_rect(src_rect_in),
+            flags, fx, debug_d3dtexturefiltertype(filter));
+    TRACE("Usage is %s.\n", debug_d3dusage(dst_surface->resource.usage));
+
+    if (fx)
+    {
+        TRACE("dwSize %#x.\n", fx->dwSize);
+        TRACE("dwDDFX %#x.\n", fx->dwDDFX);
+        TRACE("dwROP %#x.\n", fx->dwROP);
+        TRACE("dwDDROP %#x.\n", fx->dwDDROP);
+        TRACE("dwRotationAngle %#x.\n", fx->dwRotationAngle);
+        TRACE("dwZBufferOpCode %#x.\n", fx->dwZBufferOpCode);
+        TRACE("dwZBufferLow %#x.\n", fx->dwZBufferLow);
+        TRACE("dwZBufferHigh %#x.\n", fx->dwZBufferHigh);
+        TRACE("dwZBufferBaseDest %#x.\n", fx->dwZBufferBaseDest);
+        TRACE("dwZDestConstBitDepth %#x.\n", fx->dwZDestConstBitDepth);
+        TRACE("lpDDSZBufferDest %p.\n", fx->u1.lpDDSZBufferDest);
+        TRACE("dwZSrcConstBitDepth %#x.\n", fx->dwZSrcConstBitDepth);
+        TRACE("lpDDSZBufferSrc %p.\n", fx->u2.lpDDSZBufferSrc);
+        TRACE("dwAlphaEdgeBlendBitDepth %#x.\n", fx->dwAlphaEdgeBlendBitDepth);
+        TRACE("dwAlphaEdgeBlend %#x.\n", fx->dwAlphaEdgeBlend);
+        TRACE("dwReserved %#x.\n", fx->dwReserved);
+        TRACE("dwAlphaDestConstBitDepth %#x.\n", fx->dwAlphaDestConstBitDepth);
+        TRACE("lpDDSAlphaDest %p.\n", fx->u3.lpDDSAlphaDest);
+        TRACE("dwAlphaSrcConstBitDepth %#x.\n", fx->dwAlphaSrcConstBitDepth);
+        TRACE("lpDDSAlphaSrc %p.\n", fx->u4.lpDDSAlphaSrc);
+        TRACE("lpDDSPattern %p.\n", fx->u5.lpDDSPattern);
+        TRACE("ddckDestColorkey {%#x, %#x}.\n",
+                fx->ddckDestColorkey.color_space_low_value,
+                fx->ddckDestColorkey.color_space_high_value);
+        TRACE("ddckSrcColorkey {%#x, %#x}.\n",
+                fx->ddckSrcColorkey.color_space_low_value,
+                fx->ddckSrcColorkey.color_space_high_value);
+    }
+
+    if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+    {
+        /* TODO: Separate application maps from internal maps */
+        if (!wined3d_settings.cs_multithreaded)
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+
+        wined3d_cs_emit_glfinish(dst_surface->resource.device->cs);
+        dst_surface->resource.device->cs->ops->finish(dst_surface->resource.device->cs);
+
+        if (dst_surface->resource.map_count || (src_surface && src_surface->resource.map_count))
+        {
+            WARN("Surface is busy, returning WINEDDERR_SURFACEBUSY.\n");
+            return WINEDDERR_SURFACEBUSY;
+        }
+    }
+
+    surface_get_rect(dst_surface, dst_rect_in, &dst_rect);
+
+    if (dst_rect.left >= dst_rect.right || dst_rect.top >= dst_rect.bottom
+            || dst_rect.left > dst_surface->resource.width || dst_rect.left < 0
+            || dst_rect.top > dst_surface->resource.height || dst_rect.top < 0
+            || dst_rect.right > dst_surface->resource.width || dst_rect.right < 0
+            || dst_rect.bottom > dst_surface->resource.height || dst_rect.bottom < 0)
+    {
+        WARN("The application gave us a bad destination rectangle.\n");
+        return WINEDDERR_INVALIDRECT;
+    }
+
+    if (src_surface)
+    {
+        DWORD src_ds_flags, dst_ds_flags;
+
+        surface_get_rect(src_surface, src_rect_in, &src_rect);
+
+        if (src_rect.left >= src_rect.right || src_rect.top >= src_rect.bottom
+                || src_rect.left > src_surface->resource.width || src_rect.left < 0
+                || src_rect.top > src_surface->resource.height || src_rect.top < 0
+                || src_rect.right > src_surface->resource.width || src_rect.right < 0
+                || src_rect.bottom > src_surface->resource.height || src_rect.bottom < 0)
+        {
+            WARN("Application gave us bad source rectangle for Blt.\n");
+            return WINEDDERR_INVALIDRECT;
+        }
+
+        dst_ds_flags = dst_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        src_ds_flags = src_surface->resource.format->flags & (WINED3DFMT_FLAG_DEPTH | WINED3DFMT_FLAG_STENCIL);
+        if (src_ds_flags != dst_ds_flags)
+        {
+            WARN("Rejecting depth / stencil blit between incompatible formats.\n");
+            return WINED3DERR_INVALIDCALL;
+        }
+
+    }
+    else
+    {
+        memset(&src_rect, 0, sizeof(src_rect));
+    }
+
+    if (!fx || !(fx->dwDDFX))
+        flags &= ~WINEDDBLT_DDFX;
+
+    if (flags & WINEDDBLT_WAIT)
+        flags &= ~WINEDDBLT_WAIT;
+
+    if (flags & WINEDDBLT_ASYNC)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_ASYNC flag.\n");
+        flags &= ~WINEDDBLT_ASYNC;
+    }
+
+    /* WINEDDBLT_DONOTWAIT appeared in DX7. */
+    if (flags & WINEDDBLT_DONOTWAIT)
+    {
+        static unsigned int once;
+
+        if (!once++)
+            FIXME("Can't handle WINEDDBLT_DONOTWAIT flag.\n");
+        flags &= ~WINEDDBLT_DONOTWAIT;
+    }
+
+    TRACE("Emitting blit %p <== %p\n", dst_surface, src_surface);
+    wined3d_cs_emit_blt(device->cs, dst_surface, &dst_rect, src_surface, &src_rect,
+            flags, fx, filter);
+
+    return WINED3D_OK;
+}
+
+static const struct wined3d_resource_ops surface_resource_ops =
+{
+    surface_resource_incref,
+    surface_resource_decref,
+    surface_unload,
+    wined3d_surface_location_invalidated,
+    wined3d_surface_load_location,
+};
+
 static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_texture *container,
         const struct wined3d_resource_desc *desc, GLenum target, unsigned int level, unsigned int layer, DWORD flags)
 {
@@ -5541,7 +5324,7 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     }
 
     surface->container = container;
-    surface_validate_location(surface, WINED3D_LOCATION_SYSMEM);
+    wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
     list_init(&surface->renderbuffers);
     list_init(&surface->overlays);
 
@@ -5573,8 +5356,9 @@ static HRESULT surface_init(struct wined3d_surface *surface, struct wined3d_text
     if (surface->resource.map_binding == WINED3D_LOCATION_DIB)
     {
         wined3d_resource_free_sysmem(&surface->resource);
-        surface_validate_location(surface, WINED3D_LOCATION_DIB);
-        surface_invalidate_location(surface, WINED3D_LOCATION_SYSMEM);
+        surface->resource.map_heap_memory = NULL;
+        wined3d_resource_validate_location(&surface->resource, WINED3D_LOCATION_DIB);
+        wined3d_resource_invalidate_location(&surface->resource, WINED3D_LOCATION_SYSMEM);
     }
 
     return hr;
@@ -5601,7 +5385,7 @@ HRESULT wined3d_surface_create(struct wined3d_texture *container, const struct w
     if (FAILED(hr = surface_init(object, container, desc, target, level, layer, flags)))
     {
         WARN("Failed to initialize surface, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
+        /* The command stream takes care of freeing the memory. */
         return hr;
     }
 
diff --git a/dlls/wined3d/swapchain.c b/dlls/wined3d/swapchain.c
index 25e2107..c126ef7 100644
--- a/dlls/wined3d/swapchain.c
+++ b/dlls/wined3d/swapchain.c
@@ -309,7 +309,7 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
         if (backbuffer->resource.multisample_type)
         {
             location = WINED3D_LOCATION_RB_RESOLVED;
-            surface_load_location(backbuffer, location);
+            wined3d_resource_load_location(&backbuffer->resource, context, location);
         }
 
         context_apply_fbo_state_blit(context, GL_READ_FRAMEBUFFER, backbuffer, NULL, location);
@@ -417,11 +417,11 @@ static void swapchain_blit(const struct wined3d_swapchain *swapchain,
 }
 
 static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
-        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
 {
     struct wined3d_surface *back_buffer = surface_from_resource(
             wined3d_texture_get_sub_resource(swapchain->back_buffers[0], 0));
-    const struct wined3d_fb_state *fb = &swapchain->device->fb;
     const struct wined3d_gl_info *gl_info;
     struct wined3d_context *context;
     struct wined3d_surface *front;
@@ -449,27 +449,6 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
                 NULL, WINED3D_TEXF_POINT);
     }
 
-    if (swapchain->device->bCursorVisible && swapchain->device->cursor_texture
-            && !swapchain->device->hardwareCursor)
-    {
-        struct wined3d_surface *cursor = surface_from_resource(
-                wined3d_texture_get_sub_resource(swapchain->device->cursor_texture, 0));
-        RECT destRect =
-        {
-            swapchain->device->xScreenSpace - swapchain->device->xHotSpot,
-            swapchain->device->yScreenSpace - swapchain->device->yHotSpot,
-            swapchain->device->xScreenSpace + swapchain->device->cursorWidth - swapchain->device->xHotSpot,
-            swapchain->device->yScreenSpace + swapchain->device->cursorHeight - swapchain->device->yHotSpot,
-        };
-
-        TRACE("Rendering the software cursor.\n");
-
-        if (swapchain->desc.windowed)
-            MapWindowPoints(NULL, swapchain->win_handle, (POINT *)&destRect, 2);
-        wined3d_surface_blt(back_buffer, &destRect, cursor, NULL, WINEDDBLT_ALPHATEST,
-                NULL, WINED3D_TEXF_POINT);
-    }
-
     TRACE("Presenting HDC %p.\n", context->hdc);
 
     render_to_fbo = swapchain->render_to_fbo;
@@ -511,14 +490,14 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
      */
     if (!swapchain->render_to_fbo && render_to_fbo && wined3d_settings.offscreen_rendering_mode == ORM_FBO)
     {
-        surface_load_location(back_buffer, WINED3D_LOCATION_TEXTURE_RGB);
-        surface_invalidate_location(back_buffer, WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_load_location(&back_buffer->resource, context, WINED3D_LOCATION_TEXTURE_RGB);
+        wined3d_resource_invalidate_location(&back_buffer->resource, WINED3D_LOCATION_DRAWABLE);
         swapchain->render_to_fbo = TRUE;
         swapchain_update_draw_bindings(swapchain);
     }
     else
     {
-        surface_load_location(back_buffer, back_buffer->container->resource.draw_binding);
+        wined3d_resource_load_location(&back_buffer->resource, context, back_buffer->container->resource.draw_binding);
     }
 
     if (swapchain->render_to_fbo)
@@ -531,8 +510,8 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
         swapchain_blit(swapchain, context, &src_rect, &dst_rect);
     }
 
-    if (swapchain->num_contexts > 1)
-        gl_info->gl_ops.gl.p_glFinish();
+    if (swapchain->num_contexts > 1 && !wined3d_settings.cs_multithreaded)
+        gl_info->gl_ops.gl.p_glFlush();
 
     /* call wglSwapBuffers through the gl table to avoid confusing the Steam overlay */
     gl_info->gl_ops.wgl.p_wglSwapBuffers(context->hdc); /* TODO: cycle through the swapchain buffers */
@@ -555,59 +534,34 @@ static void swapchain_gl_present(struct wined3d_swapchain *swapchain, const RECT
     }
 
     front = surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0));
-    if (!swapchain->render_to_fbo && ((front->locations & WINED3D_LOCATION_SYSMEM)
-            || (back_buffer->locations & WINED3D_LOCATION_SYSMEM)))
+    wined3d_resource_validate_location(&front->resource, WINED3D_LOCATION_DRAWABLE);
+    wined3d_resource_invalidate_location(&front->resource, ~WINED3D_LOCATION_DRAWABLE);
+    switch (swapchain->desc.swap_effect)
     {
-        /* Both memory copies of the surfaces are ok, flip them around too instead of dirtifying
-         * Doesn't work with render_to_fbo because we're not flipping
-         */
+        case WINED3D_SWAP_EFFECT_DISCARD:
+            wined3d_resource_validate_location(&back_buffer->resource, WINED3D_LOCATION_DISCARDED);
+            break;
 
-        if (front->resource.size == back_buffer->resource.size)
-        {
-            flip_surface(front, back_buffer);
+        case WINED3D_SWAP_EFFECT_FLIP:
+            wined3d_resource_validate_location(&back_buffer->resource, back_buffer->container->resource.draw_binding);
+            wined3d_resource_invalidate_location(&back_buffer->resource, ~back_buffer->container->resource.draw_binding);
+            break;
 
-            /* Tell the front buffer surface that is has been modified. However,
-             * the other locations were preserved during that, so keep the flags.
-             * This serves to update the emulated overlay, if any. */
-            surface_validate_location(front, WINED3D_LOCATION_DRAWABLE);
-        }
-        else
-        {
-            surface_validate_location(front, WINED3D_LOCATION_DRAWABLE);
-            surface_invalidate_location(front, ~WINED3D_LOCATION_DRAWABLE);
-            surface_validate_location(back_buffer, WINED3D_LOCATION_DRAWABLE);
-            surface_invalidate_location(back_buffer, ~WINED3D_LOCATION_DRAWABLE);
-        }
-    }
-    else
-    {
-        surface_validate_location(front, WINED3D_LOCATION_DRAWABLE);
-        surface_invalidate_location(front, ~WINED3D_LOCATION_DRAWABLE);
-        /* If the swapeffect is DISCARD, the back buffer is undefined. That means the SYSMEM
-         * and INTEXTURE copies can keep their old content if they have any defined content.
-         * If the swapeffect is COPY, the content remains the same. If it is FLIP however,
-         * the texture / sysmem copy needs to be reloaded from the drawable
-         */
-        if (swapchain->desc.swap_effect == WINED3D_SWAP_EFFECT_FLIP)
-        {
-            surface_validate_location(back_buffer, back_buffer->container->resource.draw_binding);
-            surface_invalidate_location(back_buffer, ~back_buffer->container->resource.draw_binding);
-        }
+        default:
+            break;
     }
 
-    if (fb->depth_stencil)
+    if (depth_stencil)
     {
-        struct wined3d_surface *ds = wined3d_rendertarget_view_get_surface(fb->depth_stencil);
-
-        if (ds && (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
-                || ds->flags & SFLAG_DISCARD))
+        if (swapchain->desc.flags & WINED3DPRESENTFLAG_DISCARD_DEPTHSTENCIL
+                || depth_stencil->flags & SFLAG_DISCARD)
         {
-            surface_modify_ds_location(ds, WINED3D_LOCATION_DISCARDED,
-                    fb->depth_stencil->width, fb->depth_stencil->height);
-            if (ds == swapchain->device->onscreen_depth_stencil)
+            surface_modify_ds_location(depth_stencil, WINED3D_LOCATION_DISCARDED,
+                    depth_stencil->resource.width, depth_stencil->resource.height);
+            if (depth_stencil == swapchain->device->cs->onscreen_depth_stencil)
             {
-                wined3d_surface_decref(swapchain->device->onscreen_depth_stencil);
-                swapchain->device->onscreen_depth_stencil = NULL;
+                wined3d_surface_decref(swapchain->device->cs->onscreen_depth_stencil);
+                swapchain->device->cs->onscreen_depth_stencil = NULL;
             }
         }
     }
@@ -640,7 +594,7 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 
     TRACE("Copying surface %p to screen.\n", front);
 
-    surface_load_location(front, WINED3D_LOCATION_DIB);
+    wined3d_resource_load_location(&front->resource, NULL, WINED3D_LOCATION_DIB);
 
     src_dc = front->hDC;
     window = swapchain->win_handle;
@@ -668,7 +622,8 @@ void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *r
 }
 
 static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const RECT *src_rect_in,
-        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags)
+        const RECT *dst_rect_in, const RGNDATA *dirty_region, DWORD flags,
+        struct wined3d_surface *depth_stencil)
 {
     struct wined3d_surface *front, *back;
 
@@ -695,9 +650,9 @@ static void swapchain_gdi_present(struct wined3d_swapchain *swapchain, const REC
     {
         void *tmp;
 
-        tmp = front->dib.bitmap_data;
-        front->dib.bitmap_data = back->dib.bitmap_data;
-        back->dib.bitmap_data = tmp;
+        tmp = front->resource.bitmap_data;
+        front->resource.bitmap_data = back->resource.bitmap_data;
+        back->resource.bitmap_data = tmp;
 
         if (front->resource.heap_memory)
             ERR("GDI Surface %p has heap memory allocated.\n", front);
@@ -768,6 +723,69 @@ void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain)
     swapchain->render_to_fbo = TRUE;
 }
 
+HRESULT swapchain_create_context_cs(struct wined3d_device *device, struct wined3d_swapchain *swapchain)
+{
+    const struct wined3d_adapter *adapter = device->adapter;
+    unsigned int i;
+    static const enum wined3d_format_id formats[] =
+    {
+        WINED3DFMT_D24_UNORM_S8_UINT,
+        WINED3DFMT_D32_UNORM,
+        WINED3DFMT_R24_UNORM_X8_TYPELESS,
+        WINED3DFMT_D16_UNORM,
+        WINED3DFMT_S1_UINT_D15_UNORM
+    };
+    struct wined3d_surface *front_buffer;
+    const struct wined3d_gl_info *gl_info = &adapter->gl_info;
+
+    swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
+    if (!swapchain->context)
+    {
+        ERR("Failed to create the context array.\n");
+        return E_OUTOFMEMORY;
+    }
+    swapchain->num_contexts = 1;
+
+    /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
+     * You are able to add a depth + stencil surface at a later stage when you need it.
+     * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
+     * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
+     * context, need torecreate shaders, textures and other resources.
+     *
+     * The context manager already takes care of the state problem and for the other tasks code from Reset
+     * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
+     * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
+     * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
+     * issue needs to be fixed. */
+    front_buffer = surface_from_resource(wined3d_texture_get_sub_resource(swapchain->front_buffer, 0));
+    for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
+    {
+        swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
+        swapchain->context[0] = context_create(swapchain, front_buffer, swapchain->ds_format);
+        if (swapchain->context[0]) break;
+        TRACE("Depth stencil format %s is not supported, trying next format\n",
+                debug_d3dformat(formats[i]));
+    }
+
+    if (!swapchain->context[0])
+    {
+        WARN("Failed to create context.\n");
+        HeapFree(GetProcessHeap(), 0, swapchain->context);
+        swapchain->context = NULL;
+        return WINED3DERR_NOTAVAILABLE;
+    }
+
+    if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
+            && (!swapchain->desc.enable_auto_depth_stencil
+            || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
+    {
+        FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
+    }
+    context_release(swapchain->context[0]);
+
+    return WINED3D_OK;
+}
+
 static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3d_device *device,
         struct wined3d_swapchain_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
@@ -865,8 +883,8 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
     wined3d_texture_set_swapchain(swapchain->front_buffer, swapchain);
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        surface_validate_location(front_buffer, WINED3D_LOCATION_DRAWABLE);
-        surface_invalidate_location(front_buffer, ~WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_validate_location(&front_buffer->resource, WINED3D_LOCATION_DRAWABLE);
+        wined3d_resource_invalidate_location(&front_buffer->resource, ~WINED3D_LOCATION_DRAWABLE);
     }
 
     /* MSDN says we're only allowed a single fullscreen swapchain per device,
@@ -875,16 +893,14 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!desc->windowed)
     {
-        struct wined3d_display_mode mode;
-
         /* Change the display settings */
-        mode.width = desc->backbuffer_width;
-        mode.height = desc->backbuffer_height;
-        mode.format_id = desc->backbuffer_format;
-        mode.refresh_rate = desc->refresh_rate;
-        mode.scanline_ordering = WINED3D_SCANLINE_ORDERING_UNKNOWN;
+        swapchain->d3d_mode.width = desc->backbuffer_width;
+        swapchain->d3d_mode.height = desc->backbuffer_height;
+        swapchain->d3d_mode.format_id = desc->backbuffer_format;
+        swapchain->d3d_mode.refresh_rate = desc->refresh_rate;
+        swapchain->d3d_mode.scanline_ordering = WINED3D_SCANLINE_ORDERING_UNKNOWN;
 
-        if (FAILED(hr = wined3d_set_adapter_display_mode(device->wined3d, adapter->ordinal, &mode)))
+        if (FAILED(hr = wined3d_set_adapter_display_mode(device->wined3d, adapter->ordinal, &swapchain->d3d_mode)))
         {
             WARN("Failed to set display mode, hr %#x.\n", hr);
             goto err;
@@ -894,60 +910,9 @@ static HRESULT swapchain_init(struct wined3d_swapchain *swapchain, struct wined3
 
     if (!(device->wined3d->flags & WINED3D_NO3D))
     {
-        static const enum wined3d_format_id formats[] =
-        {
-            WINED3DFMT_D24_UNORM_S8_UINT,
-            WINED3DFMT_D32_UNORM,
-            WINED3DFMT_R24_UNORM_X8_TYPELESS,
-            WINED3DFMT_D16_UNORM,
-            WINED3DFMT_S1_UINT_D15_UNORM
-        };
-
-        const struct wined3d_gl_info *gl_info = &adapter->gl_info;
-
-        swapchain->context = HeapAlloc(GetProcessHeap(), 0, sizeof(*swapchain->context));
-        if (!swapchain->context)
-        {
-            ERR("Failed to create the context array.\n");
-            hr = E_OUTOFMEMORY;
+        hr = wined3d_cs_emit_create_swapchain_context(device->cs, swapchain);
+        if (FAILED(hr))
             goto err;
-        }
-        swapchain->num_contexts = 1;
-
-        /* In WGL both color, depth and stencil are features of a pixel format. In case of D3D they are separate.
-         * You are able to add a depth + stencil surface at a later stage when you need it.
-         * In order to support this properly in WineD3D we need the ability to recreate the opengl context and
-         * drawable when this is required. This is very tricky as we need to reapply ALL opengl states for the new
-         * context, need torecreate shaders, textures and other resources.
-         *
-         * The context manager already takes care of the state problem and for the other tasks code from Reset
-         * can be used. These changes are way to risky during the 1.0 code freeze which is taking place right now.
-         * Likely a lot of other new bugs will be exposed. For that reason request a depth stencil surface all the
-         * time. It can cause a slight performance hit but fixes a lot of regressions. A fixme reminds of that this
-         * issue needs to be fixed. */
-        for (i = 0; i < (sizeof(formats) / sizeof(*formats)); i++)
-        {
-            swapchain->ds_format = wined3d_get_format(gl_info, formats[i]);
-            swapchain->context[0] = context_create(swapchain, front_buffer, swapchain->ds_format);
-            if (swapchain->context[0]) break;
-            TRACE("Depth stencil format %s is not supported, trying next format\n",
-                  debug_d3dformat(formats[i]));
-        }
-
-        if (!swapchain->context[0])
-        {
-            WARN("Failed to create context.\n");
-            hr = WINED3DERR_NOTAVAILABLE;
-            goto err;
-        }
-
-        if (wined3d_settings.offscreen_rendering_mode != ORM_FBO
-                && (!desc->enable_auto_depth_stencil
-                || swapchain->desc.auto_depth_stencil_format != swapchain->ds_format->id))
-        {
-            FIXME("Add OpenGL context recreation support to context_validate_onscreen_formats\n");
-        }
-        context_release(swapchain->context[0]);
     }
 
     if (swapchain->desc.backbuffer_count > 0)
@@ -1175,3 +1140,42 @@ void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain)
         wined3d_resource_update_draw_binding(&swapchain->back_buffers[i]->resource);
     }
 }
+
+void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate)
+{
+    if (activate)
+    {
+        if (!(swapchain->device->create_parms.flags & WINED3DCREATE_NOWINDOWCHANGES))
+        {
+            /* The d3d versions do not agree on the exact messages here. D3d8 restores
+             * the window but leaves the size untouched, d3d9 sets the size on an
+             * invisible window, generates messages but doesn't change the window
+             * properties. The implementation follows d3d9.
+             *
+             * Guild Wars 1 wants a WINDOWPOSCHANGED message on the device window to
+             * resume drawing after a focus loss. */
+            SetWindowPos(swapchain->device_window, NULL, 0, 0,
+                    swapchain->desc.backbuffer_width, swapchain->desc.backbuffer_height,
+                    SWP_NOACTIVATE | SWP_NOZORDER);
+        }
+
+        if (swapchain->device->wined3d->flags & WINED3D_RESTORE_MODE_ON_ACTIVATE)
+        {
+            if (FAILED(wined3d_set_adapter_display_mode(swapchain->device->wined3d,
+                    swapchain->device->adapter->ordinal, &swapchain->d3d_mode)))
+                ERR("Failed to set display mode.\n");
+        }
+    }
+    else
+    {
+        if (FAILED(wined3d_set_adapter_display_mode(swapchain->device->wined3d,
+                swapchain->device->adapter->ordinal, NULL)))
+            ERR("Failed to set display mode.\n");
+
+        swapchain->reapply_mode = TRUE;
+
+        if (!(swapchain->device->create_parms.flags & WINED3DCREATE_NOWINDOWCHANGES)
+                && IsWindowVisible(swapchain->device_window))
+            ShowWindow(swapchain->device_window, SW_MINIMIZE);
+    }
+}
diff --git a/dlls/wined3d/texture.c b/dlls/wined3d/texture.c
index 6ecd414..6f78292 100644
--- a/dlls/wined3d/texture.c
+++ b/dlls/wined3d/texture.c
@@ -74,6 +74,8 @@ static HRESULT wined3d_texture_init(struct wined3d_texture *texture, const struc
     {
         ERR("Failed to allocate sub-resource array.\n");
         resource_cleanup(&texture->resource);
+        if (wined3d_settings.cs_multithreaded)
+            texture->resource.device->cs->ops->finish(texture->resource.device->cs);
         return E_OUTOFMEMORY;
     }
 
@@ -129,10 +131,18 @@ static void wined3d_texture_unload_gl_texture(struct wined3d_texture *texture)
     resource_unload(&texture->resource);
 }
 
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture)
+{
+    wined3d_texture_unload_gl_texture(texture);
+    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
+    HeapFree(GetProcessHeap(), 0, texture);
+}
+
 static void wined3d_texture_cleanup(struct wined3d_texture *texture)
 {
     UINT sub_count = texture->level_count * texture->layer_count;
     UINT i;
+    struct wined3d_device *device = texture->resource.device;
 
     TRACE("texture %p.\n", texture);
 
@@ -144,9 +154,8 @@ static void wined3d_texture_cleanup(struct wined3d_texture *texture)
             texture->texture_ops->texture_sub_resource_cleanup(sub_resource);
     }
 
-    wined3d_texture_unload_gl_texture(texture);
-    HeapFree(GetProcessHeap(), 0, texture->sub_resources);
     resource_cleanup(&texture->resource);
+    wined3d_cs_emit_texture_cleanup(device->cs, texture);
 }
 
 void wined3d_texture_set_swapchain(struct wined3d_texture *texture, struct wined3d_swapchain *swapchain)
@@ -513,9 +522,10 @@ ULONG CDECL wined3d_texture_decref(struct wined3d_texture *texture)
 
     if (!refcount)
     {
+        void *parent = texture->resource.parent;
+        const struct wined3d_parent_ops *parent_ops = texture->resource.parent_ops;
         wined3d_texture_cleanup(texture);
-        texture->resource.parent_ops->wined3d_object_destroyed(texture->resource.parent);
-        HeapFree(GetProcessHeap(), 0, texture);
+        parent_ops->wined3d_object_destroyed(parent);
     }
 
     return refcount;
@@ -563,10 +573,8 @@ void wined3d_texture_load(struct wined3d_texture *texture,
 
 void CDECL wined3d_texture_preload(struct wined3d_texture *texture)
 {
-    struct wined3d_context *context;
-    context = context_acquire(texture->resource.device, NULL);
-    wined3d_texture_load(texture, context, texture->flags & WINED3D_TEXTURE_IS_SRGB);
-    context_release(context);
+    const struct wined3d_device *device = texture->resource.device;
+    wined3d_cs_emit_texture_preload(device->cs, texture);
 }
 
 void * CDECL wined3d_texture_get_parent(const struct wined3d_texture *texture)
@@ -595,6 +603,13 @@ DWORD CDECL wined3d_texture_set_lod(struct wined3d_texture *texture, DWORD lod)
 
     if (texture->lod != lod)
     {
+        if (wined3d_settings.cs_multithreaded)
+        {
+            struct wined3d_device *device = texture->resource.device;
+            FIXME("Waiting for cs.\n");
+            device->cs->ops->finish(device->cs);
+        }
+
         texture->lod = lod;
 
         texture->texture_rgb.states[WINED3DTEXSTA_MAXMIPLEVEL] = ~0U;
@@ -654,6 +669,12 @@ HRESULT CDECL wined3d_texture_set_color_key(struct wined3d_texture *texture,
         return WINED3DERR_INVALIDCALL;
     }
 
+    if (wined3d_settings.cs_multithreaded)
+    {
+        FIXME("waiting for cs\n");
+        texture->resource.device->cs->ops->finish(texture->resource.device->cs);
+    }
+
     if (color_key)
     {
         switch (flags & ~WINEDDCKEY_COLORSPACE)
@@ -741,7 +762,10 @@ HRESULT CDECL wined3d_texture_update_desc(struct wined3d_texture *texture, UINT
     }
 
     if (device->d3d_initialized)
-        texture->resource.resource_ops->resource_unload(&texture->resource);
+    {
+        wined3d_cs_emit_evict_resource(device->cs, &surface->resource);
+        device->cs->ops->finish(device->cs);
+    }
 
     texture->resource.format = format;
     texture->resource.multisample_type = multisample_type;
@@ -819,17 +843,20 @@ HRESULT CDECL wined3d_texture_add_dirty_region(struct wined3d_texture *texture,
 static void texture2d_sub_resource_load(struct wined3d_resource *sub_resource,
         struct wined3d_context *context, BOOL srgb)
 {
-    surface_load(surface_from_resource(sub_resource), srgb);
+    surface_load(surface_from_resource(sub_resource), context, srgb);
 }
 
 static void texture2d_sub_resource_add_dirty_region(struct wined3d_resource *sub_resource,
         const struct wined3d_box *dirty_region)
 {
     struct wined3d_surface *surface = surface_from_resource(sub_resource);
+    struct wined3d_context *context;
 
-    surface_prepare_map_memory(surface);
-    surface_load_location(surface, surface->resource.map_binding);
-    surface_invalidate_location(surface, ~surface->resource.map_binding);
+    context = context_acquire(surface->resource.device, NULL);
+    wined3d_resource_prepare_map_memory(&surface->resource, context);
+    wined3d_resource_load_location(&surface->resource, context, surface->resource.map_binding);
+    context_release(context);
+    wined3d_resource_invalidate_location(&surface->resource, ~surface->resource.map_binding);
 }
 
 static void texture2d_sub_resource_cleanup(struct wined3d_resource *sub_resource)
@@ -841,9 +868,7 @@ static void texture2d_sub_resource_cleanup(struct wined3d_resource *sub_resource
 
 static void texture2d_sub_resource_invalidate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
-    struct wined3d_surface *surface = surface_from_resource(sub_resource);
-
-    surface_invalidate_location(surface, location);
+    wined3d_resource_invalidate_location(sub_resource, location);
 }
 
 /* Context activation is done by the caller. */
@@ -902,13 +927,11 @@ static void texture2d_prepare_texture(struct wined3d_texture *texture, struct wi
 
         if (gl_info->supported[APPLE_CLIENT_STORAGE])
         {
-            if (surface->flags & (SFLAG_NONPOW2 | SFLAG_DIBSECTION)
-                    || texture->flags & WINED3D_TEXTURE_CONVERTED
-                    || !surface->resource.heap_memory)
+            if (surface->flags & (SFLAG_NONPOW2)
+                    || texture->flags & WINED3D_TEXTURE_CONVERTED)
             {
                 /* In some cases we want to disable client storage.
                  * SFLAG_NONPOW2 has a bigger opengl texture than the client memory, and different pitches
-                 * SFLAG_DIBSECTION: Dibsections may have read / write protections on the memory. Avoid issues...
                  * WINED3D_TEXTURE_CONVERTED: The conversion destination memory is freed after loading the surface
                  * heap_memory == NULL: Not defined in the extension. Seems to disable client storage effectively
                  */
@@ -916,6 +939,8 @@ static void texture2d_prepare_texture(struct wined3d_texture *texture, struct wi
             }
             else
             {
+                wined3d_resource_prepare_system_memory(&surface->resource);
+
                 surface->flags |= SFLAG_CLIENT;
                 mem = surface->resource.heap_memory;
 
@@ -983,11 +1008,25 @@ static void wined3d_texture_unload(struct wined3d_resource *resource)
     wined3d_texture_unload_gl_texture(texture);
 }
 
+static void wined3d_texture_load_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
+/* Context activation is done by the caller. */
+static void wined3d_texture_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location)
+{
+    ERR("Should not be called on textures.\n");
+}
+
 static const struct wined3d_resource_ops texture_resource_ops =
 {
     texture_resource_incref,
     texture_resource_decref,
     wined3d_texture_unload,
+    wined3d_texture_load_location_invalidated,
+    wined3d_texture_load_location,
 };
 
 static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wined3d_resource_desc *desc,
@@ -1004,12 +1043,14 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[ARB_TEXTURE_CUBE_MAP] && desc->pool != WINED3D_POOL_SCRATCH)
     {
         WARN("(%p) : Tried to create not supported cube texture.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1019,12 +1060,14 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -1052,6 +1095,7 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
             else
             {
                 WARN("Attempted to create a NPOT cube texture (edge length %u) without GL support.\n", desc->width);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -1061,6 +1105,7 @@ static HRESULT cubetexture_init(struct wined3d_texture *texture, const struct wi
             surface_flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1123,6 +1168,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1153,6 +1199,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
                 else
                 {
                     WARN("Attempted to create a mipmapped NPOT texture without unconditional NPOT support.\n");
+                    HeapFree(GetProcessHeap(), 0, texture);
                     return WINED3DERR_INVALIDCALL;
                 }
             }
@@ -1165,12 +1212,14 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning WINED3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -1186,6 +1235,7 @@ static HRESULT texture_init(struct wined3d_texture *texture, const struct wined3
             surface_flags, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1283,9 +1333,7 @@ static void texture3d_sub_resource_cleanup(struct wined3d_resource *sub_resource
 
 static void texture3d_sub_resource_invalidate_location(struct wined3d_resource *sub_resource, DWORD location)
 {
-    struct wined3d_volume *volume = volume_from_resource(sub_resource);
-
-    wined3d_volume_invalidate_location(volume, location);
+    wined3d_resource_invalidate_location(sub_resource, location);
 }
 
 static void texture3d_prepare_texture(struct wined3d_texture *texture, struct wined3d_context *context, BOOL srgb)
@@ -1303,7 +1351,7 @@ static void texture3d_prepare_texture(struct wined3d_texture *texture, struct wi
         void *mem = NULL;
 
         if (gl_info->supported[APPLE_CLIENT_STORAGE] && !format->convert
-                && volume_prepare_system_memory(volume))
+                && wined3d_resource_prepare_system_memory(&volume->resource))
         {
             TRACE("Enabling GL_UNPACK_CLIENT_STORAGE_APPLE for volume %p\n", volume);
             gl_info->gl_ops.gl.p_glPixelStorei(GL_UNPACK_CLIENT_STORAGE_APPLE, GL_TRUE);
@@ -1348,12 +1396,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
     if (WINED3DFMT_UNKNOWN >= desc->format)
     {
         WARN("(%p) : Texture cannot be created with a format of WINED3DFMT_UNKNOWN.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
     if (!gl_info->supported[EXT_TEXTURE3D])
     {
         WARN("(%p) : Texture cannot be created - no volume texture support.\n", texture);
+        HeapFree(GetProcessHeap(), 0, texture);
         return WINED3DERR_INVALIDCALL;
     }
 
@@ -1363,12 +1413,14 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
         if (!gl_info->supported[SGIS_GENERATE_MIPMAP])
         {
             WARN("No mipmap generation support, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
         if (levels > 1)
         {
             WARN("D3DUSAGE_AUTOGENMIPMAP is set, and level count > 1, returning D3DERR_INVALIDCALL.\n");
+            HeapFree(GetProcessHeap(), 0, texture);
             return WINED3DERR_INVALIDCALL;
         }
 
@@ -1403,6 +1455,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             {
                 WARN("Attempted to create a NPOT volume texture (%u, %u, %u) without GL support.\n",
                         desc->width, desc->height, desc->depth);
+                HeapFree(GetProcessHeap(), 0, texture);
                 return WINED3DERR_INVALIDCALL;
             }
         }
@@ -1412,6 +1465,7 @@ static HRESULT volumetexture_init(struct wined3d_texture *texture, const struct
             0, device, parent, parent_ops, &texture_resource_ops)))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
+        HeapFree(GetProcessHeap(), 0, texture);
         return hr;
     }
 
@@ -1482,7 +1536,6 @@ HRESULT CDECL wined3d_texture_create(struct wined3d_device *device, const struct
     if (FAILED(hr))
     {
         WARN("Failed to initialize texture, returning %#x.\n", hr);
-        HeapFree(GetProcessHeap(), 0, object);
         return hr;
     }
 
diff --git a/dlls/wined3d/utils.c b/dlls/wined3d/utils.c
index d3fb1d6..63f5250 100644
--- a/dlls/wined3d/utils.c
+++ b/dlls/wined3d/utils.c
@@ -3160,7 +3160,7 @@ void set_texture_matrix(const struct wined3d_gl_info *gl_info, const float *smat
                 * check for pixel shaders, and the shader has to undo the default gl divide.
                 *
                 * A more serious problem occurs if the app passes 4 coordinates in, and the
-                * 4th is != 1.0(opengl default). This would have to be fixed in drawStridedSlow
+                * 4th is != 1.0(opengl default). This would have to be fixed in draw_strided_slow
                 * or a replacement shader. */
                 default:
                     mat[3] = mat[7] = mat[11] = 0; mat[15] = 1;
@@ -3428,7 +3428,7 @@ void gen_ffp_frag_op(const struct wined3d_context *context, const struct wined3d
     unsigned int i;
     DWORD ttff;
     DWORD cop, aop, carg0, carg1, carg2, aarg0, aarg1, aarg2;
-    const struct wined3d_format *rt_format = state->fb->render_targets[0]->format;
+    const struct wined3d_format *rt_format = state->fb.render_targets[0]->format;
     const struct wined3d_gl_info *gl_info = context->gl_info;
     const struct wined3d_d3d_info *d3d_info = context->d3d_info;
 
diff --git a/dlls/wined3d/vertexdeclaration.c b/dlls/wined3d/vertexdeclaration.c
index cf5378c..fc7a110 100644
--- a/dlls/wined3d/vertexdeclaration.c
+++ b/dlls/wined3d/vertexdeclaration.c
@@ -48,6 +48,12 @@ ULONG CDECL wined3d_vertex_declaration_incref(struct wined3d_vertex_declaration
     return refcount;
 }
 
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration)
+{
+    HeapFree(GetProcessHeap(), 0, declaration->elements);
+    HeapFree(GetProcessHeap(), 0, declaration);
+}
+
 ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration *declaration)
 {
     ULONG refcount = InterlockedDecrement(&declaration->ref);
@@ -56,9 +62,9 @@ ULONG CDECL wined3d_vertex_declaration_decref(struct wined3d_vertex_declaration
 
     if (!refcount)
     {
-        HeapFree(GetProcessHeap(), 0, declaration->elements);
+        const struct wined3d_device *device = declaration->device;
         declaration->parent_ops->wined3d_object_destroyed(declaration->parent);
-        HeapFree(GetProcessHeap(), 0, declaration);
+        wined3d_cs_emit_vertex_declaration_destroy(device->cs, declaration);
     }
 
     return refcount;
diff --git a/dlls/wined3d/view.c b/dlls/wined3d/view.c
index 1f8db54..f9924fb 100644
--- a/dlls/wined3d/view.c
+++ b/dlls/wined3d/view.c
@@ -33,6 +33,11 @@ ULONG CDECL wined3d_rendertarget_view_incref(struct wined3d_rendertarget_view *v
     return refcount;
 }
 
+void wined3d_rendertarget_view_destroy(struct wined3d_rendertarget_view *view)
+{
+    HeapFree(GetProcessHeap(), 0, view);
+}
+
 ULONG CDECL wined3d_rendertarget_view_decref(struct wined3d_rendertarget_view *view)
 {
     ULONG refcount = InterlockedDecrement(&view->refcount);
@@ -41,11 +46,13 @@ ULONG CDECL wined3d_rendertarget_view_decref(struct wined3d_rendertarget_view *v
 
     if (!refcount)
     {
+        struct wined3d_device *device = view->resource->device;
+
         /* Call wined3d_object_destroyed() before releasing the resource,
          * since releasing the resource may end up destroying the parent. */
         view->parent_ops->wined3d_object_destroyed(view->parent);
         wined3d_resource_decref(view->resource);
-        HeapFree(GetProcessHeap(), 0, view);
+        wined3d_cs_emit_view_destroy(device->cs, view);
     }
 
     return refcount;
diff --git a/dlls/wined3d/volume.c b/dlls/wined3d/volume.c
index 58d7321..a30acab 100644
--- a/dlls/wined3d/volume.c
+++ b/dlls/wined3d/volume.c
@@ -27,44 +27,6 @@
 WINE_DEFAULT_DEBUG_CHANNEL(d3d_surface);
 WINE_DECLARE_DEBUG_CHANNEL(d3d_perf);
 
-BOOL volume_prepare_system_memory(struct wined3d_volume *volume)
-{
-    if (volume->resource.heap_memory)
-        return TRUE;
-
-    if (!wined3d_resource_allocate_sysmem(&volume->resource))
-    {
-        ERR("Failed to allocate system memory.\n");
-        return FALSE;
-    }
-    return TRUE;
-}
-
-static void wined3d_volume_get_pitch(const struct wined3d_volume *volume, UINT *row_pitch,
-        UINT *slice_pitch)
-{
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (format->flags & WINED3DFMT_FLAG_BLOCKS)
-    {
-        /* Since compressed formats are block based, pitch means the amount of
-         * bytes to the next row of block rather than the next row of pixels. */
-        UINT row_block_count = (volume->resource.width + format->block_width - 1) / format->block_width;
-        UINT slice_block_count = (volume->resource.height + format->block_height - 1) / format->block_height;
-        *row_pitch = row_block_count * format->block_byte_count;
-        *slice_pitch = *row_pitch * slice_block_count;
-    }
-    else
-    {
-        unsigned char alignment = volume->resource.device->surface_alignment;
-        *row_pitch = format->byte_count * volume->resource.width;  /* Bytes / row */
-        *row_pitch = (*row_pitch + alignment - 1) & ~(alignment - 1);
-        *slice_pitch = *row_pitch * volume->resource.height;
-    }
-
-    TRACE("Returning row pitch %u, slice pitch %u.\n", *row_pitch, *slice_pitch);
-}
-
 /* Context activation is done by the caller. */
 void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
         const struct wined3d_bo_address *data)
@@ -95,7 +57,7 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
         dst_row_pitch = (dst_row_pitch + alignment - 1) & ~(alignment - 1);
         dst_slice_pitch = dst_row_pitch * height;
 
-        wined3d_volume_get_pitch(volume, &src_row_pitch, &src_slice_pitch);
+        wined3d_resource_get_pitch(&volume->resource, &src_row_pitch, &src_slice_pitch);
 
         mem = HeapAlloc(GetProcessHeap(), 0, dst_slice_pitch * depth);
         format->convert(data->addr, mem, src_row_pitch, src_slice_pitch,
@@ -123,20 +85,6 @@ void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wine
         HeapFree(GetProcessHeap(), 0, mem);
 }
 
-static void wined3d_volume_validate_location(struct wined3d_volume *volume, DWORD location)
-{
-    TRACE("Volume %p, setting %s.\n", volume, wined3d_debug_location(location));
-    volume->locations |= location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
-}
-
-void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location)
-{
-    TRACE("Volume %p, clearing %s.\n", volume, wined3d_debug_location(location));
-    volume->locations &= ~location;
-    TRACE("new location flags are %s.\n", wined3d_debug_location(volume->locations));
-}
-
 /* Context activation is done by the caller. */
 static void wined3d_volume_download_data(struct wined3d_volume *volume,
         const struct wined3d_context *context, const struct wined3d_bo_address *data)
@@ -172,28 +120,8 @@ static void wined3d_volume_download_data(struct wined3d_volume *volume,
 static void wined3d_volume_evict_sysmem(struct wined3d_volume *volume)
 {
     wined3d_resource_free_sysmem(&volume->resource);
-    wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_SYSMEM);
-}
-
-static DWORD volume_access_from_location(DWORD location)
-{
-    switch (location)
-    {
-        case WINED3D_LOCATION_DISCARDED:
-            return 0;
-
-        case WINED3D_LOCATION_SYSMEM:
-            return WINED3D_RESOURCE_ACCESS_CPU;
-
-        case WINED3D_LOCATION_BUFFER:
-        case WINED3D_LOCATION_TEXTURE_RGB:
-        case WINED3D_LOCATION_TEXTURE_SRGB:
-            return WINED3D_RESOURCE_ACCESS_GPU;
-
-        default:
-            FIXME("Unhandled location %#x.\n", location);
-            return 0;
-    }
+    volume->resource.map_heap_memory = NULL;
+    wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
 }
 
 /* Context activation is done by the caller. */
@@ -235,20 +163,16 @@ static BOOL wined3d_volume_can_evict(const struct wined3d_volume *volume)
 
     return TRUE;
 }
+
 /* Context activation is done by the caller. */
-static void wined3d_volume_load_location(struct wined3d_volume *volume,
+static void wined3d_volume_load_location(struct wined3d_resource *resource,
         struct wined3d_context *context, DWORD location)
 {
-    DWORD required_access = volume_access_from_location(location);
+    struct wined3d_volume *volume = volume_from_resource(resource);
+    DWORD required_access = wined3d_resource_access_from_location(location);
 
     TRACE("Volume %p, loading %s, have %s.\n", volume, wined3d_debug_location(location),
-        wined3d_debug_location(volume->locations));
-
-    if ((volume->locations & location) == location)
-    {
-        TRACE("Location(s) already up to date.\n");
-        return;
-    }
+        wined3d_debug_location(volume->resource.locations));
 
     if ((volume->resource.access_flags & required_access) != required_access)
     {
@@ -267,35 +191,35 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
                     && !(volume->container->flags & WINED3D_TEXTURE_SRGB_ALLOCATED)))
                 ERR("Trying to load (s)RGB texture without prior allocation.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & WINED3D_LOCATION_DISCARDED)
             {
                 TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
+                wined3d_resource_invalidate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
             }
-            else if (volume->locations & WINED3D_LOCATION_SYSMEM)
+            else if (volume->resource.locations & WINED3D_LOCATION_SYSMEM)
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_BUFFER)
+            else if (volume->resource.locations & WINED3D_LOCATION_BUFFER)
             {
-                struct wined3d_bo_address data = {volume->pbo, NULL};
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
                 wined3d_volume_upload_data(volume, context, &data);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, TRUE);
             }
-            else if (volume->locations & WINED3D_LOCATION_TEXTURE_SRGB)
+            else if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_SRGB)
             {
                 wined3d_volume_srgb_transfer(volume, context, FALSE);
             }
             else
             {
-                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->locations));
+                FIXME("Implement texture loading from %s.\n", wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, location);
+            wined3d_resource_validate_location(&volume->resource, location);
 
             if (wined3d_volume_can_evict(volume))
                 wined3d_volume_evict_sysmem(volume);
@@ -306,16 +230,11 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             if (!volume->resource.heap_memory)
                 ERR("Trying to load WINED3D_LOCATION_SYSMEM without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
-            {
-                TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
-            }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
                 struct wined3d_bo_address data = {0, volume->resource.heap_memory};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -326,26 +245,21 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_SYSMEM loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_SYSMEM);
             break;
 
         case WINED3D_LOCATION_BUFFER:
-            if (!volume->pbo)
+            if (!volume->resource.buffer)
                 ERR("Trying to load WINED3D_LOCATION_BUFFER without setting it up first.\n");
 
-            if (volume->locations & WINED3D_LOCATION_DISCARDED)
+            if (volume->resource.locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
             {
-                TRACE("Volume previously discarded, nothing to do.\n");
-                wined3d_volume_invalidate_location(volume, WINED3D_LOCATION_DISCARDED);
-            }
-            else if (volume->locations & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
-            {
-                struct wined3d_bo_address data = {volume->pbo, NULL};
+                struct wined3d_bo_address data = {volume->resource.buffer->name, NULL};
 
-                if (volume->locations & WINED3D_LOCATION_TEXTURE_RGB)
+                if (volume->resource.locations & WINED3D_LOCATION_TEXTURE_RGB)
                     wined3d_texture_bind_and_dirtify(volume->container, context, FALSE);
                 else
                     wined3d_texture_bind_and_dirtify(volume->container, context, TRUE);
@@ -355,15 +269,15 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
             else
             {
                 FIXME("Implement WINED3D_LOCATION_BUFFER loading from %s.\n",
-                        wined3d_debug_location(volume->locations));
+                        wined3d_debug_location(volume->resource.locations));
                 return;
             }
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
+            wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_BUFFER);
             break;
 
         default:
             FIXME("Implement %s loading from %s.\n", wined3d_debug_location(location),
-                    wined3d_debug_location(volume->locations));
+                    wined3d_debug_location(volume->resource.locations));
     }
 }
 
@@ -371,49 +285,18 @@ static void wined3d_volume_load_location(struct wined3d_volume *volume,
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context, BOOL srgb_mode)
 {
     wined3d_texture_prepare_texture(volume->container, context, srgb_mode);
-    wined3d_volume_load_location(volume, context,
+    wined3d_resource_load_location(&volume->resource, context,
             srgb_mode ? WINED3D_LOCATION_TEXTURE_SRGB : WINED3D_LOCATION_TEXTURE_RGB);
 }
 
-/* Context activation is done by the caller. */
-static void wined3d_volume_prepare_pbo(struct wined3d_volume *volume, struct wined3d_context *context)
-{
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    if (volume->pbo)
-        return;
-
-    GL_EXTCALL(glGenBuffersARB(1, &volume->pbo));
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-    GL_EXTCALL(glBufferDataARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->resource.size, NULL, GL_STREAM_DRAW_ARB));
-    GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-    checkGLcall("Create PBO");
-
-    TRACE("Created PBO %u for volume %p.\n", volume->pbo, volume);
-}
-
-static void wined3d_volume_free_pbo(struct wined3d_volume *volume)
-{
-    struct wined3d_context *context = context_acquire(volume->resource.device, NULL);
-    const struct wined3d_gl_info *gl_info = context->gl_info;
-
-    TRACE("Deleting PBO %u belonging to volume %p.\n", volume->pbo, volume);
-    GL_EXTCALL(glDeleteBuffersARB(1, &volume->pbo));
-    checkGLcall("glDeleteBuffersARB");
-    volume->pbo = 0;
-    context_release(context);
-}
-
 void wined3d_volume_destroy(struct wined3d_volume *volume)
 {
+    struct wined3d_device *device = volume->resource.device;
     TRACE("volume %p.\n", volume);
 
-    if (volume->pbo)
-        wined3d_volume_free_pbo(volume);
-
     resource_cleanup(&volume->resource);
     volume->resource.parent_ops->wined3d_object_destroyed(volume->resource.parent);
-    HeapFree(GetProcessHeap(), 0, volume);
+    wined3d_cs_emit_volume_cleanup(device->cs, volume);
 }
 
 static void volume_unload(struct wined3d_resource *resource)
@@ -427,27 +310,18 @@ static void volume_unload(struct wined3d_resource *resource)
 
     TRACE("texture %p.\n", resource);
 
-    if (volume_prepare_system_memory(volume))
+    if (wined3d_resource_prepare_system_memory(&volume->resource))
     {
         context = context_acquire(device, NULL);
-        wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_load_location(&volume->resource, context, WINED3D_LOCATION_SYSMEM);
         context_release(context);
-        wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_SYSMEM);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_SYSMEM);
     }
     else
     {
         ERR("Out of memory when unloading volume %p.\n", volume);
-        wined3d_volume_validate_location(volume, WINED3D_LOCATION_DISCARDED);
-        wined3d_volume_invalidate_location(volume, ~WINED3D_LOCATION_DISCARDED);
-    }
-
-    if (volume->pbo)
-    {
-        /* Should not happen because only dynamic default pool volumes
-         * have a buffer, and those are not evicted by device_evit_managed_resources
-         * and must be freed before a non-ex device reset. */
-        ERR("Unloading a volume with a buffer\n");
-        wined3d_volume_free_pbo(volume);
+        wined3d_resource_validate_location(&volume->resource, WINED3D_LOCATION_DISCARDED);
+        wined3d_resource_invalidate_location(&volume->resource, ~WINED3D_LOCATION_DISCARDED);
     }
 
     /* The texture name is managed by the container. */
@@ -463,6 +337,11 @@ ULONG CDECL wined3d_volume_incref(struct wined3d_volume *volume)
     return wined3d_texture_incref(volume->container);
 }
 
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume)
+{
+    HeapFree(GetProcessHeap(), 0, volume);
+}
+
 ULONG CDECL wined3d_volume_decref(struct wined3d_volume *volume)
 {
     TRACE("Forwarding to container %p.\n", volume->container);
@@ -489,34 +368,6 @@ struct wined3d_resource * CDECL wined3d_volume_get_resource(struct wined3d_volum
     return &volume->resource;
 }
 
-static BOOL volume_check_block_align(const struct wined3d_volume *volume,
-        const struct wined3d_box *box)
-{
-    UINT width_mask, height_mask;
-    const struct wined3d_format *format = volume->resource.format;
-
-    if (!box)
-        return TRUE;
-
-    /* This assumes power of two block sizes, but NPOT block sizes would be
-     * silly anyway.
-     *
-     * This also assumes that the format's block depth is 1. */
-    width_mask = format->block_width - 1;
-    height_mask = format->block_height - 1;
-
-    if (box->left & width_mask)
-        return FALSE;
-    if (box->top & height_mask)
-        return FALSE;
-    if (box->right & width_mask && box->right != volume->resource.width)
-        return FALSE;
-    if (box->bottom & height_mask && box->bottom != volume->resource.height)
-        return FALSE;
-
-    return TRUE;
-}
-
 static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *volume,
         const struct wined3d_box *box)
 {
@@ -542,145 +393,33 @@ static BOOL wined3d_volume_check_box_dimensions(const struct wined3d_volume *vol
 HRESULT CDECL wined3d_volume_map(struct wined3d_volume *volume,
         struct wined3d_map_desc *map_desc, const struct wined3d_box *box, DWORD flags)
 {
-    struct wined3d_device *device = volume->resource.device;
-    struct wined3d_context *context;
-    const struct wined3d_gl_info *gl_info;
-    BYTE *base_memory;
+    HRESULT hr;
     const struct wined3d_format *format = volume->resource.format;
 
-    TRACE("volume %p, map_desc %p, box %p, flags %#x.\n",
-            volume, map_desc, box, flags);
-
     map_desc->data = NULL;
     if (!(volume->resource.access_flags & WINED3D_RESOURCE_ACCESS_CPU))
     {
         WARN("Volume %p is not CPU accessible.\n", volume);
         return WINED3DERR_INVALIDCALL;
     }
-    if (volume->resource.map_count)
-    {
-        WARN("Volume is already mapped.\n");
-        return WINED3DERR_INVALIDCALL;
-    }
     if (!wined3d_volume_check_box_dimensions(volume, box))
     {
         WARN("Map box is invalid.\n");
         return WINED3DERR_INVALIDCALL;
     }
-    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) && !volume_check_block_align(volume, box))
+    if ((format->flags & WINED3DFMT_FLAG_BLOCKS) &&
+            !wined3d_resource_check_block_align(&volume->resource, box))
     {
         WARN("Map box is misaligned for %ux%u blocks.\n",
                 format->block_width, format->block_height);
         return WINED3DERR_INVALIDCALL;
     }
 
-    flags = wined3d_resource_sanitize_map_flags(&volume->resource, flags);
-
-    if (volume->resource.map_binding == WINED3D_LOCATION_BUFFER)
-    {
-        context = context_acquire(device, NULL);
-        gl_info = context->gl_info;
-
-        wined3d_volume_prepare_pbo(volume, context);
-        if (flags & WINED3D_MAP_DISCARD)
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_BUFFER);
-        else
-            wined3d_volume_load_location(volume, context, WINED3D_LOCATION_BUFFER);
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-
-        if (gl_info->supported[ARB_MAP_BUFFER_RANGE])
-        {
-            GLbitfield mapflags = wined3d_resource_gl_map_flags(flags);
-            mapflags &= ~GL_MAP_FLUSH_EXPLICIT_BIT;
-            base_memory = GL_EXTCALL(glMapBufferRange(GL_PIXEL_UNPACK_BUFFER_ARB,
-                    0, volume->resource.size, mapflags));
-        }
-        else
-        {
-            GLenum access = wined3d_resource_gl_legacy_map_flags(flags);
-            base_memory = GL_EXTCALL(glMapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, access));
-        }
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Map PBO");
-
-        context_release(context);
-    }
-    else
-    {
-        if (!volume_prepare_system_memory(volume))
-        {
-            WARN("Out of memory.\n");
-            map_desc->data = NULL;
-            return E_OUTOFMEMORY;
-        }
-
-        if (flags & WINED3D_MAP_DISCARD)
-        {
-            wined3d_volume_validate_location(volume, WINED3D_LOCATION_SYSMEM);
-        }
-        else if (!(volume->locations & WINED3D_LOCATION_SYSMEM))
-        {
-            context = context_acquire(device, NULL);
-            wined3d_volume_load_location(volume, context, WINED3D_LOCATION_SYSMEM);
-            context_release(context);
-        }
-        base_memory = volume->resource.heap_memory;
-    }
-
-    TRACE("Base memory pointer %p.\n", base_memory);
-
-    if (format->flags & WINED3DFMT_FLAG_BROKEN_PITCH)
-    {
-        map_desc->row_pitch = volume->resource.width * format->byte_count;
-        map_desc->slice_pitch = map_desc->row_pitch * volume->resource.height;
-    }
-    else
-    {
-        wined3d_volume_get_pitch(volume, &map_desc->row_pitch, &map_desc->slice_pitch);
-    }
-
-    if (!box)
-    {
-        TRACE("No box supplied - all is ok\n");
-        map_desc->data = base_memory;
-    }
-    else
-    {
-        TRACE("Lock Box (%p) = l %u, t %u, r %u, b %u, fr %u, ba %u\n",
-                box, box->left, box->top, box->right, box->bottom, box->front, box->back);
-
-        if ((format->flags & (WINED3DFMT_FLAG_BLOCKS | WINED3DFMT_FLAG_BROKEN_PITCH)) == WINED3DFMT_FLAG_BLOCKS)
-        {
-            /* Compressed textures are block based, so calculate the offset of
-             * the block that contains the top-left pixel of the locked rectangle. */
-            map_desc->data = base_memory
-                    + (box->front * map_desc->slice_pitch)
-                    + ((box->top / format->block_height) * map_desc->row_pitch)
-                    + ((box->left / format->block_width) * format->block_byte_count);
-        }
-        else
-        {
-            map_desc->data = base_memory
-                    + (map_desc->slice_pitch * box->front)
-                    + (map_desc->row_pitch * box->top)
-                    + (box->left * volume->resource.format->byte_count);
-        }
-    }
-
-    if (!(flags & (WINED3D_MAP_NO_DIRTY_UPDATE | WINED3D_MAP_READONLY)))
-    {
-        wined3d_texture_set_dirty(volume->container);
-        wined3d_volume_invalidate_location(volume, ~volume->resource.map_binding);
-    }
-
-    volume->resource.map_count++;
-
-    TRACE("Returning memory %p, row pitch %d, slice pitch %d.\n",
-            map_desc->data, map_desc->row_pitch, map_desc->slice_pitch);
+    hr = wined3d_resource_map(&volume->resource, map_desc, box, flags);
+    if (FAILED(hr))
+        return hr;
 
-    return WINED3D_OK;
+    return hr;
 }
 
 struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resource *resource)
@@ -690,31 +429,15 @@ struct wined3d_volume * CDECL wined3d_volume_from_resource(struct wined3d_resour
 
 HRESULT CDECL wined3d_volume_unmap(struct wined3d_volume *volume)
 {
-    TRACE("volume %p.\n", volume);
-
-    if (!volume->resource.map_count)
-    {
-        WARN("Trying to unlock an unlocked volume %p.\n", volume);
-        return WINED3DERR_INVALIDCALL;
-    }
-
-    if (volume->resource.map_binding == WINED3D_LOCATION_BUFFER)
-    {
-        struct wined3d_device *device = volume->resource.device;
-        struct wined3d_context *context = context_acquire(device, NULL);
-        const struct wined3d_gl_info *gl_info = context->gl_info;
-
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, volume->pbo));
-        GL_EXTCALL(glUnmapBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB));
-        GL_EXTCALL(glBindBufferARB(GL_PIXEL_UNPACK_BUFFER_ARB, 0));
-        checkGLcall("Unmap PBO");
-
-        context_release(context);
-    }
+    HRESULT hr;
 
-    volume->resource.map_count--;
+    if (volume->resource.unmap_dirtify)
+        wined3d_texture_set_dirty(volume->container);
 
-    return WINED3D_OK;
+    hr = wined3d_resource_unmap(&volume->resource);
+    if (hr == WINEDDERR_NOTLOCKED)
+        return WINED3DERR_INVALIDCALL;
+    return hr;
 }
 
 static ULONG volume_resource_incref(struct wined3d_resource *resource)
@@ -727,11 +450,21 @@ static ULONG volume_resource_decref(struct wined3d_resource *resource)
     return wined3d_volume_decref(volume_from_resource(resource));
 }
 
+static void wined3d_volume_location_invalidated(struct wined3d_resource *resource, DWORD location)
+{
+    struct wined3d_volume *volume = volume_from_resource(resource);
+
+    if (location & (WINED3D_LOCATION_TEXTURE_RGB | WINED3D_LOCATION_TEXTURE_SRGB))
+        wined3d_texture_set_dirty(volume->container);
+}
+
 static const struct wined3d_resource_ops volume_resource_ops =
 {
     volume_resource_incref,
     volume_resource_decref,
     volume_unload,
+    wined3d_volume_location_invalidated,
+    wined3d_volume_load_location,
 };
 
 static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture *container,
@@ -768,7 +501,7 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     }
 
     volume->texture_level = level;
-    volume->locations = WINED3D_LOCATION_DISCARDED;
+    volume->resource.locations = WINED3D_LOCATION_DISCARDED;
 
     if (desc->pool == WINED3D_POOL_DEFAULT && desc->usage & WINED3DUSAGE_DYNAMIC
             && gl_info->supported[ARB_PIXEL_BUFFER_OBJECT]
@@ -776,6 +509,7 @@ static HRESULT volume_init(struct wined3d_volume *volume, struct wined3d_texture
     {
         wined3d_resource_free_sysmem(&volume->resource);
         volume->resource.map_binding = WINED3D_LOCATION_BUFFER;
+        volume->resource.map_heap_memory = NULL;
     }
 
     volume->container = container;
diff --git a/dlls/wined3d/wined3d.spec b/dlls/wined3d/wined3d.spec
index 7a77003..95885c7 100644
--- a/dlls/wined3d/wined3d.spec
+++ b/dlls/wined3d/wined3d.spec
@@ -181,6 +181,7 @@
 
 @ cdecl wined3d_resource_get_desc(ptr ptr)
 @ cdecl wined3d_resource_get_parent(ptr)
+@ cdecl wined3d_resource_get_pitch(ptr ptr ptr)
 @ cdecl wined3d_resource_get_priority(ptr)
 @ cdecl wined3d_resource_set_parent(ptr ptr)
 @ cdecl wined3d_resource_set_priority(ptr long)
@@ -226,7 +227,6 @@
 @ cdecl wined3d_surface_get_flip_status(ptr long)
 @ cdecl wined3d_surface_get_overlay_position(ptr ptr ptr)
 @ cdecl wined3d_surface_get_parent(ptr)
-@ cdecl wined3d_surface_get_pitch(ptr)
 @ cdecl wined3d_surface_get_render_target_data(ptr ptr)
 @ cdecl wined3d_surface_get_resource(ptr)
 @ cdecl wined3d_surface_getdc(ptr ptr)
diff --git a/dlls/wined3d/wined3d_main.c b/dlls/wined3d/wined3d_main.c
index 758ba43..a1e4e6c 100644
--- a/dlls/wined3d/wined3d_main.c
+++ b/dlls/wined3d/wined3d_main.c
@@ -85,6 +85,8 @@ struct wined3d_settings wined3d_settings =
     ~0U,            /* No GS shader model limit by default. */
     ~0U,            /* No PS shader model limit by default. */
     FALSE,          /* 3D support enabled by default. */
+    FALSE,          /* No multithreaded CS by default. */
+    FALSE,          /* Do not ignore render target maps. */
 };
 
 struct wined3d * CDECL wined3d_create(DWORD flags)
@@ -304,6 +306,18 @@ static BOOL wined3d_dll_init(HINSTANCE hInstDLL)
             TRACE("Disabling 3D support.\n");
             wined3d_settings.no_3d = TRUE;
         }
+        if (!get_config_key(hkey, appkey, "CSMT", buffer, size)
+                && !strcmp(buffer,"enabled"))
+        {
+            TRACE("Enabling multithreaded command stream.\n");
+            wined3d_settings.cs_multithreaded = TRUE;
+        }
+        if (!get_config_key(hkey, appkey, "ignore_rt_map", buffer, size)
+                && !strcmp(buffer,"enabled"))
+        {
+            TRACE("Ignoring render target maps.\n");
+            wined3d_settings.ignore_rt_map = TRUE;
+        }
     }
 
     if (appkey) RegCloseKey( appkey );
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 4210d26..fef0ed2 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -5,7 +5,7 @@
  * Copyright 2002-2003 Raphael Junqueira
  * Copyright 2002-2003, 2004 Jason Edmeades
  * Copyright 2005 Oliver Stieber
- * Copyright 2006-2011, 2013 Stefan Dösinger for CodeWeavers
+ * Copyright 2006-2011, 2013-2014 Stefan Dösinger for CodeWeavers
  *
  * This library is free software; you can redistribute it and/or
  * modify it under the terms of the GNU Lesser General Public
@@ -31,6 +31,7 @@
 #define WINE_GLAPI
 #endif
 
+#include <assert.h>
 #include <stdarg.h>
 #include <math.h>
 #include <limits.h>
@@ -279,6 +280,8 @@ struct wined3d_settings
     unsigned int max_sm_gs;
     unsigned int max_sm_ps;
     BOOL no_3d;
+    BOOL cs_multithreaded;
+    BOOL ignore_rt_map;
 };
 
 extern struct wined3d_settings wined3d_settings DECLSPEC_HIDDEN;
@@ -547,6 +550,7 @@ enum WINED3D_SHADER_INSTRUCTION_HANDLER
     WINED3DSIH_TEXREG2GB,
     WINED3DSIH_TEXREG2RGB,
     WINED3DSIH_UDIV,
+    WINED3DSIH_UGE,
     WINED3DSIH_USHR,
     WINED3DSIH_UTOF,
     WINED3DSIH_XOR,
@@ -950,8 +954,9 @@ struct wined3d_stream_info
     WORD use_map; /* MAX_ATTRIBS, 16 */
 };
 
-void draw_primitive(struct wined3d_device *device, UINT start_idx, UINT index_count,
-        UINT start_instance, UINT instance_count, BOOL indexed) DECLSPEC_HIDDEN;
+void draw_primitive(struct wined3d_device *device, const struct wined3d_state *state,
+        UINT start_idx, UINT index_count, UINT start_instance, UINT instance_count,
+        BOOL indexed) DECLSPEC_HIDDEN;
 DWORD get_flexible_vertex_size(DWORD d3dvtVertexType) DECLSPEC_HIDDEN;
 
 #define eps 1e-8f
@@ -1033,6 +1038,8 @@ struct wined3d_occlusion_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+    DWORD samples;
+    BOOL started;
 };
 
 union wined3d_gl_query_object
@@ -1068,11 +1075,42 @@ struct wined3d_timestamp_query
     struct list entry;
     GLuint id;
     struct wined3d_context *context;
+    UINT64 timestamp;
 };
 
 void context_alloc_timestamp_query(struct wined3d_context *context, struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 void context_free_timestamp_query(struct wined3d_timestamp_query *query) DECLSPEC_HIDDEN;
 
+struct wined3d_fb_state
+{
+    struct wined3d_rendertarget_view **render_targets;
+    struct wined3d_rendertarget_view *depth_stencil;
+    UINT rt_size;
+};
+
+static inline BOOL wined3d_fb_equal(const struct wined3d_fb_state *fb1, const struct wined3d_fb_state *fb2)
+{
+    UINT i;
+
+    if (fb1->depth_stencil != fb2->depth_stencil)
+        return FALSE;
+    if (fb1->rt_size != fb2->rt_size)
+        return FALSE;
+    for (i = 0; i < fb1->rt_size; i++)
+        if (fb1->render_targets[i] != fb2->render_targets[i])
+            return FALSE;
+    return TRUE;
+}
+
+static inline void wined3d_fb_copy(struct wined3d_fb_state *dst, const struct wined3d_fb_state *src)
+{
+    UINT i;
+
+    dst->depth_stencil = src->depth_stencil;
+    for (i = 0; i < min(dst->rt_size, src->rt_size); i++)
+        dst->render_targets[i] = src->render_targets[i];
+}
+
 struct wined3d_context
 {
     const struct wined3d_gl_info *gl_info;
@@ -1087,6 +1125,7 @@ struct wined3d_context
     DWORD                   dirtyArray[STATE_HIGHEST + 1]; /* Won't get bigger than that, a state is never marked dirty 2 times */
     DWORD                   numDirtyEntries;
     DWORD isStateDirty[STATE_HIGHEST / (sizeof(DWORD) * CHAR_BIT) + 1]; /* Bitmap to find out quickly if a state is dirty */
+    struct wined3d_fb_state current_fb;
 
     struct wined3d_swapchain *swapchain;
     struct wined3d_surface *current_rt;
@@ -1184,12 +1223,8 @@ struct wined3d_context
     GLfloat                 fog_coord_value;
     GLfloat                 color[4], fogstart, fogend, fogcolor[4];
     GLuint                  dummy_arbfp_prog;
-};
 
-struct wined3d_fb_state
-{
-    struct wined3d_rendertarget_view **render_targets;
-    struct wined3d_rendertarget_view *depth_stencil;
+    GLenum                  offscreenBuffer;
 };
 
 typedef void (*APPLYSTATEFUNC)(struct wined3d_context *ctx, const struct wined3d_state *state, DWORD state_id);
@@ -1317,7 +1352,8 @@ void context_alloc_occlusion_query(struct wined3d_context *context,
 void context_apply_blit_state(struct wined3d_context *context, const struct wined3d_device *device) DECLSPEC_HIDDEN;
 BOOL context_apply_clear_state(struct wined3d_context *context, const struct wined3d_device *device,
         UINT rt_count, const struct wined3d_fb_state *fb) DECLSPEC_HIDDEN;
-BOOL context_apply_draw_state(struct wined3d_context *context, struct wined3d_device *device) DECLSPEC_HIDDEN;
+BOOL context_apply_draw_state(struct wined3d_context *context, const struct wined3d_device *device,
+        const struct wined3d_state *state) DECLSPEC_HIDDEN;
 void context_apply_fbo_state_blit(struct wined3d_context *context, GLenum target,
         struct wined3d_surface *render_target, struct wined3d_surface *depth_stencil, DWORD location) DECLSPEC_HIDDEN;
 void context_active_texture(struct wined3d_context *context, const struct wined3d_gl_info *gl_info,
@@ -1523,6 +1559,7 @@ enum wined3d_pci_device
     CARD_NVIDIA_GEFORCE_GTX770      = 0x1184,
     CARD_NVIDIA_GEFORCE_GTX780      = 0x1004,
     CARD_NVIDIA_GEFORCE_GTX780TI    = 0x100a,
+    CARD_NVIDIA_GEFORCE_GTX970      = 0x13c2,
 
     CARD_VMWARE_SVGA3D              = 0x0405,
 
@@ -1865,7 +1902,7 @@ struct wined3d_stream_state
 struct wined3d_state
 {
     DWORD flags;
-    const struct wined3d_fb_state *fb;
+    struct wined3d_fb_state fb;
 
     struct wined3d_vertex_declaration *vertex_declaration;
     struct wined3d_stream_output stream_output[MAX_STREAM_OUT];
@@ -1910,6 +1947,14 @@ struct wined3d_state
     DWORD render_states[WINEHIGHEST_RENDER_STATE + 1];
 };
 
+struct wined3d_gl_bo
+{
+    GLuint name;
+    GLenum usage;
+    GLenum type_hint;
+    UINT size;
+};
+
 #define WINED3D_UNMAPPED_STAGE ~0U
 
 /* Multithreaded flag. Removed from the public header to signal that
@@ -1965,15 +2010,11 @@ struct wined3d_device
     struct wined3d_rendertarget_view *back_buffer_view;
     struct wined3d_swapchain **swapchains;
     UINT swapchain_count;
+    struct wined3d_rendertarget_view *auto_depth_stencil_view;
 
     struct list             resources; /* a linked list to track resources created by the device */
     struct list             shaders;   /* a linked list to track shaders (pixel and vertex)      */
 
-    /* Render Target Support */
-    struct wined3d_fb_state fb;
-    struct wined3d_surface *onscreen_depth_stencil;
-    struct wined3d_rendertarget_view *auto_depth_stencil_view;
-
     /* For rendering to a texture using glCopyTexImage */
     GLuint                  depth_blt_texture;
 
@@ -1983,7 +2024,6 @@ struct wined3d_device
     UINT                    xScreenSpace;
     UINT                    yScreenSpace;
     UINT                    cursorWidth, cursorHeight;
-    struct wined3d_texture *cursor_texture;
     HCURSOR                 hardwareCursor;
 
     /* The Wine logo texture */
@@ -2015,9 +2055,17 @@ LRESULT device_process_message(struct wined3d_device *device, HWND window, BOOL
         UINT message, WPARAM wparam, LPARAM lparam, WNDPROC proc) DECLSPEC_HIDDEN;
 void device_resource_add(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void device_resource_released(struct wined3d_device *device, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
-void device_switch_onscreen_ds(struct wined3d_device *device, struct wined3d_context *context,
-        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 void device_invalidate_state(const struct wined3d_device *device, DWORD state) DECLSPEC_HIDDEN;
+void device_invalidate_shader_constants(const struct wined3d_device *device, DWORD mask) DECLSPEC_HIDDEN;
+void device_exec_update_texture(struct wined3d_context *context, struct wined3d_texture *src_texture,
+        struct wined3d_texture *dst_texture) DECLSPEC_HIDDEN;
+struct wined3d_gl_bo *wined3d_device_get_bo(struct wined3d_device *device, UINT size, GLenum gl_usage,
+        GLenum type_hint, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_device_release_bo(struct wined3d_device *device, struct wined3d_gl_bo *bo,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_create_dummy_textures(struct wined3d_device *device, struct wined3d_context *context) DECLSPEC_HIDDEN;
+void device_delete_opengl_contexts_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 static inline BOOL isStateDirty(const struct wined3d_context *context, DWORD state)
 {
@@ -2041,6 +2089,9 @@ struct wined3d_resource_ops
     ULONG (*resource_incref)(struct wined3d_resource *resource);
     ULONG (*resource_decref)(struct wined3d_resource *resource);
     void (*resource_unload)(struct wined3d_resource *resource);
+    void (*resource_location_invalidated)(struct wined3d_resource *resource, DWORD location);
+    void (*resource_load_location)(struct wined3d_resource *resource,
+            struct wined3d_context *context, DWORD location);
 };
 
 struct wined3d_resource
@@ -2063,8 +2114,13 @@ struct wined3d_resource
     UINT depth;
     UINT size;
     DWORD priority;
-    void *heap_memory;
+    void *heap_memory, *map_heap_memory, *user_memory, *bitmap_data;
+    struct wined3d_gl_bo *buffer, *map_buffer;
+    UINT custom_row_pitch, custom_slice_pitch;
     struct list resource_list_entry;
+    DWORD locations;
+    LONG access_fence;
+    BOOL unmap_dirtify;
 
     void *parent;
     const struct wined3d_parent_ops *parent_ops;
@@ -2089,13 +2145,52 @@ HRESULT resource_init(struct wined3d_resource *resource, struct wined3d_device *
         void *parent, const struct wined3d_parent_ops *parent_ops,
         const struct wined3d_resource_ops *resource_ops) DECLSPEC_HIDDEN;
 void resource_unload(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+DWORD wined3d_resource_access_from_location(DWORD location) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_allocate_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_changed(struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_check_block_align(const struct wined3d_resource *resource,
+        const struct wined3d_box *box) DECLSPEC_HIDDEN;
+void wined3d_resource_cleanup_cs(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_free_bo(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_resource_free_sysmem(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+BYTE *wined3d_resource_get_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context, DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_resource_get_memory(const struct wined3d_resource *resource,
+        DWORD location, struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
 GLbitfield wined3d_resource_gl_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
-GLenum wined3d_resource_gl_legacy_map_flags(DWORD d3d_flags) DECLSPEC_HIDDEN;
+void wined3d_resource_invalidate_location(struct wined3d_resource *resource, DWORD location) DECLSPEC_HIDDEN;
 BOOL wined3d_resource_is_offscreen(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_load_location(struct wined3d_resource *resource,
+        struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_map(struct wined3d_resource *resource, struct wined3d_map_desc *map_desc,
+        const struct wined3d_box *box, DWORD flags) DECLSPEC_HIDDEN;
+void *wined3d_resource_map_internal(struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_map_memory(struct wined3d_resource *resource,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+BOOL wined3d_resource_prepare_system_memory(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_release_map_ptr(const struct wined3d_resource *resource,
+        const struct wined3d_context *context) DECLSPEC_HIDDEN;
 DWORD wined3d_resource_sanitize_map_flags(const struct wined3d_resource *resource, DWORD flags) DECLSPEC_HIDDEN;
+HRESULT wined3d_resource_unmap(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_unmap_internal(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
 void wined3d_resource_update_draw_binding(struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_resource_validate_location(struct wined3d_resource *resource, DWORD location) DECLSPEC_HIDDEN;
+
+static inline void wined3d_resource_inc_fence(struct wined3d_resource *resource)
+{
+    InterlockedIncrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_dec_fence(struct wined3d_resource *resource)
+{
+    InterlockedDecrement(&resource->access_fence);
+}
+
+static inline void wined3d_resource_wait_fence(struct wined3d_resource *resource)
+{
+    while(InterlockedCompareExchange(&resource->access_fence, 0, 0));
+}
 
 /* Tests show that the start address of resources is 32 byte aligned */
 #define RESOURCE_ALIGNMENT 16
@@ -2186,6 +2281,7 @@ static inline struct gl_texture *wined3d_texture_get_gl_texture(struct wined3d_t
 void wined3d_texture_apply_state_changes(struct wined3d_texture *texture,
         const DWORD samplerStates[WINED3D_HIGHEST_SAMPLER_STATE + 1],
         const struct wined3d_gl_info *gl_info) DECLSPEC_HIDDEN;
+void wined3d_texture_cleanup_cs(struct wined3d_texture *texture) DECLSPEC_HIDDEN;
 void wined3d_texture_bind(struct wined3d_texture *texture,
         struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void wined3d_texture_bind_and_dirtify(struct wined3d_texture *texture,
@@ -2219,10 +2315,9 @@ struct wined3d_volume
     struct wined3d_resource resource;
     struct wined3d_texture *container;
 
-    DWORD flags, locations;
+    DWORD flags;
     GLint texture_level;
     DWORD download_count;
-    GLuint pbo;
 };
 
 static inline struct wined3d_volume *volume_from_resource(struct wined3d_resource *resource)
@@ -2230,20 +2325,18 @@ static inline struct wined3d_volume *volume_from_resource(struct wined3d_resourc
     return CONTAINING_RECORD(resource, struct wined3d_volume, resource);
 }
 
-BOOL volume_prepare_system_memory(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
 HRESULT wined3d_volume_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
         unsigned int level, struct wined3d_volume **volume) DECLSPEC_HIDDEN;
 void wined3d_volume_destroy(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
 void wined3d_volume_load(struct wined3d_volume *volume, struct wined3d_context *context,
         BOOL srgb_mode) DECLSPEC_HIDDEN;
-void wined3d_volume_invalidate_location(struct wined3d_volume *volume, DWORD location) DECLSPEC_HIDDEN;
 void wined3d_volume_upload_data(struct wined3d_volume *volume, const struct wined3d_context *context,
         const struct wined3d_bo_address *data) DECLSPEC_HIDDEN;
+void wined3d_volume_cleanup_cs(struct wined3d_volume *volume) DECLSPEC_HIDDEN;
 
 struct wined3d_surface_dib
 {
     HBITMAP DIBsection;
-    void *bitmap_data;
     UINT bitmap_size;
 };
 
@@ -2269,7 +2362,7 @@ struct fbo_entry
 struct wined3d_surface_ops
 {
     HRESULT (*surface_private_setup)(struct wined3d_surface *surface);
-    void (*surface_unmap)(struct wined3d_surface *surface);
+    void (*surface_frontbuffer_updated)(struct wined3d_surface *surface);
 };
 
 struct wined3d_surface
@@ -2277,17 +2370,12 @@ struct wined3d_surface
     struct wined3d_resource resource;
     const struct wined3d_surface_ops *surface_ops;
     struct wined3d_texture *container;
-    void *user_memory;
-    DWORD locations;
 
     DWORD flags;
 
-    UINT pitch;
     UINT pow2Width;
     UINT pow2Height;
 
-    /* PBO */
-    GLuint                    pbo;
     GLuint rb_multisample;
     GLuint rb_resolved;
     GLenum texture_target;
@@ -2333,12 +2421,10 @@ HRESULT surface_color_fill(struct wined3d_surface *s,
 GLenum surface_get_gl_buffer(const struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 void surface_get_drawable_size(const struct wined3d_surface *surface, const struct wined3d_context *context,
         unsigned int *width, unsigned int *height) DECLSPEC_HIDDEN;
-void surface_invalidate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
-void surface_load(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
+void surface_load(struct wined3d_surface *surface, struct wined3d_context *context, BOOL srgb) DECLSPEC_HIDDEN;
 void surface_load_ds_location(struct wined3d_surface *surface,
         struct wined3d_context *context, DWORD location) DECLSPEC_HIDDEN;
 void surface_load_fb_texture(struct wined3d_surface *surface, BOOL srgb) DECLSPEC_HIDDEN;
-HRESULT surface_load_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 void surface_modify_ds_location(struct wined3d_surface *surface, DWORD location, UINT w, UINT h) DECLSPEC_HIDDEN;
 void surface_prepare_rb(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info, BOOL multisample) DECLSPEC_HIDDEN;
@@ -2350,16 +2436,21 @@ HRESULT wined3d_surface_update_desc(struct wined3d_surface *surface,
         const struct wined3d_gl_info *gl_info, void *mem, unsigned int pitch) DECLSPEC_HIDDEN;
 HRESULT surface_upload_from_surface(struct wined3d_surface *dst_surface, const POINT *dst_point,
         struct wined3d_surface *src_surface, const RECT *src_rect) DECLSPEC_HIDDEN;
-void surface_validate_location(struct wined3d_surface *surface, DWORD location) DECLSPEC_HIDDEN;
 HRESULT wined3d_surface_create(struct wined3d_texture *container, const struct wined3d_resource_desc *desc,
         GLenum target, unsigned int level, unsigned int layer, DWORD flags,
         struct wined3d_surface **surface) DECLSPEC_HIDDEN;
 void wined3d_surface_destroy(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
-void surface_prepare_map_memory(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void surface_blt_ugly(struct wined3d_surface *dst_surface, const RECT *dst_rect_in,
+        struct wined3d_surface *src_surface, const RECT *src_rect_in, DWORD flags,
+        const WINEDDBLTFX *fx, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+BOOL surface_check_block_align(struct wined3d_surface *surface, const RECT *rect) DECLSPEC_HIDDEN;
+void wined3d_surface_cleanup_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_getdc_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_surface_releasedc_cs(struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 
 void draw_textured_quad(const struct wined3d_surface *src_surface, struct wined3d_context *context,
         const RECT *src_rect, const RECT *dst_rect, enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
-void flip_surface(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
+void surface_flip(struct wined3d_surface *front, struct wined3d_surface *back) DECLSPEC_HIDDEN;
 
 /* Surface flags: */
 #define SFLAG_DIBSECTION        0x00000001 /* Has a DIB section attached for GetDC. */
@@ -2402,6 +2493,8 @@ struct wined3d_vertex_declaration
     BOOL half_float_conv_needed;
 };
 
+void wined3d_vertex_declaration_destroy(struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+
 struct wined3d_saved_states
 {
     DWORD transform[(HIGHEST_TRANSFORMSTATE >> 5) + 1];
@@ -2469,30 +2562,56 @@ struct wined3d_stateblock
 void stateblock_init_contained_states(struct wined3d_stateblock *stateblock) DECLSPEC_HIDDEN;
 
 void state_cleanup(struct wined3d_state *state) DECLSPEC_HIDDEN;
-HRESULT state_init(struct wined3d_state *state, struct wined3d_fb_state *fb,
-        const struct wined3d_gl_info *gl_info, const struct wined3d_d3d_info *d3d_info,
-        DWORD flags) DECLSPEC_HIDDEN;
+HRESULT state_init(struct wined3d_state *state, const struct wined3d_gl_info *gl_info,
+        const struct wined3d_d3d_info *d3d_info, DWORD flags) DECLSPEC_HIDDEN;
 void state_unbind_resources(struct wined3d_state *state) DECLSPEC_HIDDEN;
 
+struct wined3d_cs_list
+{
+    struct list blocks;
+};
+
+#define WINED3D_CS_QUEUE_SIZE 0x100000
+#define WINED3D_CS_SPIN_COUNT 10000000
+
+struct wined3d_cs_queue
+{
+    LONG head, tail;
+    BYTE data[WINED3D_CS_QUEUE_SIZE];
+};
+
 struct wined3d_cs_ops
 {
     void *(*require_space)(struct wined3d_cs *cs, size_t size);
-    void (*submit)(struct wined3d_cs *cs);
+    void *(*require_space_prio)(struct wined3d_cs *cs, size_t size);
+    void (*submit)(struct wined3d_cs *cs, size_t size);
+    void (*submit_prio)(struct wined3d_cs *cs, size_t size);
+    void (*finish)(struct wined3d_cs *cs);
+    void (*finish_prio)(struct wined3d_cs *cs);
 };
 
 struct wined3d_cs
 {
     const struct wined3d_cs_ops *ops;
     struct wined3d_device *device;
-    struct wined3d_fb_state fb;
     struct wined3d_state state;
+    HANDLE thread;
+    DWORD thread_id;
+    struct wined3d_surface *onscreen_depth_stencil;
 
-    size_t data_size;
-    void *data;
+    struct wined3d_cs_queue queue, prio_queue;
+
+    LONG pending_presents;
+    struct list query_poll_list;
+
+    HANDLE event;
+    BOOL waiting_for_event;
 };
 
 struct wined3d_cs *wined3d_cs_create(struct wined3d_device *device) DECLSPEC_HIDDEN;
 void wined3d_cs_destroy(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_switch_onscreen_ds(struct wined3d_cs *cs, struct wined3d_context *context,
+        struct wined3d_surface *depth_stencil) DECLSPEC_HIDDEN;
 
 void wined3d_cs_emit_clear(struct wined3d_cs *cs, DWORD rect_count, const RECT *rects,
         DWORD flags, const struct wined3d_color *color, float depth, DWORD stencil) DECLSPEC_HIDDEN;
@@ -2540,6 +2659,65 @@ void wined3d_cs_emit_set_transform(struct wined3d_cs *cs, enum wined3d_transform
 void wined3d_cs_emit_set_vertex_declaration(struct wined3d_cs *cs,
         struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
 void wined3d_cs_emit_set_viewport(struct wined3d_cs *cs, const struct wined3d_viewport *viewport) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_f(struct wined3d_cs *cs, UINT start_register, const float *constants,
+        UINT vector4f_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_b(struct wined3d_cs *cs, UINT start_register,
+        const BOOL *constants, UINT bool_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_consts_i(struct wined3d_cs *cs, UINT start_register,
+        const int *constants, UINT vector4i_count, enum wined3d_shader_type type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_glfinish(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_base_vertex_index(struct wined3d_cs *cs,
+        UINT base_vertex_index) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_primitive_type(struct wined3d_cs *cs,
+        GLenum primitive_type) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light(struct wined3d_cs *cs, const struct wined3d_light_info *light) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_set_light_enable(struct wined3d_cs *cs, UINT idx, BOOL enable) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_blt(struct wined3d_cs *cs, struct wined3d_surface *dst_surface,
+        const RECT *dst_rect, struct wined3d_surface *src_surface,
+        const RECT *src_rect, DWORD flags, const WINEDDBLTFX *fx,
+        enum wined3d_texture_filter_type filter) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_clear_rtv(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view,
+        const RECT *rect, const struct wined3d_color *color) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_changed(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        struct wined3d_gl_bo *swap_buffer, void *swap_heap_memory) DECLSPEC_HIDDEN;
+void *wined3d_cs_emit_resource_map(struct wined3d_cs *cs, struct wined3d_resource *resource,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_unmap(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_issue(struct wined3d_cs *cs, struct wined3d_query *query,
+        DWORD flags) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_get_data(struct wined3d_cs *cs, struct wined3d_query *query, void *data,
+        UINT data_size, DWORD flags, HRESULT *ret) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_query_destroy(struct wined3d_cs *cs, struct wined3d_query *query) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_surface(struct wined3d_cs *cs, struct wined3d_surface *src,
+        const RECT *src_rect, struct wined3d_surface *dst, const POINT *dst_point) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_preload(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_preload(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_update_texture(struct wined3d_cs *cs, struct wined3d_texture *src,
+        struct wined3d_texture *dst) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_evict_resource(struct wined3d_cs *cs, struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_swap_mem(struct wined3d_cs *cs, struct wined3d_buffer *buffer,
+        BYTE *mem) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_invalidate_bo_range(struct wined3d_cs *cs,
+        struct wined3d_buffer *buffer, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_preload(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_view_destroy(struct wined3d_cs *cs, struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_vertex_declaration_destroy(struct wined3d_cs *cs,
+        struct wined3d_vertex_declaration *declaration) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_shader_cleanup(struct wined3d_cs *cs, struct wined3d_shader *shader) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_vbo(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_resource_cleanup(struct wined3d_cs *cs,
+        struct wined3d_resource *resource) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_buffer_cleanup(struct wined3d_cs *cs, struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_volume_cleanup(struct wined3d_cs *cs, struct wined3d_volume *volume) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_surface_cleanup(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_texture_cleanup(struct wined3d_cs *cs, struct wined3d_texture *texture) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_create_dummy_textures(struct wined3d_cs *cs) DECLSPEC_HIDDEN;
+HRESULT wined3d_cs_emit_create_swapchain_context(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_delete_opengl_contexts(struct wined3d_cs *cs,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_getdc(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
+void wined3d_cs_emit_releasedc(struct wined3d_cs *cs, struct wined3d_surface *surface) DECLSPEC_HIDDEN;
 
 /* Direct3D terminology with little modifications. We do not have an issued state
  * because only the driver knows about it, but we have a created state because d3d
@@ -2554,7 +2732,8 @@ enum query_state {
 struct wined3d_query_ops
 {
     HRESULT (*query_get_data)(struct wined3d_query *query, void *data, DWORD data_size, DWORD flags);
-    HRESULT (*query_issue)(struct wined3d_query *query, DWORD flags);
+    BOOL (*query_poll)(struct wined3d_query *query);
+    BOOL (*query_issue)(struct wined3d_query *query, DWORD flags);
 };
 
 struct wined3d_query
@@ -2568,8 +2747,13 @@ struct wined3d_query
     enum wined3d_query_type type;
     DWORD data_size;
     void                     *extendedData;
+
+    LONG                     counter_main, counter_retrieved;
+    struct list              poll_list_entry;
 };
 
+void wined3d_query_destroy(struct wined3d_query *query) DECLSPEC_HIDDEN;
+
 /* TODO: Add tests and support for FLOAT16_4 POSITIONT, D3DCOLOR position, other
  * fixed function semantics as D3DCOLOR or FLOAT16 */
 enum wined3d_buffer_conversion_type
@@ -2595,6 +2779,7 @@ struct wined3d_buffer
     GLenum buffer_object_usage;
     GLenum buffer_type_hint;
     DWORD flags;
+    BOOL ignore_discard;
     void *map_ptr;
 
     struct wined3d_map_range *maps;
@@ -2619,7 +2804,11 @@ void buffer_get_memory(struct wined3d_buffer *buffer, struct wined3d_context *co
 BYTE *buffer_get_sysmem(struct wined3d_buffer *This, struct wined3d_context *context) DECLSPEC_HIDDEN;
 void buffer_internal_preload(struct wined3d_buffer *buffer, struct wined3d_context *context,
         const struct wined3d_state *state) DECLSPEC_HIDDEN;
-void buffer_mark_used(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
+void buffer_invalidate_bo_range(struct wined3d_buffer *This, UINT offset, UINT size) DECLSPEC_HIDDEN;
+void buffer_swap_mem(struct wined3d_buffer *buffer, BYTE *mem) DECLSPEC_HIDDEN;
+void buffer_create_buffer_object(struct wined3d_buffer *This,
+        struct wined3d_context *context) DECLSPEC_HIDDEN;
+void wined3d_buffer_cleanup_cs(struct wined3d_buffer *buffer) DECLSPEC_HIDDEN;
 
 struct wined3d_rendertarget_view
 {
@@ -2657,6 +2846,8 @@ static inline struct wined3d_surface *wined3d_rendertarget_view_get_surface(
     return surface_from_resource(resource);
 }
 
+void wined3d_rendertarget_view_destroy(struct wined3d_rendertarget_view *view) DECLSPEC_HIDDEN;
+
 struct wined3d_shader_resource_view
 {
     LONG refcount;
@@ -2668,7 +2859,8 @@ struct wined3d_shader_resource_view
 struct wined3d_swapchain_ops
 {
     void (*swapchain_present)(struct wined3d_swapchain *swapchain, const RECT *src_rect,
-            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags);
+            const RECT *dst_rect, const RGNDATA *dirty_region, DWORD flags,
+            struct wined3d_surface *depth_stencil);
 };
 
 struct wined3d_swapchain
@@ -2682,9 +2874,9 @@ struct wined3d_swapchain
     struct wined3d_texture **back_buffers;
     struct wined3d_texture *front_buffer;
     struct wined3d_swapchain_desc desc;
-    struct wined3d_display_mode original_mode;
+    struct wined3d_display_mode original_mode, d3d_mode;
     struct wined3d_gamma_ramp orig_gamma;
-    BOOL render_to_fbo;
+    BOOL render_to_fbo, reapply_mode;
     const struct wined3d_format *ds_format;
     struct wined3d_palette *palette;
 
@@ -2702,11 +2894,14 @@ struct wined3d_swapchain
 
 void x11_copy_to_screen(const struct wined3d_swapchain *swapchain, const RECT *rect) DECLSPEC_HIDDEN;
 
+void wined3d_swapchain_activate(struct wined3d_swapchain *swapchain, BOOL activate) DECLSPEC_HIDDEN;
 struct wined3d_context *swapchain_get_context(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_destroy_contexts(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 HDC swapchain_get_backup_dc(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_draw_bindings(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 void swapchain_update_render_to_fbo(struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
+HRESULT swapchain_create_context_cs(struct wined3d_device *device,
+        struct wined3d_swapchain *swapchain) DECLSPEC_HIDDEN;
 
 /*****************************************************************************
  * Utility function prototypes
@@ -2926,6 +3121,7 @@ unsigned int shader_find_free_input_register(const struct wined3d_shader_reg_map
 void shader_generate_main(const struct wined3d_shader *shader, struct wined3d_shader_buffer *buffer,
         const struct wined3d_shader_reg_maps *reg_maps, const DWORD *byte_code, void *backend_ctx) DECLSPEC_HIDDEN;
 BOOL shader_match_semantic(const char *semantic_name, enum wined3d_decl_usage usage) DECLSPEC_HIDDEN;
+void shader_cleanup(struct wined3d_shader *shader) DECLSPEC_HIDDEN;
 
 static inline BOOL shader_is_scalar(const struct wined3d_shader_register *reg)
 {
diff --git a/dlls/winemapi/main.c b/dlls/winemapi/main.c
index 8cd6b6d..b627d49 100644
--- a/dlls/winemapi/main.c
+++ b/dlls/winemapi/main.c
@@ -100,7 +100,7 @@ ULONG WINAPI MAPIResolveName(LHANDLE session, ULONG_PTR uiparam, LPSTR name,
     TRACE("(0x%08lx 0x%08lx %s 0x%08x 0x%08x %p)\n", session, uiparam,
           debugstr_a(name), flags, reserved, recip);
 
-    if (!name || !strlen(name))
+    if (!name || !name[0])
         return MAPI_E_FAILURE;
 
     scode = MAPIAllocateBuffer(sizeof(**recip) + sizeof(smtp) + strlen(name),
diff --git a/dlls/winex11.drv/opengl.c b/dlls/winex11.drv/opengl.c
index cf5d440..6f0fddf 100644
--- a/dlls/winex11.drv/opengl.c
+++ b/dlls/winex11.drv/opengl.c
@@ -1990,6 +1990,7 @@ static void wglFinish(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+    ERR("glFinish\n");
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
@@ -2015,6 +2016,7 @@ static void wglFlush(void)
     escape.code = X11DRV_FLUSH_GL_DRAWABLE;
     escape.gl_drawable = 0;
 
+    ERR("glFlush\n");
     if ((gl = get_gl_drawable( WindowFromDC( ctx->hdc ), 0 )))
     {
         switch (gl->type)
diff --git a/dlls/ws2_32/tests/sock.c b/dlls/ws2_32/tests/sock.c
index 0c39545..acc2783 100644
--- a/dlls/ws2_32/tests/sock.c
+++ b/dlls/ws2_32/tests/sock.c
@@ -4354,7 +4354,11 @@ end:
     if (dst != INVALID_SOCKET)
         closesocket(dst);
     if (hThread != NULL)
+    {
+        dwRet = WaitForSingleObject(hThread, 500);
+        ok(dwRet == WAIT_OBJECT_0, "failed to wait for thread termination: %d\n", GetLastError());
         CloseHandle(hThread);
+    }
     if (ov.hEvent)
         CloseHandle(ov.hEvent);
     HeapFree(GetProcessHeap(), 0, buffer);
diff --git a/include/d3d9types.h b/include/d3d9types.h
index 4cc1195..fd7c4ce 100644
--- a/include/d3d9types.h
+++ b/include/d3d9types.h
@@ -206,7 +206,6 @@
 #define D3DPRESENTFLAG_NOAUTOROTATE         0x00000020 /* d3d9ex, ignore display rotation */
 #define D3DPRESENTFLAG_UNPRUNEDMODE         0x00000040 /* d3d9ex, specify invalid display modes */
 
-#define D3DPRESENT_BACK_BUFFERS_MAX         __MSABI_LONG(3)
 #define D3DPRESENT_RATE_DEFAULT             0x00000000
 
 /**************************** 
@@ -643,8 +642,6 @@ typedef enum _D3DBACKBUFFER_TYPE {
     D3DBACKBUFFER_TYPE_FORCE_DWORD  = 0x7fffffff
 } D3DBACKBUFFER_TYPE;
 
-#define D3DPRESENT_BACK_BUFFER_MAX __MSABI_LONG(3)
-
 typedef enum _D3DBASISTYPE {
    D3DBASIS_BEZIER        = 0,
    D3DBASIS_BSPLINE       = 1,
diff --git a/include/difxapi.h b/include/difxapi.h
index f5149b8..21d43c9 100644
--- a/include/difxapi.h
+++ b/include/difxapi.h
@@ -51,6 +51,8 @@ typedef enum _DIFXAPI_LOG
 
 typedef VOID (CALLBACK *DIFXAPILOGCALLBACK_A)(DIFXAPI_LOG,DWORD,PCSTR,PVOID);
 typedef VOID (CALLBACK *DIFXAPILOGCALLBACK_W)(DIFXAPI_LOG,DWORD,PCWSTR,PVOID);
+typedef VOID (CALLBACK *DIFXLOGCALLBACK_A)(DIFXAPI_LOG,DWORD,PCSTR,PVOID);
+typedef VOID (CALLBACK *DIFXLOGCALLBACK_W)(DIFXAPI_LOG,DWORD,PCWSTR,PVOID);
 
 VOID  WINAPI DIFXAPISetLogCallbackA(DIFXAPILOGCALLBACK_A,VOID*);
 VOID  WINAPI DIFXAPISetLogCallbackW(DIFXAPILOGCALLBACK_W,VOID*);
@@ -62,6 +64,8 @@ DWORD WINAPI DriverPackagePreinstallA(PCSTR,DWORD);
 DWORD WINAPI DriverPackagePreinstallW(PCWSTR,DWORD);
 DWORD WINAPI DriverPackageUninstallA(PCSTR,DWORD,PCINSTALLERINFO_A,BOOL*);
 DWORD WINAPI DriverPackageUninstallW(PCWSTR,DWORD,PCINSTALLERINFO_W,BOOL*);
+VOID  WINAPI SetDifxLogCallbackA(DIFXLOGCALLBACK_A,VOID*);
+VOID  WINAPI SetDifxLogCallbackW(DIFXLOGCALLBACK_W,VOID*);
 
 #ifdef __cplusplus
 }
diff --git a/include/objbase.h b/include/objbase.h
index e1e45c9..23594ac 100644
--- a/include/objbase.h
+++ b/include/objbase.h
@@ -380,8 +380,9 @@ HRESULT WINAPI CoRegisterChannelHook(REFGUID ExtensionGuid, IChannelHook *pChann
 
 typedef enum tagCOWAIT_FLAGS
 {
-    COWAIT_WAITALL   = 0x00000001,
-    COWAIT_ALERTABLE = 0x00000002
+    COWAIT_WAITALL        = 0x00000001,
+    COWAIT_ALERTABLE      = 0x00000002,
+    COWAIT_INPUTAVAILABLE = 0x00000004
 } COWAIT_FLAGS;
 
 HRESULT WINAPI CoWaitForMultipleHandles(DWORD dwFlags,DWORD dwTimeout,ULONG cHandles,LPHANDLE pHandles,LPDWORD lpdwindex);
diff --git a/include/shobjidl.idl b/include/shobjidl.idl
index 627a6df..7dfc4c4 100644
--- a/include/shobjidl.idl
+++ b/include/shobjidl.idl
@@ -3440,6 +3440,54 @@ interface ITransferDestination : IUnknown
                        [out, iid_is(riid)] void **presources);
 }
 
+[
+    uuid(92218cab-ecaa-4335-8133-807fd234c2ee),
+    object,
+    pointer_default(unique)
+]
+interface IAssocHandlerInvoker : IUnknown
+{
+    HRESULT SupportsSelection();
+    HRESULT Invoke();
+}
+
+[
+    uuid(f04061ac-1659-4a3f-a954-775aa57fc083),
+    object,
+    pointer_default(unique)
+]
+interface IAssocHandler : IUnknown
+{
+    HRESULT GetName([out, string] LPWSTR *name);
+    HRESULT GetUIName([out, string] LPWSTR *uiname);
+    HRESULT GetIconLocation([out, string] LPWSTR *path,
+                            [out] int *index);
+    HRESULT IsRecommended();
+    HRESULT MakeDefault([in, string] LPCWSTR description);
+    HRESULT Invoke([in] IDataObject *object);
+    HRESULT CreateInvoker([in] IDataObject *object,
+                          [out] IAssocHandlerInvoker **invoker);
+}
+
+[
+    uuid(973810ae-9599-4b88-9e4d-6ee98c9552da),
+    object,
+    pointer_default(unique)
+]
+interface IEnumAssocHandlers : IUnknown
+{
+    HRESULT Next([in]  ULONG count,
+                 [out, size_is(count), length_is(*fetched)] IAssocHandler **handlers,
+                 [out] ULONG *fetched);
+}
+
+typedef enum ASSOC_FILTER
+{
+    ASSOC_FILTER_NONE = 0,
+    ASSOC_FILTER_RECOMMENDED
+} ASSOC_FILTER;
+cpp_quote("HRESULT WINAPI SHAssocEnumHandlers(PCWSTR extra, ASSOC_FILTER filter, IEnumAssocHandlers **handlersenum);")
+
 /*****************************************************************************
  * ShellObjects typelibrary
  */
diff --git a/include/wine/wined3d.h b/include/wine/wined3d.h
index ef9850b..b48b953 100644
--- a/include/wine/wined3d.h
+++ b/include/wine/wined3d.h
@@ -1237,6 +1237,7 @@ enum wined3d_display_rotation
 #define WINED3D_NO3D                                            0x00000002
 #define WINED3D_VIDMEM_ACCOUNTING                               0x00000004
 #define WINED3D_PRESENT_CONVERSION                              0x00000008
+#define WINED3D_RESTORE_MODE_ON_ACTIVATE                        0x00000010
 
 #define WINED3D_RESZ_CODE                                       0x7fa05000
 
@@ -2405,6 +2406,8 @@ static inline HRESULT wined3d_private_store_set_private_data(struct wined3d_priv
 void __cdecl wined3d_resource_get_desc(const struct wined3d_resource *resource,
         struct wined3d_resource_desc *desc);
 void * __cdecl wined3d_resource_get_parent(const struct wined3d_resource *resource);
+void __cdecl wined3d_resource_get_pitch(const struct wined3d_resource *resource, UINT *row_pitch,
+        UINT *slice_pitch);
 DWORD __cdecl wined3d_resource_get_priority(const struct wined3d_resource *resource);
 void __cdecl wined3d_resource_set_parent(struct wined3d_resource *resource, void *parent);
 DWORD __cdecl wined3d_resource_set_priority(struct wined3d_resource *resource, DWORD priority);
@@ -2462,7 +2465,6 @@ HRESULT __cdecl wined3d_surface_get_blt_status(const struct wined3d_surface *sur
 HRESULT __cdecl wined3d_surface_get_flip_status(const struct wined3d_surface *surface, DWORD flags);
 HRESULT __cdecl wined3d_surface_get_overlay_position(const struct wined3d_surface *surface, LONG *x, LONG *y);
 void * __cdecl wined3d_surface_get_parent(const struct wined3d_surface *surface);
-DWORD __cdecl wined3d_surface_get_pitch(const struct wined3d_surface *surface);
 HRESULT __cdecl wined3d_surface_get_render_target_data(struct wined3d_surface *surface,
         struct wined3d_surface *render_target);
 struct wined3d_resource * __cdecl wined3d_surface_get_resource(struct wined3d_surface *surface);
diff --git a/include/winsock.h b/include/winsock.h
index d5c1e0b..21e984c 100644
--- a/include/winsock.h
+++ b/include/winsock.h
@@ -662,6 +662,7 @@ typedef struct WS(WSAData)
 #define SO_RCVTIMEO                0x1006
 #define SO_ERROR                   0x1007
 #define SO_TYPE                    0x1008
+#define SO_BSP_STATE               0x1009
 
 
 #define IOCPARM_MASK               0x7f
diff --git a/programs/control/control.c b/programs/control/control.c
index 49f006c..9f9005f 100644
--- a/programs/control/control.c
+++ b/programs/control/control.c
@@ -40,7 +40,6 @@ static const WCHAR szP_PRINTERS [] = {'P','R','I','N','T','E','R','S',0};
 static const WCHAR szC_COLOR[] = {'d','e','s','k','.','c','p','l',',',',','2',0};
 static const WCHAR szC_DATETIME[] = {'t','i','m','e','d','a','t','e','.','c','p','l',0};
 static const WCHAR szC_DESKTOP[] = {'d','e','s','k','.','c','p','l',0};
-static const WCHAR szC_FONTS[] = {'m','a','i','n','.','c','p','l',' ','@','3',0};
 static const WCHAR szC_INTERNATIONAL[] = {'i','n','t','l','.','c','p','l',0};
 static const WCHAR szC_KEYBOARD[] = {'m','a','i','n','.','c','p','l',' ','@','1',0};
 static const WCHAR szC_MOUSE[] = {'m','a','i','n','.','c','p','l',0};
diff --git a/programs/explorer/explorer.c b/programs/explorer/explorer.c
index 1b900d0..a4f93bc 100644
--- a/programs/explorer/explorer.c
+++ b/programs/explorer/explorer.c
@@ -639,6 +639,7 @@ static int copy_path_string(LPWSTR target, LPWSTR source)
         while (*source && *source != ',') target[i++] = *source++;
         target[i] = 0;
     }
+    PathRemoveBackslashW(target);
     return i;
 }
 
diff --git a/programs/reg/reg.c b/programs/reg/reg.c
index d299cbf..e9c7d16 100644
--- a/programs/reg/reg.c
+++ b/programs/reg/reg.c
@@ -67,6 +67,22 @@ static int reg_message(int msg)
     return reg_printfW(formatW, msg_buffer);
 }
 
+static int reg_StrCmpNIW(LPCWSTR str, LPCWSTR comp, int len)
+{
+    int i;
+
+    for (i = 0; i < len; i++)
+    {
+        if (!str[i])
+        {
+            len = i + 1;
+            break;
+        }
+    }
+
+    return CompareStringW(CP_ACP, NORM_IGNORECASE, str, len, comp, len) - CSTR_EQUAL;
+}
+
 static HKEY get_rootkey(LPWSTR key)
 {
     static const WCHAR szHKLM[] = {'H','K','L','M',0};
@@ -80,20 +96,20 @@ static HKEY get_rootkey(LPWSTR key)
     static const WCHAR szHKCC[] = {'H','K','C','C',0};
     static const WCHAR szHKEY_CURRENT_CONFIG[] = {'H','K','E','Y','_','C','U','R','R','E','N','T','_','C','O','N','F','I','G',0};
 
-    if (CompareStringW(CP_ACP,NORM_IGNORECASE,key,4,szHKLM,4)==CSTR_EQUAL ||
-        CompareStringW(CP_ACP,NORM_IGNORECASE,key,18,szHKEY_LOCAL_MACHINE,18)==CSTR_EQUAL)
+    if (!reg_StrCmpNIW(key, szHKLM, 4) ||
+        !reg_StrCmpNIW(key, szHKEY_LOCAL_MACHINE, 18))
         return HKEY_LOCAL_MACHINE;
-    else if (CompareStringW(CP_ACP,NORM_IGNORECASE,key,4,szHKCU,4)==CSTR_EQUAL ||
-             CompareStringW(CP_ACP,NORM_IGNORECASE,key,17,szHKEY_CURRENT_USER,17)==CSTR_EQUAL)
+    else if (!reg_StrCmpNIW(key, szHKCU, 4) ||
+             !reg_StrCmpNIW(key, szHKEY_CURRENT_USER, 17))
         return HKEY_CURRENT_USER;
-    else if (CompareStringW(CP_ACP,NORM_IGNORECASE,key,4,szHKCR,4)==CSTR_EQUAL ||
-             CompareStringW(CP_ACP,NORM_IGNORECASE,key,17,szHKEY_CLASSES_ROOT,17)==CSTR_EQUAL)
+    else if (!reg_StrCmpNIW(key, szHKCR, 4) ||
+             !reg_StrCmpNIW(key, szHKEY_CLASSES_ROOT, 17))
         return HKEY_CLASSES_ROOT;
-    else if (CompareStringW(CP_ACP,NORM_IGNORECASE,key,3,szHKU,3)==CSTR_EQUAL ||
-             CompareStringW(CP_ACP,NORM_IGNORECASE,key,10,szHKEY_USERS,10)==CSTR_EQUAL)
+    else if (!reg_StrCmpNIW(key, szHKU, 3) ||
+             !reg_StrCmpNIW(key, szHKEY_USERS, 10))
         return HKEY_USERS;
-    else if (CompareStringW(CP_ACP,NORM_IGNORECASE,key,4,szHKCC,4)==CSTR_EQUAL ||
-             CompareStringW(CP_ACP,NORM_IGNORECASE,key,19,szHKEY_CURRENT_CONFIG,19)==CSTR_EQUAL)
+    else if (!reg_StrCmpNIW(key, szHKCC, 4) ||
+             !reg_StrCmpNIW(key, szHKEY_CURRENT_CONFIG, 19))
         return HKEY_CURRENT_CONFIG;
     else return NULL;
 }
diff --git a/programs/regedit/framewnd.c b/programs/regedit/framewnd.c
index 1635b50..0a56f94 100644
--- a/programs/regedit/framewnd.c
+++ b/programs/regedit/framewnd.c
@@ -286,7 +286,7 @@ static UINT_PTR CALLBACK ExportRegistryFile_OFNHookProc(HWND hdlg, UINT uiMsg, W
                 BOOL export_branch = FALSE;
                 WCHAR* path = GetItemFullPath(g_pChildWnd->hTreeWnd, NULL, FALSE);
                 SendDlgItemMessageW(hdlg, IDC_EXPORT_PATH, WM_SETTEXT, 0, (LPARAM)path);
-                if (path && strlenW(path) > 0)
+                if (path && path[0])
                     export_branch = TRUE;
                 HeapFree(GetProcessHeap(), 0, path);
                 CheckRadioButton(hdlg, IDC_EXPORT_ALL, IDC_EXPORT_SELECTED, export_branch ? IDC_EXPORT_SELECTED : IDC_EXPORT_ALL);
diff --git a/programs/regedit/regproc.c b/programs/regedit/regproc.c
index 1adeddf..80beb21 100644
--- a/programs/regedit/regproc.c
+++ b/programs/regedit/regproc.c
@@ -320,7 +320,7 @@ static BOOL parseKeyName(LPWSTR lpKeyName, HKEY *hKey, LPWSTR *lpKeyPath)
     *hKey = NULL;
 
     for (i = 0; i < REG_CLASS_NUMBER; i++) {
-        if (CompareStringW(LOCALE_USER_DEFAULT, 0, lpKeyName, len, reg_class_namesW[i], len) == CSTR_EQUAL &&
+        if (CompareStringW(LOCALE_USER_DEFAULT, 0, lpKeyName, len, reg_class_namesW[i], -1) == CSTR_EQUAL &&
             len == lstrlenW(reg_class_namesW[i])) {
             *hKey = reg_class_keys[i];
             break;
diff --git a/programs/winecfg/x11drvdlg.c b/programs/winecfg/x11drvdlg.c
index 8d914ad..809068e 100644
--- a/programs/winecfg/x11drvdlg.c
+++ b/programs/winecfg/x11drvdlg.c
@@ -51,8 +51,6 @@ static const WCHAR defaultW[] = {'D','e','f','a','u','l','t',0};
 static const WCHAR explorerW[] = {'E','x','p','l','o','r','e','r',0};
 static const WCHAR explorer_desktopsW[] = {'E','x','p','l','o','r','e','r','\\',
                                            'D','e','s','k','t','o','p','s',0};
-static const WCHAR x11_driverW[] = {'X','1','1',' ','D','r','i','v','e','r',0};
-static const WCHAR default_resW[] = {'8','0','0','x','6','0','0',0};
 
 
 static BOOL updating_ui;
diff --git a/programs/winedbg/be_i386.c b/programs/winedbg/be_i386.c
index 0aafe65..99e3b29 100644
--- a/programs/winedbg/be_i386.c
+++ b/programs/winedbg/be_i386.c
@@ -21,10 +21,10 @@
 #include "debugger.h"
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(winedbg);
-
 #ifdef __i386__
 
+WINE_DEFAULT_DEBUG_CHANNEL(winedbg);
+
   /* db_disasm.c */
 extern void             be_i386_disasm_one_insn(ADDRESS64* addr, int display);
 
diff --git a/programs/winedbg/be_x86_64.c b/programs/winedbg/be_x86_64.c
index 8628025..029f9f1 100644
--- a/programs/winedbg/be_x86_64.c
+++ b/programs/winedbg/be_x86_64.c
@@ -22,10 +22,10 @@
 #include "debugger.h"
 #include "wine/debug.h"
 
-WINE_DEFAULT_DEBUG_CHANNEL(winedbg);
-
 #if defined(__x86_64__)
 
+WINE_DEFAULT_DEBUG_CHANNEL(winedbg);
+
 #define STEP_FLAG 0x00000100 /* single step flag */
 
 static BOOL be_x86_64_get_addr(HANDLE hThread, const CONTEXT* ctx,
diff --git a/server/console.c b/server/console.c
index 2a5ca80..4c2d61d 100644
--- a/server/console.c
+++ b/server/console.c
@@ -299,7 +299,11 @@ static struct object *create_console_input( struct thread* renderer, int fd )
 {
     struct console_input *console_input;
 
-    if (!(console_input = alloc_object( &console_input_ops ))) return NULL;
+    if (!(console_input = alloc_object( &console_input_ops )))
+    {
+        if (fd != -1) close( fd );
+        return NULL;
+    }
     console_input->renderer      = renderer;
     console_input->mode          = ENABLE_PROCESSED_INPUT | ENABLE_LINE_INPUT |
                                    ENABLE_ECHO_INPUT | ENABLE_MOUSE_INPUT | ENABLE_INSERT_MODE |
@@ -323,8 +327,9 @@ static struct object *create_console_input( struct thread* renderer, int fd )
 
     if (!console_input->history || (renderer && !console_input->evt) || !console_input->event)
     {
-	release_object( console_input );
-	return NULL;
+        if (fd != -1) close( fd );
+        release_object( console_input );
+        return NULL;
     }
     if (fd != -1) /* bare console */
     {
@@ -1387,6 +1392,16 @@ DECL_HANDLER(alloc_console)
     int fd;
     int attach = 0;
 
+    if (req->input_fd != -1)
+    {
+        if ((fd = thread_get_inflight_fd( current, req->input_fd )) == -1)
+        {
+            set_error( STATUS_INVALID_PARAMETER );
+            return;
+        }
+    }
+    else fd = -1;
+
     switch (req->pid)
     {
     case 0:
@@ -1394,6 +1409,7 @@ DECL_HANDLER(alloc_console)
         renderer = current;
         if (!(process = current->process->parent))
         {
+            if (fd != -1) close( fd );
             set_error( STATUS_ACCESS_DENIED );
             return;
         }
@@ -1410,23 +1426,19 @@ DECL_HANDLER(alloc_console)
     default:
         /* renderer is current, console to be attached to req->pid */
         renderer = current;
-        if (!(process = get_process_from_id( req->pid ))) return;
+        if (!(process = get_process_from_id( req->pid )))
+        {
+            if (fd != -1) close( fd );
+            return;
+        }
     }
 
     if (attach && process->console)
     {
+        if (fd != -1) close( fd );
         set_error( STATUS_ACCESS_DENIED );
         goto the_end;
     }
-    if (req->input_fd != -1)
-    {
-        if ((fd = thread_get_inflight_fd( current, req->input_fd )) == -1)
-        {
-            set_error( STATUS_INVALID_PARAMETER );
-            goto the_end;
-        }
-    }
-    else fd = -1;
 
     if ((console = (struct console_input*)create_console_input( renderer, fd )))
     {
@@ -1604,12 +1616,12 @@ DECL_HANDLER(create_console_output)
     else fd = -1;
     if (!(console = console_input_get( req->handle_in, FILE_WRITE_PROPERTIES )))
     {
-        close(fd);
+        if (fd != -1) close( fd );
         return;
     }
     if (console_input_is_bare( console ) ^ (fd != -1))
     {
-        close( fd );
+        if (fd != -1) close( fd );
         release_object( console );
         set_error( STATUS_INVALID_HANDLE );
         return;
diff --git a/server/file.c b/server/file.c
index cceb8ad..abda2c3 100644
--- a/server/file.c
+++ b/server/file.c
@@ -120,21 +120,25 @@ struct file *create_file_for_fd( int fd, unsigned int access, unsigned int shari
     if (fstat( fd, &st ) == -1)
     {
         file_set_error();
+        close( fd );
         return NULL;
     }
 
-    if ((file = alloc_object( &file_ops )))
+    if (!(file = alloc_object( &file_ops )))
     {
-        file->mode = st.st_mode;
-        file->access = default_fd_map_access( &file->obj, access );
-        if (!(file->fd = create_anonymous_fd( &file_fd_ops, fd, &file->obj,
-                                              FILE_SYNCHRONOUS_IO_NONALERT )))
-        {
-            release_object( file );
-            return NULL;
-        }
-        allow_fd_caching( file->fd );
+        close( fd );
+        return NULL;
+    }
+
+    file->mode = st.st_mode;
+    file->access = default_fd_map_access( &file->obj, access );
+    if (!(file->fd = create_anonymous_fd( &file_fd_ops, fd, &file->obj,
+                                          FILE_SYNCHRONOUS_IO_NONALERT )))
+    {
+        release_object( file );
+        return NULL;
     }
+    allow_fd_caching( file->fd );
     return file;
 }
 
diff --git a/server/process.c b/server/process.c
index 7b9a3b2..4a356b9 100644
--- a/server/process.c
+++ b/server/process.c
@@ -911,14 +911,21 @@ DECL_HANDLER(new_process)
     }
 
     /* build the startup info for a new process */
-    if (!(info = alloc_object( &startup_info_ops ))) return;
+    if (!(info = alloc_object( &startup_info_ops )))
+    {
+        close( socket_fd );
+        return;
+    }
     info->exe_file = NULL;
     info->process  = NULL;
     info->data     = NULL;
 
     if (req->exe_file &&
         !(info->exe_file = get_file_obj( current->process, req->exe_file, FILE_READ_DATA )))
+    {
+        close( socket_fd );
         goto done;
+    }
 
     info->data_size = get_req_data_size();
     info->info_size = min( req->info_size, info->data_size );
@@ -929,7 +936,11 @@ DECL_HANDLER(new_process)
         data_size_t env_size = info->data_size - info->info_size;
         data_size_t info_size = min( req->info_size, FIELD_OFFSET( startup_info_t, curdir_len ));
 
-        if (!(info->data = mem_alloc( sizeof(*info->data) + env_size ))) goto done;
+        if (!(info->data = mem_alloc( sizeof(*info->data) + env_size )))
+        {
+            close( socket_fd );
+            goto done;
+        }
         memcpy( info->data, get_req_data(), info_size );
         memset( (char *)info->data + info_size, 0, sizeof(*info->data) - info_size );
         memcpy( info->data + 1, (const char *)get_req_data() + req->info_size, env_size );
@@ -940,7 +951,11 @@ DECL_HANDLER(new_process)
     {
         data_size_t pos = sizeof(*info->data);
 
-        if (!(info->data = memdup( get_req_data(), info->data_size ))) goto done;
+        if (!(info->data = memdup( get_req_data(), info->data_size )))
+        {
+            close( socket_fd );
+            goto done;
+        }
 #define FIXUP_LEN(len) do { (len) = min( (len), info->info_size - pos ); pos += (len); } while(0)
         FIXUP_LEN( info->data->curdir_len );
         FIXUP_LEN( info->data->dllpath_len );
diff --git a/server/region.c b/server/region.c
index 8b85c34..464c5ad 100644
--- a/server/region.c
+++ b/server/region.c
@@ -108,7 +108,7 @@ static const rectangle_t empty_rect;  /* all-zero rectangle for empty regions */
 /* add a rectangle to a region */
 static inline rectangle_t *add_rect( struct region *reg )
 {
-    if (reg->num_rects >= reg->size - 1)
+    if (reg->num_rects >= reg->size)
     {
         rectangle_t *new_rect = realloc( reg->rects, 2 * sizeof(rectangle_t) * reg->size );
         if (!new_rect)
diff --git a/server/thread.c b/server/thread.c
index 50d6940..ba3f1d5 100644
--- a/server/thread.c
+++ b/server/thread.c
@@ -219,11 +219,16 @@ struct thread *create_thread( int fd, struct process *process )
 
     if (process->is_terminating)
     {
+        close( fd );
         set_error( STATUS_PROCESS_IS_TERMINATING );
         return NULL;
     }
 
-    if (!(thread = alloc_object( &thread_ops ))) return NULL;
+    if (!(thread = alloc_object( &thread_ops )))
+    {
+        close( fd );
+        return NULL;
+    }
 
     init_thread_structure( thread );
 
@@ -236,6 +241,7 @@ struct thread *create_thread( int fd, struct process *process )
 
     if (!(thread->id = alloc_ptid( thread )))
     {
+        close( fd );
         release_object( thread );
         return NULL;
     }
@@ -1047,6 +1053,8 @@ int thread_add_inflight_fd( struct thread *thread, int client, int server )
             thread->inflight[i].server = server;
             return i;
         }
+
+    close( server );
     return -1;
 }
 
